### Error messages for BaseTypeChecker
receiver.invalid=incompatible types.%nfound   : %s%nrequired: %s
type.anno.before.modifier=write type annotation %s immediately before type, after modifiers %s
type.anno.before.decl.anno=write type annotations %s immediately before type, after declaration annotation %s

array.initializer.type.incompatible=incompatible types in array initializer.%nfound   : %s%nrequired: %s
assignment.type.incompatible=incompatible types in assignment.%nfound   : %s%nrequired: %s
compound.assignment.type.incompatible=expression type incompatible with left-hand side in compound assignment.%nfound   : %s%nrequired: %s
unary.increment.type.incompatible=increment result incompatible with variable declared type.%nfound   : %s%nrequired: %s
unary.decrement.type.incompatible=decrement result incompatible with variable declared type.%nfound   : %s%nrequired: %s
enhancedfor.type.incompatible=incompatible types in enhanced for loop.%nfound   : %s%nrequired: %s
vector.copyinto.type.incompatible=incompatible component type in Vector.copyinto.%nfound   : %s%nrequired: %s
return.type.incompatible=incompatible types in return.%ntype of expression: %s%nmethod return type: %s
annotation.type.incompatible=incompatible types in annotation.%nfound   : %s%nrequired: %s
conditional.type.incompatible=incompatible types in conditional expression.%nfound   : %s%nrequired: %s
type.argument.type.incompatible=incompatible type argument for type parameter %s of %s.%nfound   : %s%nrequired: %s
argument.type.incompatible=incompatible argument for parameter %s of %s.%nfound   : %s%nrequired: %s
varargs.type.incompatible=incompatible types in varargs.%nfound   : %s%nrequired: %s
type.incompatible=incompatible types.%nfound   : %s%nrequired: %s
bound.type.incompatible=incompatible bounds in %s%ntype: %s%nupper bound: %s%nlower bound: %s
monotonic.type.incompatible=cannot assign %s to %s (monotonic type).%ntype of right-hand-side: %s
type.invalid=invalid type: annotations %s in type "%s"
type.invalid.conflicting.annos=invalid type: conflicting annotations %s in type "%s"
type.invalid.too.few.annotations=invalid type: missing annotations %s in type "%s"
type.invalid.annotations.on.use=invalid type: annotations %s conflict with declaration of type %s
cast.unsafe=cast from "%s" to "%s" cannot be statically verified
invariant.cast.unsafe=cannot cast from "%s" to "%s"
cast.unsafe.constructor.invocation=constructor invocation cast from "%s" to "%s" cannot be statically verified
exception.parameter.invalid=invalid type in catch argument.%nfound   : %s%nrequired: %s
throw.type.invalid=invalid type thrown.%nfound   : %s%nrequired: %s
expression.unparsable.type.invalid=Expression invalid in dependent type annotation: %s
explicit.annotation.ignored=The qualifier %s is ignored in favor of %s. Either delete %s or change it to %s.

override.return.invalid=Incompatible return type.%nfound   : %s%nrequired: %s%nConsequence: method%n  %s in %s%ncannot override%n  %s in %s
override.param.invalid=Incompatible parameter type for %s.%nfound   : %s%nrequired: %s%nConsequence: method%n  %s in %s%ncannot override%n  %s in %s
override.receiver.invalid=Incompatible receiver type%nfound   : %s%nrequired: %s%nConsequence: method%n  %s in %s%ncannot override%n  %s in %s
methodref.return.invalid=Incompatible return type%nfound   : %s%nrequired: %s%nConsequence: method%n  %s in %s%nis not a valid method reference for%n  %s in %s
methodref.param.invalid=Incompatible parameter type for %s%nfound   : %s%nrequired: %s%nConsequence: method%n  %s in %s%nis not a valid method reference for%n  %s in %s
methodref.receiver.invalid=Incompatible receiver type%nfound   : %s%nrequired: %s%nConsequence: method%n  %s in %s%nis not a valid method reference for%n  %s in %s
methodref.receiver.bound.invalid=Incompatible receiver type%nfound   : %s%nrequired: %s%nConsequence: method%n  %s%nis not a valid method reference for%n  %s in %s
lambda.param.type.incompatible=incompatible parameter types for parameter %s in lambda expression.%nfound   : %s%nrequired: %s

# The first argument is a string like "annotation @KeyFor on parameter 'param1'"
# or "postcondition @EnsuresKeyFor on the declaration".
expression.parameter.name.invalid=The %s of method '%s' contains invalid identifier '%s'. Use "#%d" for the formal parameter.
expression.parameter.name.shadows.field=The %s of method '%s' contains ambiguous identifier '%s'. Use "this.%s" for the field, or "#%d" for the formal parameter.

inconsistent.constructor.type=Constructor type (%s) is a subtype of the top type (%s), therefore it cannot be statically verified.
super.invocation.invalid=Constructor of type %s cannot call %s of type %s.
this.invocation.invalid=Constructor of type %s cannot call %s of type %s.
method.invocation.invalid=call to %s not allowed on the given receiver.%nfound   : %s%nrequired: %s
constructor.invocation.invalid=creation of %s not allowed with given receiver.%nfound   : %s%nrequired: %s
type.arguments.not.inferred=Could not infer type arguments for %s.
type.argument.invalid.hasqualparam=Types with qualifier parameters are not allowed as type arguments.%nfound qualifier parameter of %s hierarchy.
declaration.inconsistent.with.extends.clause=Class %s cannot extend %s
declaration.inconsistent.with.implements.clause=Class %s cannot implement %s

unallowed.access=access of the field (%s) is not permitted on receiver of type (%s)
cast.redundant=Redundant cast;%ntype   : %s

# TODO: The call.{constructor,method} messages should take an argument indicating which method or constructor is the problem
purity.deterministic.constructor=a constructor cannot be deterministic
purity.deterministic.void.method=a method without return value cannot be deterministic
purity.invalid.methodref=Incompatible purity declaration%nMethod%n  %s in %s%n  is not a valid method reference for%n  %s in %s%nfound   : %s%nrequired: %s
purity.invalid.overriding=Incompatible purity declaration%nMethod%n  %s in %s%n  cannot override%n  %s in %s%nfound   : %s%nrequired: %s
purity.not.deterministic.assign.array=array assignment not allowed in deterministic method
purity.not.deterministic.assign.field=field assignment not allowed in deterministic method
purity.not.deterministic.call=call to non-deterministic method %s not allowed in deterministic method
purity.not.deterministic.catch=catch block not allowed in deterministic method
purity.not.deterministic.object.creation=object creation not allowed in deterministic method
purity.not.deterministic.not.sideeffectfree.assign.array=array assignment not allowed in deterministic side-effect-free method
purity.not.deterministic.not.sideeffectfree.assign.field=field assignment not allowed in deterministic side-effect-free method
purity.not.deterministic.not.sideeffectfree.call=call to non-deterministic side-effecting %s not allowed in deterministic side-effect-free method
purity.not.sideeffectfree.call=call to side-effecting %s not allowed in side-effect-free method
purity.more.deterministic=the method %s could be declared as @Deterministic
purity.more.pure=the method %s could be declared as @Pure
purity.more.sideeffectfree=the method %s could be declared as @SideEffectFree

flowexpr.parse.index.too.big=the method does not have a parameter %s
flowexpr.parse.error=cannot parse the expression %s
flowexpr.parse.error.postcondition=error parsing the postcondition expression for %s%ncannot parse the expression %s
flowexpr.parse.context.not.determined=could not determine the context at '%s' with which to parse expressions
flowexpr.parameter.not.final=parameter %s in '%s' is not effectively final (i.e., it gets re-assigned)
contracts.precondition.not.satisfied=precondition of %s is not satisfied.%nfound   : %s%nrequired: %s
contracts.postcondition.not.satisfied=postcondition of %s is not satisfied.%nfound   : %s%nrequired: %s
contracts.conditional.postcondition.not.satisfied=conditional postcondition is not satisfied when %s returns %s.%nfound   : %s%nrequired: %s
contracts.conditional.postcondition.invalid.returntype=this annotation is only valid for methods with return type 'boolean'
# Same text for "override" and "methodref", but different key.
contracts.precondition.override.invalid=Subclass precondition is stronger for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.postcondition.override.invalid=Subclass postcondition is weaker for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.conditional.postcondition.true.override.invalid=Subclass postcondition with result=true is weaker for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.conditional.postcondition.false.override.invalid=Subclass postcondition with result=false is weaker for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.precondition.methodref.invalid=Subclass precondition is stronger for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.postcondition.methodref.invalid=Subclass postcondition is weaker for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.conditional.postcondition.true.methodref.invalid=Subclass postcondition with result=true is weaker for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s
contracts.conditional.postcondition.false.methodref.invalid=Subclass postcondition with result=false is weaker for '%s' in %s.%n  In superclass %s: %s%n  In subclass %s: %s

lambda.unimplemented=This version of the Checker Framework does not type-check lambda expressions.
methodref.inference.unimplemented=This version of the Checker Framework does not type-check method references with implicit type arguments.

invalid.polymorphic.qualifier.use=Cannot use polymorphic qualifier %s on a field unless the class is annotated with @HasQualifierParameter
missing.has.qual.param=Missing @HasQualifierParameter for hierarchy %s.%nClass extends or implements a type that has a qualifier parameter.
conflicting.qual.param=Conflicting @HasQualifierParameter.%nClass has both @HasQualifierParameter and @NoQualifierParameter for %s.


field.invariant.not.found=the field invariant annotation refers to fields not found in a superclass%nfields not found: %s
field.invariant.not.final=the field invariant annotation refers to fields that are not final%nfields not final: %s
field.invariant.not.subtype=the qualifier for field %s is not a subtype of the declared type%nfound: %s%ndeclared type: %s
field.invariant.not.wellformed=the field invariant annotation does not have equal numbers of fields and qualifiers.
field.invariant.not.found.superclass=the field invariant annotation is missing fields that are listed in the superclass field invariant.%nfields not found: %s
field.invariant.not.subtype.superclass=the qualifier for field %s is not a subtype of the qualifier in the superclass field invariant%nfound: %s%nsuperclass type: %s

invalid.annotation.location.bytecode=found annotation in unexpected location in bytecode on element: %s %nUse -AignoreInvalidAnnotationLocations to suppress this warning
instanceof.unsafe='%s' instanceof '%s' cannot be statically verified.

anno.on.irrelevant=Annotation %s is not applicable to %s

type.inference.not.same=incorrect inferred types\ntype variable: %s\ninferred: %s\njava type: %s
type.inference.crash=type inference crashed: %s
