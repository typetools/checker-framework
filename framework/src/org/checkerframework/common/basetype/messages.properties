### Error messages for BaseTypeChecker
assignability.invalid=Cannot (re-)assign %s through the reference: %s
receiver.invalid=incompatible types.\nfound   : %s\nrequired: %s

array.initializer.type.incompatible=incompatible types in array initializer.\nfound   : %s\nrequired: %s
assignment.type.incompatible=incompatible types in assignment.\nfound   : %s\nrequired: %s
compound.assignment.type.incompatible=incompatible result type in compound assignment.\nfound   : %s\nrequired: %s
enhancedfor.type.incompatible=incompatible types in enhanced for loop.\nfound   : %s\nrequired: %s
vector.copyinto.type.incompatible=incompatible component type in Vector.copyinto.\nfound   : %s\nrequired: %s
return.type.incompatible=incompatible types in return.\nfound   : %s\nrequired: %s
annotation.type.incompatible=incompatible types in annotation.\nfound   : %s\nrequired: %s
conditional.type.incompatible=incompatible types in conditional expression.\nfound   : %s\nrequired: %s
type.argument.type.incompatible=incompatible types in type argument.\nfound   : %s\nrequired: %s
argument.type.incompatible=incompatible types in argument.\nfound   : %s\nrequired: %s
varargs.type.incompatible=incompatible types in varargs.\nfound   : %s\nrequired: %s
type.incompatible=incompatible types.\nfound   : %s\nrequired: %s
bound.type.incompatible=incompatible bounds in %s\ntype: %s\nupper bound: %s\nlower bound: %s
monotonic.type.incompatible=cannot assign %s to %s (monotonic type).\nfull type found: %s
type.invalid=invalid type: annotations %s in type "%s"
type.invalid.conflicting.annos=invalid type: conflicting annotations %s in type "%s"
type.invalid.too.few.annotations=invalid type: missing annotations %s in type "%s"
type.invalid.annotations.on.use=invalid type: annotations %s conflict with declaration of type %s
cast.unsafe="%s" may not be casted to the type "%s"
exception.parameter.invalid=invalid type in catch argument.\nfound   : %s\nrequired: %s
throw.type.invalid=invalid type thrown.\nfound   : %s\nrequired: %s
expression.unparsable.type.invalid=Expression in dependent type annotation invalid: %s

override.return.invalid=Incompatible return type.\nMethod\n  %s in %s\ncannot override\n  %s in %s\nfound   : %s\nrequired: %s
override.param.invalid=Incompatible parameter type.\nMethod\n  %s in %s\ncannot override\n  %s in %s\nfound   : %s\nrequired: %s
override.receiver.invalid=Incompatible receiver type\nMethod\n  %s in %s\ncannot override\n  %s in %s\nfound   : %s\nrequired: %s
methodref.return.invalid=Incompatible return type\nMethod\n  %s in %s\nis not a valid method reference for\n  %s in %s\nfound   : %s\nrequired: %s
methodref.param.invalid=Incompatible parameter type\nMethod\n  %s in %s\nis not a valid method reference for\n  %s in %s\nfound   : %s\nrequired: %s
methodref.receiver.invalid=Incompatible receiver type\nMethod\n  %s in %s\nis not a valid method reference for\n  %s in %s\nfound   : %s\nrequired: %s
methodref.receiver.bound.invalid=Incompatible receiver type\nMethod\n  %s\nis not a valid method reference for\n  %s in %s\nfound   : %s\nrequired: %s
lambda.param.type.incompatible=incompatible parameter types in lambda expression.\nfound   : %s\nrequired: %s

method.declaration.expression.parameter.name=The annotation on parameter '%s' of method '%s' refers to formal parameter '%s' by name. Please use "#%s" instead of "%s".
contracts.precondition.expression.parameter.name=The precondition on the declaration of method '%s' refers to formal parameter '%s' by name. Please use "#%s" instead of "%s".
contracts.postcondition.expression.parameter.name=The postcondition on the declaration of method '%s' refers to formal parameter '%s' by name. Please use "#%s" instead of "%s".
contracts.conditional.postcondition.expression.parameter.name=The conditional postcondition on the declaration of method '%s' refers to formal parameter '%s' by name. Please use "#%s" instead of "%s".

method.invocation.invalid=call to %s not allowed on the given receiver.\nfound   : %s\nrequired: %s
constructor.invocation.invalid=creation of %s not allowed with given receiver;\nfound   : %s\nrequired: %s
type.arguments.not.inferred=Could not infer type arguments for %s.

unallowed.access=access of the field (%s) is not permitted on receiver of type (%s)
cast.redundant=Redundant cast;\ntype   : %s

purity.deterministic.void.method=a deterministic method without return value is redundant
purity.deterministic.constructor=a deterministic constructor is redundant
purity.invalid.overriding=Incompatible purity declaration\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nfound   : %s\nrequired: %s
purity.invalid.methodref=Incompatible purity declaration\nMethod\n  %s in %s\n  is not a valid method reference for\n  %s in %s\nfound   : %s\nrequired: %s
purity.not.deterministic.catch=catch block not allowed in deterministic method
purity.not.deterministic.call=call to non-deterministic method %s not allowed in deterministic method
purity.not.sideeffectfree.call=call to non-side-effect-free method %s not allowed in side-effect-free method
purity.not.deterministic.not.sideeffectfree.call=call to non-deterministic non-side-effect-free method %s not allowed in deterministic side-effect-free method
purity.not.sideeffectfree.object.creation=object creation using a non-side-effect-free constructor not allowed in side-effect-free method
purity.not.deterministic.not.sideeffectfree.object.creation=object creation not allowed in deterministic side-effect-free method
purity.not.deterministic.not.sideeffectfree.assign.field=field assignment not allowed in deterministic side-effect-free method
purity.not.deterministic.not.sideeffectfree.assign.array=array assignment not allowed in deterministic side-effect-free method
purity.not.deterministic.object.creation=object creation not allowed in deterministic method
purity.not.deterministic.assign.field=field assignment not allowed in deterministic method
purity.not.deterministic.assign.array=array assignment not allowed in deterministic method
purity.more.pure=the method %s could be declared as @Pure
purity.more.sideeffectfree=the method %s could be declared as @SideEffectFree
purity.more.deterministic=the method %s could be declared as @Deterministic

flowexpr.parse.index.too.big=the method does not have a parameter %s
flowexpr.parse.error=cannot parse the expression %s
flowexpr.parse.error.postcondition=error parsing the postcondition expression for %s\ncannot parse the expression '%s'
flowexpr.parse.context.not.determined=could not determine the context at '%s' with which to parse expressions
flowexpr.parameter.not.final=parameter %s in '%s' is not effectively final (i.e., it gets re-assigned)
contracts.precondition.not.satisfied=the called method '%s' has a precondition '%s' that is not satisfied
contracts.postcondition.not.satisfied=the postcondition about '%s' of this method is not satisfied
contracts.conditional.postcondition.not.satisfied=the conditional postcondition about '%s' at this return statement is not satisfied
contracts.conditional.postcondition.invalid.returntype=this annotation is only valid for methods with return type 'boolean'
# Same text for "override" and "methodref", but different key.
contracts.precondition.override.invalid=Precondition must be no stronger than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nPrecondition is too strong: '%s' for '%s'
contracts.postcondition.override.invalid=Postcondition must be no weaker than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nBase postcondition is too strong: '%s' for '%s'
contracts.conditional.postcondition.true.override.invalid=Conditional postcondition must be no weaker than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nBase postcondition with result=true is too strong: '%s' for '%s'
contracts.conditional.postcondition.false.override.invalid=Conditional postcondition must be no weaker than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nBase postcondition with result=false is too strong: '%s' for '%s'
contracts.precondition.methodref.invalid=Precondition must be no stronger than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nPrecondition is too strong: '%s' for '%s'
contracts.postcondition.methodref.invalid=Postcondition must be no weaker than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nBase postcondition is too strong: '%s' for '%s'
contracts.conditional.postcondition.true.methodref.invalid=Conditional postcondition must be no weaker than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nBase postcondition with result=true is too strong: '%s' for '%s'
contracts.conditional.postcondition.false.methodref.invalid=Conditional postcondition must be no weaker than in superclass.\nMethod\n  %s in %s\n  cannot override\n  %s in %s\nBase postcondition with result=false is too strong: '%s' for '%s'

lambda.unimplemented=This version of the Checker Framework does not type-check lambda expressions.
methodref.inference.unimplemented=This version of the Checker Framework does not type-check method references with implicit type arguments.

field.invariant.not.found=the field invariant annotation refers to fields not found in a superclass\nfields not found: %s
field.invariant.not.final=the field invariant annotation refers to fields that are not final\nfields not final: %s
field.invariant.not.subtype=the qualifier for field %s is not a subtype of the declared type\nfound: %s\ndeclared type: %s
field.invariant.not.wellformed=the field invariant annotation does not have equal numbers of fields and qualifiers.
field.invariant.not.found.superclass=the field invariant annotation is missing fields that are listed in the superclass field invariant.\nfields not found: %s
field.invariant.not.subtype.superclass=the qualifier for field %s is not a subtype of the qualifier in the superclass field invariant\nfound: %s\nsuperclass type: %s
