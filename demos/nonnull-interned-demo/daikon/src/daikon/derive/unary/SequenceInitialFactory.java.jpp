#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPEDOUBLE) || defined(TYPELONG))
  #error "TYPEDOUBLE or TYPELONG must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME SequenceInitialFactory
  #define PROGLANGTYPE ProglangType.INT_ARRAY
  #define SEQUENCEINITIAL SequenceInitial
#elif defined(TYPEDOUBLE)
  #define CLASSNAME SequenceInitialFactoryFloat
  #define PROGLANGTYPE ProglangType.DOUBLE_ARRAY
  #define SEQUENCEINITIAL SequenceInitialFloat
#endif

// ***** This file is automatically generated from SequenceInitialFactory.java.jpp

package daikon.derive.unary;

import daikon.*;
import utilMDE.*;
import java.util.logging.Logger;

public final class CLASSNAME extends UnaryDerivationFactory {

  public static final Logger debug =
    Logger.getLogger("daikon.derive.binary.SequenceInitialFactory");

  public UnaryDerivation[] instantiate(VarInfo vi) {
    // System.out.println("SequenceInitialFactory.instantiate(" + vi + ")");
    // return (UnaryDerivation)new SequenceFirst(vi);

    if (! SEQUENCEINITIAL.dkconfig_enabled) {
      return null;
    }

    if (vi.rep_type != PROGLANGTYPE)
      return null;

    // System.out.println("SequenceInitial.applicable(" + vi.name + ") = "
    //                    + SequenceInitial.applicable(vi));

    if (! SEQUENCEINITIAL.applicable(vi)) {
      Global.tautological_suppressed_derived_variables += 4;
      return null;
    }

    // by default, we use the indices 0, 1, -1, -2.
    int lowerbound = -2;
    int upperbound = 1;

    boolean suppress_zero = false;
    // We know that var.~ll~[0] == var and var.~ll~.field[0] == var.field.
    if (vi.isClosure()) {
      suppress_zero = true;
      if ((lowerbound == 0) && (upperbound == 0))
        Global.tautological_suppressed_derived_variables += 4;
        return null;
    }

    int num_invs = upperbound - lowerbound + 1 - (suppress_zero ? 1 : 0);
    Assert.assertTrue(num_invs > 0,
                      "No SequenceInitial invariants to instantiate; "
                      + "lowerbound=" + lowerbound
                      + ", upperbound=" + upperbound
                      + ", suppress_zero=" + suppress_zero);
    UnaryDerivation[] result = new UnaryDerivation[num_invs];
    int j=0;
    for (int i=lowerbound; i<=upperbound; i++) {
      if (! ((i == 0) && suppress_zero)) {
        result[j] = new SEQUENCEINITIAL(vi, i);
        j++;
      }
    }
    // No longer needed (I hope!).
    // Assert.assertTrue(j == num_invs,
    //                   "SequenceInitial(" + vi.name + "): "
    //                   + "j=" + j + ", num_invs=" + num_invs
    //                   + ",lowerbound=" + lowerbound
    //                   + ", upperbound=" + upperbound
    //                   + ", suppress_zero=" + suppress_zero);

    Global.tautological_suppressed_derived_variables += 4 - num_invs;

    return result;
  }

}
