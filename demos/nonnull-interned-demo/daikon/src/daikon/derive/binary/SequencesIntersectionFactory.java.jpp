#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(SCALAR) || defined(STRING) || defined(FLOAT))
  #error "One of SCALAR, FLOAT, or STRING must be defined"
#endif

#if defined(SCALAR)
  #undef SCALAR
  #define PROGLANG_INT ProglangType.INT
  #define PROGLANG_INT_ARRAY ProglangType.INT_ARRAY
  #define SCALARSEQUENCESINTERSECTIONFACTORY SequenceScalarIntersectionFactory
  #define SCALARSEQUENCESINTERSECTIONFACTORY_STRING "SequenceScalarIntersectionFactory"
  #define SCALARSEQUENCESINTERSECTION SequenceScalarIntersection
#elif defined(FLOAT)
  #define PROGLANG_INT ProglangType.DOUBLE
  #define PROGLANG_INT_ARRAY ProglangType.DOUBLE_ARRAY
  #define SCALARSEQUENCESINTERSECTIONFACTORY SequenceFloatIntersectionFactory
  #define SCALARSEQUENCESINTERSECTIONFACTORY_STRING "SequenceFloatIntersectionFactory"
  #define SCALARSEQUENCESINTERSECTION SequenceFloatIntersection
#elif defined(STRING)
  #define THIS_UNDEF_OF_STRING is for "ProglangType.STRING"
  #undef STRING
  #define PROGLANG_INT ProglangType.STRING
  #define PROGLANG_INT_ARRAY ProglangType.STRING_ARRAY
  #define SCALARSEQUENCESINTERSECTIONFACTORY SequenceStringIntersectionFactory
  #define SCALARSEQUENCESINTERSECTIONFACTORY_STRING "SequenceStringIntersectionFactory"
  #define SCALARSEQUENCESINTERSECTION SequenceStringIntersection
#else
  #error "One of SCALAR, FLOAT, or STRING must be defined"
#endif

// ***** This file is automatically generated from SequencesIntersectionFactory.java.jpp

package daikon.derive.binary;

import daikon.*;
import daikon.derive.Derivation;

import java.util.logging.Logger;
import java.util.logging.Level;

// This controls derivations which use the scalar as an index into the
// sequence, such as getting the element at that index or a subsequence up
// to that index.

public final class SCALARSEQUENCESINTERSECTIONFACTORY extends BinaryDerivationFactory {

  /** Debug tracer. **/
  private static final Logger debug =
    Logger.getLogger("daikon.derive.binary." + SCALARSEQUENCESINTERSECTIONFACTORY_STRING);

  public BinaryDerivation[] instantiate(VarInfo seq1, VarInfo seq2) {

    if (! SCALARSEQUENCESINTERSECTION.dkconfig_enabled) {
      return null;
    }

    if ((seq1.rep_type != PROGLANG_INT_ARRAY)
        || (seq2.rep_type != PROGLANG_INT_ARRAY)) {
      return null;
    }


    // Intersect only sets with the same declared element type
    if (!seq1.type.base().equals(seq2.type.base()))
      return null;

    // For now, do nothing if the sequences are derived.
    //    if ((seq1.derived != null) || (seq2.derived != null))
    //  return null;

    // We allow double derivations of predicate slices because it may be interesting
    if ((seq1.derived != null)) {
      Derivation derivation = seq1.derived;
      if (!(derivation instanceof SequencesPredicate)) return null;
    }

    if ((seq2.derived != null)) {
      Derivation derivation = seq2.derived;
      if (!(derivation instanceof SequencesPredicate)) return null;
    }

    if (debug.isLoggable(Level.FINE)) {
      debug.fine ("Instantiatiating " + seq1.name() + " and " + seq2.name());
      debug.fine ("  in " + seq1.ppt.name());
    }


    return new BinaryDerivation[] {
      new SCALARSEQUENCESINTERSECTION(seq1, seq2) };
  }
}
