#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#define stringify(NAME) #NAME

// ***** This file is automatically generated from MathMDE.java.jpp

package utilMDE;
import java.util.*;


/** Mathematical utilities. */
public final class MathMDE {
  private MathMDE() { throw new Error("do not instantiate"); }


  ///
  /// Function versions of Java operators
  ///

  public static int negate(int a) {
    return -a;
  }

  public static long negate(long a) {
    return -a;
  }

  public static double negate(double a) {
    return -a;
  }

  public static int bitwiseComplement(int a) {
    return ~a;
  }

  public static long bitwiseComplement(long a) {
    return ~a;
  }

  public static int mul(int x, int y) {
    return x * y;
  }

  public static long mul(long x, long y) {
    return x * y;
  }

  public static double mul(double x, double y) {
    return x * y;
  }

  public static int div(int x, int y) {
    return x / y;
  }

  public static long div(long x, long y) {
    return x / y;
  }

  public static double div(double x, double y) {
    return x / y;
  }

  public static int mod(int x, int y) {
    return x % y;
  }

  public static long mod(long x, long y) {
    return x % y;
  }

  public static int lshift(int x, int y) {
    return x << y;
  }

  public static long lshift(long x, long y) {
    return x << y;
  }

  public static int rshiftSigned(int x, int y) {
    return x >> y;
  }

  public static long rshiftSigned(long x , long y) {
    return x >> y;
  }

  public static int rshiftUnsigned(int x, int y) {
    return x >>> y;
  }

  public static long rshiftUnsigned(long x, long y) {
    return x >>> y;
  }

  public static int bitwiseAnd(int x, int y) {
    return x & y;
  }

  public static long bitwiseAnd(long x, long y) {
    return x & y;
  }

  public static int logicalAnd(int x, int y) {
    return ((x!=0) && (y!=0)) ? 1 : 0;
  }

  public static long logicalAnd(long x, long y) {
    return ((x!=0) && (y!=0)) ? 1 : 0;
  }

  public static int bitwiseXor(int x, int y) {
    return x ^ y;
  }

  public static long bitwiseXor(long x, long y) {
    return x ^ y;
  }

  public static int logicalXor(int x, int y) {
    return ((x!=0) ^ (y!=0)) ? 1 : 0;
  }

  public static long logicalXor(long x, long y) {
    return ((x!=0) ^ (y!=0)) ? 1 : 0;
  }


  public static int bitwiseOr(int x, int y) {
    return x | y;
  }

  public static long bitwiseOr(long x, long y) {
    return x | y;
  }

  public static int logicalOr(int x, int y) {
    return ((x!=0) || (y!=0)) ? 1 : 0;
  }

  public static long logicalOr(long x, long y) {
    return ((x!=0) || (y!=0)) ? 1 : 0;
  }


  ///
  /// negation
  ///

  public static int sign(int a) {
    if (a==0)
      return 0;
    else if (a>0)
      return 1;
    else
      return -1;
  }


  ///
  /// exponentiation
  ///

  /**
   * Returns of value of the first argument raised to the
   * power of the second argument.
   * @see Math#pow(double, double)
   **/
  public static int pow(int base, int expt) throws ArithmeticException {
    return pow_fast(base, expt);
  }

  public static long pow(long base, long expt) throws ArithmeticException {
    return pow_fast(base, expt);
  }

  public static int pow_fast(int base, int expt) throws ArithmeticException {
    if (expt < 0)
      throw new ArithmeticException("Negative base passed to pow");

    int this_square_pow = base;
    int result = 1;
    while (expt>0) {
      if ((expt & 1) != 0)
        result *= this_square_pow;
      expt >>= 1;
      this_square_pow *= this_square_pow;
    }
    return result;
  }

  public static long pow_fast(long base, long expt) throws ArithmeticException {
    if (expt < 0)
      throw new ArithmeticException("Negative base passed to pow");

    long this_square_pow = base;
    long result = 1;
    while (expt>0) {
      if ((expt & 1) != 0)
        result *= this_square_pow;
      expt >>= 1;
      this_square_pow *= this_square_pow;
    }
    return result;
  }

  public static int pow_slow(int base, int expt) throws ArithmeticException {
    if (expt < 0)
      throw new ArithmeticException("Negative base passed to pow");

    int result = 1;
    for (int i=0; i<expt; i++)
      result *= base;
    return result;
  }

  ///
  /// gcd
  ///

#define INT int
#include "MathMDE-gcd.java.jpp"
#undef INT

  /// gcd -- version for manipulating long (rather than int) values

#define INT long
#include "MathMDE-gcd.java.jpp"
#undef INT

#define INT double
#define GCD_DOUBLE
#include "MathMDE-gcd.java.jpp"
#undef INT
#undef GCD_DOUBLE

  ///
  /// Modulus
  ///

#define PARAM_INT
#include "MathMDE-modulus.java.jpp"
#undef PARAM_INT

  /// modulus for long (as opposed to int) values

#define PARAM_LONG
#include "MathMDE-modulus.java.jpp"
#undef PARAM_LONG


  ///
  /// Non-Modulus
  ///

#define PARAM_INT
#include "MathMDE-nonmodulus.java.jpp"
#undef PARAM_INT

  /// non-modulus for long (as opposed to int) values

#define PARAM_LONG
#include "MathMDE-nonmodulus.java.jpp"
#undef PARAM_LONG


}
