plugins {
  // https://plugins.gradle.org/plugin/com.gradleup.shadow
  alias(libs.plugins.com.gradleup.shadow)
  // https://plugins.gradle.org/plugin/de.undercouch.download
  alias(libs.plugins.de.undercouch.download)
  id("java")
  // https://github.com/tbroyer/gradle-errorprone-plugin
  alias(libs.plugins.net.ltgt.errorprone)
  // https://docs.gradle.org/current/userguide/eclipse_plugin.html
  id("eclipse")

  id("groovy") // needed for formatting Gradle files

  // Code formatting; defines targets "spotlessApply" and "spotlessCheck".
  // https://github.com/diffplug/spotless/tags ; see tags starting "gradle/"
  // Only works on JDK 11+ (even including the plugin crashes Gradle on JDK 8);
  // shell scripts in checker/bin-devel/ ensure spotless isn't called unless
  // the JDK is 17 or later.
  alias(libs.plugins.com.diffplug.spotless)
}
apply from: rootProject.file("release.gradle")

// There is another `repositories { ... }` block below; if you change this one, change that one as well.
repositories {
  maven {
    url = "https://central.sonatype.com/repository/maven-snapshots/"
    mavenContent { snapshotsOnly() }
  }
  mavenCentral()
}

ext {
  // Different JDKs may be used to run Gradle, compile the Checker Framework, and run the CF tests.

  // Ways to specifiy the JDK used by different tasks/Gradle:
  //
  // 1. Run Gradle using JDK 21:
  // mkdir ~/.gradle && echo "org.gradle.java.home=/usr/lib/jvm/java-21-openjdk-amd64" >> ~/.gradle/gradle.properties
  //
  // 2. Use JDK 24 for all Java tasks: (24 could be replaced with any version.)
  // export ORG_GRADLE_PROJECT_jdkTestVersion=24
  // or
  // ./gradlew sometask -PjdkTestVersion=24
  //
  // 3. Compile the Checker Framework using JDK 21: (Overrides the version specified in `jdkTestVersion` for compiling only.)
  // export ORG_GRADLE_PROJECT_useJdk21Compiler=true
  // or
  // ./gradlew sometask -PuseJdk21Compiler=true

  gradleRunsOnJava17orHigher = JavaVersion.current() >= JavaVersion.VERSION_17
  gradleRunsOnJava21orHigher = JavaVersion.current() >= JavaVersion.VERSION_21
  gradleRunsOnJava22orHigher = JavaVersion.current() >= JavaVersion.VERSION_22
  gradleRunsOnJava24orHigher = JavaVersion.current() >= JavaVersion.VERSION_24
  // The JDK for running tests: the jdkTestVersion property or if not set, JavaVersion.current()
  if (project.getProperties().containsKey("jdkTestVersion")) {
    testJdkVersion = Integer.valueOf(project.getProperties().get("jdkTestVersion"))
  } else {
    testJdkVersion = Integer.valueOf(JavaVersion.current().getMajorVersion())
  }
  // With "useJdk21Compiler" property, use JDK 21 to compile all code because the release does.
  // If you update this line, also update JAVA_HOME in docs/developer/release/release_vars.py.
  boolean jdk21Compiler = project.getProperties().getOrDefault("useJdk21Compiler", false)
  compilerJdkVersion = jdk21Compiler ? 21 : testJdkVersion
  compilerRunsOnJava21orHigher = compilerJdkVersion >= 21

  // As of 2025-04-28 (Lombok 1.18.38), delombok supports JDK 24-ea but not
  // JDK 24 proper; see https://projectlombok.org/changelog .
  skipDelombok = gradleRunsOnJava24orHigher

  parentDir = file("${rootDir}/../").absolutePath
  afuManualDir = "docs/annotation-file-utilities/"

  gitScriptsHome = "${project(":checker").projectDir}/bin-devel/.git-scripts"
  plumeBibHome = "${projectDir}/docs/manual/plume-bib"
  plumeScriptsHome = "${project(":checker").projectDir}/bin-devel/.plume-scripts"
  htmlToolsHome = "${project(":checker").projectDir}/bin-devel/.html-tools"
  doLikeJavacHome = "${project(":checker").projectDir}/bin/.do-like-javac"

  javadocMemberLevel = JavadocMemberLevel.PROTECTED

  // The local git repository, typically in the .git directory, but not for worktrees.
  // This value is always overwritten, but Gradle needs the variable to be initialized.
  localRepo = ".git"
}

tasks.register("setLocalRepo", Exec) {
  commandLine("git", "worktree", "list")
  standardOutput = new ByteArrayOutputStream()

  doLast {
    String worktreeList = standardOutput.toString()
    localRepo = worktreeList.substring(0, worktreeList.indexOf(" ")) + "/.git"
  }
}

// No group so it does not show up in the output of `gradlew tasks`
tasks.register("installGitHooks", Copy) {
  dependsOn("setLocalRepo")
  description = "Copies git hooks to .git directory"
  from(files("checker/bin-devel/git.post-merge", "checker/bin-devel/git.pre-commit"))
  rename("git\\.(.*)", "\$1")
  into(localRepo + "/hooks")
}

spotless {
  // Resolve the Spotless plugin dependencies from the buildscript repositories rather than the
  // project repositories.  That way the spotless plugin does not use the locally built version of
  // checker-qual as a dependency. Without this, errors like the follow are issued when running
  // a spotless task without a locally-built version of checker-qual.jar:
  // Could not determine the dependencies of task ":checker-qual:spotlessCheck'.
  //  > Could not create task ":checker-qual:spotlessJavaCheck'.
  //     > Could not create task ":checker-qual:spotlessJava'.
  //        > File signature can only be created for existing regular files, given:
  //          .../checker-framework/checker-qual/build/libs/checker-qual-3.25.1-SNAPSHOT.jar
  predeclareDeps()
}

spotlessPredeclare {
  // Put all the formatters that have dependencies here.  Without this, errors like the following
  // will happen:
  // Could not determine the dependencies of task ":spotlessCheck'.
  //  > Could not create task ":spotlessJavaCheck'.
  //     > Could not create task ":spotlessJava'.
  //        > Add a step with [com.google.googlejavaformat:google-java-format:1.15.0] into the `spotlessPredeclare` block in the root project.
  java {
    googleJavaFormat(libs.google.java.format.get().version)
  }
  groovyGradle {
    greclipse()
  }
  groovy {
    greclipse()
  }
}

subprojects { subProject ->
  if (subProject.name.equals("checker")
      || subProject.name.equals("annotation-file-utilities")
      || subProject.name.equals("dataflow")
      || subProject.name.equals("framework")) {
    apply plugin: "com.gradleup.shadow"
    shadow {
      addShadowVariantIntoJavaComponent = false
    }
    shadowJar {
      // If you add an external dependency, then do the following:
      //  * On the master branch and on the modified branch, run:
      //    ./gradlew assembleForJavac && jar tf checker/dist/checker.jar | grep -v '^annotated-jdk/' | sort > checker-jar-contents.txt
      //  * Compare the files, and add relocate lines below.
      //  * Repeat until no new classes appear (all are under org/checkerframework/).

      // Relocate packages that might conflict with user's classpath.
      relocate("com.github.javaparser", "org.checkerframework.com.github.javaparser")
      relocate("org.apache", "org.checkerframework.org.apache")
      relocate("org.relaxng", "org.checkerframework.org.relaxng")
      relocate("org.plumelib", "org.checkerframework.org.plumelib")
      relocate("org.codehaus", "org.checkerframework.org.codehaus")
      relocate("org.objectweb.asm", "org.checkerframework.org.objectweb.asm")
      relocate("io.github.classgraph", "org.checkerframework.io.github.classgraph")
      relocate("nonapi.io.github.classgraph", "org.checkerframework.nonapi.io.github.classgraph")
      // relocate("sun", "org.checkerframework.sun")
      relocate("com.google", "org.checkerframework.com.google")
      relocate("plume", "org.checkerframework.plume")

      exclude("**/module-info.class")
    }
  }
}

allprojects { currentProj ->

  // To update the version number, change releaseVersion in file release.gradle.
  version = releaseVersion

  tasks.withType(JavaCompile).configureEach {
    options.fork = true
  }

  apply plugin: "java"
  apply plugin: "eclipse"
  apply plugin: "de.undercouch.download"
  apply plugin: "net.ltgt.errorprone"

  group = "org.checkerframework"

  // Keep in sync with "repositories { ... }" block above.
  repositories {
    maven {
      url = "https://central.sonatype.com/repository/maven-snapshots/"
      mavenContent { snapshotsOnly() }
    }
    mavenCentral()
  }

  configurations {
    // This is required to run the Checker Framework on JDK 8.
    javacJar

    // Holds the combined classpath of all subprojects including the subprojects themselves.
    allProjects

    // Exclude checker-qual dependency added by Error Prone to avoid a circular dependency.
    annotationProcessor.exclude group: "org.checkerframework", module: "checker-qual"

    // This is to be used to add Error Prone to the processorpath of the compile task.  The errorprone
    // configuration can't be used directly because it is marked unresolvable by the errorprone plugin.
    errorProneAnnotationProcessor.extendsFrom(errorprone)
  }

  dependencies {
    errorprone(libs.error.prone.core)

    javacJar(libs.javac)

    allProjects(subprojects)
  }

  eclipse.classpath {
    defaultOutputDir = file("build/default")
    file.whenMerged { cp ->
      cp.entries.forEach { cpe ->
        if (cpe instanceof org.gradle.plugins.ide.eclipse.model.SourceFolder) {
          cpe.output = cpe.output.replace("bin/", "build/classes/java/")
        }
        if (cpe instanceof org.gradle.plugins.ide.eclipse.model.Output) {
          cpe.path = cpe.path.replace("bin/", "build/")
        }
      }
    }
  }

  ext {
    // A list of add-export and add-open arguments to be used when running the Checker Framework.
    // Keep this list in sync with the lists in CheckerMain#getExecArguments,
    // the sections with labels "javac-jdk11-non-modularized", "maven", and "sbt" in the manual
    // and in the checker-framework-gradle-plugin, CheckerFrameworkPlugin#applyToProject
    compilerArgsForRunningCF = [
      // These are required in Java 16+ because the --illegal-access option is set to deny
      // by default.  None of these packages are accessed via reflection, so the module
      // only needs to be exported, but not opened.
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
      "--add-exports",
      "jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
      // Required because the Checker Framework reflectively accesses private members in com.sun.tools.javac.comp.
      "--add-opens",
      "jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
    ]
  }

  apply plugin: "com.diffplug.spotless"
  // patterns of files to skip for individual sub-projects
  def perProjectDoNotFormat = [
    "checker"  : [
      "bin/.do-like-javac/**",
      "bin-devel/.git-scripts/**",
      "bin-devel/.html-tools/**",
      "bin-devel/.plume-scripts/**",
      "dist/**",
      "tests/ainfer-*/annotated/*",
      "tests/build/**",
      "tests/calledmethods-delomboked/*",
      "tests/nullness-javac-errors/*",
    ],
    "dataflow" : ["manual/examples/"],
    "framework": [
      "tests/build/**",
      "tests/returnsreceiverdelomboked/*",
    ],
  ]
  spotless {
    // If you add any formatters to this block that require dependencies, then you must also
    // add them to the spotlessPredeclare block.

    // Never format files under build/ directory.
    def doNotFormat = ["build/**"]
    if (currentProj != project.rootProject) {
      if (perProjectDoNotFormat.containsKey(currentProj.name)) {
        doNotFormat += perProjectDoNotFormat[currentProj.name]
      }

      if (!gradleRunsOnJava17orHigher) {
        doNotFormat += [
          "tests/**/java17/",
          "tests/*record*/"
        ]
      }
      if (!gradleRunsOnJava21orHigher) {
        doNotFormat += ["tests/**/java21/"]
      }
      if (!gradleRunsOnJava22orHigher) {
        doNotFormat += ["tests/**/java22/"]
      }
    }

    format "misc", {
      // define the files to apply `misc` to
      target("*.md", "*.tex", ".gitignore")
      targetExclude(doNotFormat)
      // define the steps to apply to those files
      leadingTabsToSpaces(2)
      trimTrailingWhitespace()
      // endWithNewline() // Don't want to end empty files with a newline
    }

    format "make", {
      // define the files to apply `make` to
      target("Makefile")
      targetExclude(doNotFormat)
      // define the steps to apply to those files
      trimTrailingWhitespace()
      endWithNewline() // Don't want to end empty files with a newline
    }

    java {
      if (currentProj == currentProj.rootProject) {
        // format .java files outside of Gradle sub-projects
        def targets = [
          "docs/examples",
          "docs/tutorial",
        ]
        targets = targets.collectMany {
          [
            // must call toString() to convert GString to String
            "${it}/**/*.java".toString(),
            // Not .ajava files because formatting would remove import statements.
          ]
        }
        target(targets)
      } else {
        // not the root project; format all .java files in the sub-project
        target("**/*.java")
      }
      targetExclude(doNotFormat)

      if (project.hasProperty("eisopFormatting")) {
        googleJavaFormat(libs.google.java.format.get().version).aosp()
        importOrder("com", "jdk", "lib", "lombok", "org", "java", "javax")
      } else {
        googleJavaFormat(libs.google.java.format.get().version) // the formatter to apply to Java files
      }
      formatAnnotations()
    }

    // Only define a groovyGradle task on the root project, for simplicity in setting the target pattern
    if (currentProj == currentProj.rootProject) {
      groovyGradle {
        target("**/*.gradle")
        targetExclude(doNotFormat)
        greclipse()  // which formatter Spotless should use to format .gradle files.
        if (project.hasProperty("eisopFormatting")) {
          leadingTabsToSpaces(4)
        } else {
          leadingTabsToSpaces(2)
        }
        trimTrailingWhitespace()
        // endWithNewline() // Don't want to end empty files with a newline
      }

      groovy {
        target("buildSrc/**/*.groovy")
        importOrder()

        // removes semicolons at the end of lines
        removeSemicolons()
        greclipse()
        leadingTabsToSpaces(2)
        trimTrailingWhitespace()
      }

      // Don't do this, because it does not respect "ignore=true" in .editorconfig nor `doNotFormat` here.
      // shell {
      //   targetExclude doNotFormat
      //   shfmt() // configuration is in .editorconfig
      // }
    }

    // a useful task for debugging; prints exactly which files are getting formatted by spotless
    tasks.register("printSpotlessTaskInputs") {
      doLast {
        project.tasks.forEach { task ->
          if (task.name.contains("spotless")) {
            println("Inputs for task \"${task.name}\":")

            task.inputs.files.each { inputFile ->
              println("  Input: $inputFile")
            }
          }
        }
      }
    }
  }

  test {
    minHeapSize = "256m" // initial heap size
    maxHeapSize = "4g" // maximum heap size
  }

  configurations {
    checkerFatJar {
      canBeConsumed = false
      canBeResolved = true
    }
  }

  dependencies {
    checkerFatJar(project(path: ":checker", configuration: "fatJar"))
  }

  // After all the tasks have been created, modify some of them.
  afterEvaluate {

    // Add the fat checker.jar to the classpath of every Javadoc task. This allows Javadoc in
    // any module to reference classes in any other module.
    // Also, build and use ManualTaglet as a taglet.
    tasks.withType(Javadoc).configureEach {
      dependsOn(":checker:shadowJar")
      dependsOn(":framework-test:tagletClasses")
      doFirst {
        options.encoding = "UTF-8"
        if (!name.equals("javadocDoclintAll")) {
          options.memberLevel = javadocMemberLevel
        }
        classpath += configurations.named("checkerFatJar").get().asFileTree
        options.taglets("org.checkerframework.taglet.ManualTaglet")
        options.tagletPath(project(":framework-test").sourceSets.taglet.output.classesDirs.getFiles() as File[])
        options.noTimestamp = true

        // This file is looked for by Javadoc.
        file("${destinationDir}/resources/fonts/").mkdirs()
        ant.touch(file: "${destinationDir}/resources/fonts/dejavu.css")

        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED", true)
        options.addBooleanOption("-add-exports=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED", true)

        // "-Xwerror" requires Javadoc everywhere.  Currently, CI jobs require Javadoc only
        // on changed lines.  Enable -Xwerror in the future when all Javadoc exists.
        // options.addBooleanOption("Xwerror", true)
        options.addStringOption("Xmaxwarns", "99999")
      }
    }

    // Add standard javac options
    tasks.withType(JavaCompile) { compilationTask ->
      dependsOn(":installGitHooks")

      // Sorting is commented out because it disables incremental compilation.
      // Uncomment when needed.
      // // Put source files in deterministic order, for debugging.
      // compilationTask.source = compilationTask.source.sort()

      // This test is for whether the Checker Framework supports (runs under) Java 8.
      // Currently, the Checker Framework does support Java 8.
      if (true) {
        // Using `options.release.set(8)` here leads to compilation
        // errors such as "package com.sun.source.tree does not exist".
        sourceCompatibility = 8
        targetCompatibility = 8
        // Because the target is 8, all of the public compiler classes are accessible, so
        // --add-exports are not required (nor are they allowed with target 8). See
        // https://openjdk.org/jeps/247 for details on compiling for older versions.
      } else {
        // This makes the class files Java 11, and then the Checker Framework would not run under Java 8.
        options.release.set(11)
        options.compilerArgs += [
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
          "--add-exports",
          "jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
        ]
        // This is equivalent to writing "exports jdk.compiler/... to ALL-UNNAMED" in the
        // module-info.java of jdk.compiler, so corresponding --add-opens are only required for
        // reflective access to private members.
        //
        // From https://openjdk.org/jeps/261, Section titled: "Breaking encapsulation"
        // "The effect of each instance [of --add-exports] is to add a qualified export of the
        // named package from the source module to the target module. This is, essentially, a
        // command-line form of an exports clause in a module declaration[...].
        // [...]
        // The --add-exports option enables access to the public types of a specified package.
        // It is sometimes necessary to go further and enable access to all non-public elements
        // via the setAccessible method of the core reflection API. The --add-opens option can
        // be used, at run time, to do this."
      }

      options.failOnError = true
      options.deprecation = true
      // -options: To not get a warning about missing bootstrap classpath (when using Java 9 and `-source 8`).
      // -fallthrough: Don't check fallthroughs.  Instead, use Error Prone.  Its
      //   warnings are suppressible with a "// fall through" comment.
      options.compilerArgs += [
        "-g",
        "-Werror",
        "-Xlint:-options,-fallthrough",
        "-Xlint",
      ]

      options.encoding = "UTF-8"
      options.fork = true

      // TODO: enable Error Prone on test classes.
      if (compilationTask.name.equals("compileJava")
          // Error Prone depends on checker-qual.jar, so don't run it on that project to avoid a circular dependency.
          && !project.name.startsWith("checker-qual")) {
        // Error Prone must be available in the annotation processor path
        options.annotationProcessorPath = configurations.errorProneAnnotationProcessor
        // Enable Error Prone
        options.errorprone.enabled = compilerRunsOnJava21orHigher
        options.errorprone.disableWarningsInGeneratedCode = true
        options.errorprone.errorproneArgs = [
          // Many compiler classes are interned.
          "-Xep:ReferenceEquality:OFF",
          // Not useful to suggest Splitter; maybe clean up.
          "-Xep:StringSplitter:OFF",
          // Too broad, rejects seemingly-correct code.
          "-Xep:EqualsGetClass:OFF",
          // Not a real problem
          "-Xep:MixedMutabilityReturnType:OFF",
          // Don't want to add a dependency to ErrorProne.
          "-Xep:AnnotateFormatMethod:OFF",
          // Don't want to add a dependency to ErrorProne.
          "-Xep:DoNotCallSuggester:OFF",
          // Warns for every use of "@checker_framework.manual"
          "-Xep:InvalidBlockTag:OFF",
          // Recommends writing @InlineMe which is an Error-Prone-specific annotation
          "-Xep:InlineMeSuggester:OFF",
          // Recommends writing @CanIgnoreReturnValue which is an Error-Prone-specific annotation.
          // It would be great if Error Prone recognized the @This annotation.
          "-Xep:CanIgnoreReturnValueSuggester:OFF",
          // Should be turned off when using the Checker Framework.
          "-Xep:ExtendsObject:OFF",
          // The Checker Framework is the only nullness tool we care about.
          "-Xep:NullableWildcard:OFF",
          // In the visitor pattern, it is natural to forward a Void reference.
          "-Xep:VoidUsed:OFF",
          // Suggestion assumes there is no overriding equals() method.
          "-Xep:NonOverridingEquals:OFF",
          // Suggests using a class that's in Error Prone itself, not in any library for clients.
          // It requires "import com.google.errorprone.util.ASTHelpers;", and (in build.gradle)
          //   implementation(libs.error.prone.core)
          // Adding that line in build.gradle causes a javac crash when running the Checker Framework.
          "-Xep:ASTHelpersSuggestions:OFF",
          // Removing "public" from private class members loses information about the abstraction.
          "-Xep:EffectivelyPrivate:OFF",
          // -Werror halts the build if Error Prone issues a warning, which ensures that
          // the errors get fixed.  On the downside, Error Prone (or maybe the compiler?)
          // stops as soon as it issues one warning, rather than outputting them all.
          // https://github.com/google/error-prone/issues/436
          "-Werror",
        ]
      } else {
        options.errorprone.enabled = false
      }
    }
  } // end afterEvaluate
} // end allProjects

tasks.register("version") {
  description = "Print Checker Framework version"
  group = "Documentation"
  doLast {
    println(version)
  }
}

/**
 * Creates a task that runs the checker on the main source set of each subproject. The task is named
 * "check${taskName}", for example "checkPurity" or "checkNullness".
 *
 * @param projectName name of the project
 * @param taskName short name (often the checker name) to use as part of the task name
 * @param checker fully qualified name of the checker to run
 * @param args list of arguments to pass to the checker
 */
def createCheckTypeTask(projectName, taskName, checker, args = []) {
  project("${projectName}").tasks.register("check${taskName}", JavaCompile) {
    description = "Run the ${taskName} Checker on the main sources."
    group = "Verification"
    dependsOn(":checker:shadowJar")
    // Always run the task.
    outputs.upToDateWhen { false }
    source = project("${projectName}").sourceSets.main.java
    classpath =(files(project("${projectName}").compileJava.classpath, project(":checker-qual").sourceSets.main.output))
    destinationDirectory = file("${buildDir}")

    options.annotationProcessorPath =(files(project(":checker").tasks.shadowJar.archiveFile))
    options.compilerArgs += [
      "-processor",
      "${checker}",
      "-proc:only",
      "-Xlint:-processing",
      "-Xmaxerrs",
      "10000",
      "-Xmaxwarns",
      "10000",
      "-ArequirePrefixInWarningSuppressions",
      "-AwarnUnneededSuppressions",
      "-AwarnRedundantAnnotations",
    ]
    options.compilerArgs += args
    options.forkOptions.jvmArgs += ["-Xmx4g"]

    options.fork = true
    options.forkOptions.jvmArgs += compilerArgsForRunningCF
  }
}

tasks.register("addFavicon", Exec) {
  dependsOn("allJavadoc")

  doFirst {
    copy {
      from("docs/logo/Checkmark/CFCheckmark_favicon.png")
      rename("CFCheckmark_favicon.png", "favicon-checkerframework.png")
      into("${rootDir}/docs/api")
    }
  }

  workingDir = "${rootDir}/docs/api"
  executable = "${htmlToolsHome}/html-add-favicon"
  args += [
    ".",
    "favicon-checkerframework.png"
  ]
}

// `gradle allJavadoc` builds the Javadoc for all modules in `docs/api`.
//   This is what is published to checkerframework.org.
// `gradle javadoc` builds the Javadoc for each sub-project in <subproject>/build/docs/javadoc/ .
//   It's needed to create the Javadoc jars that we release in Maven Central.
// To make javadoc for only one subproject, run `./gradlew javadoc`
//   in the subproject or `./gradlew :checker:javadoc` at the top level.
tasks.register("allJavadoc", Javadoc) {
  description = "Generates API documentation that includes all the modules."
  group = "Documentation"
  dependsOn(":checker:shadowJar", "getPlumeScripts", "getHtmlTools", ":checker-qual:jar")

  destinationDir = file("${rootDir}/docs/api")
  source(
      project(":checker-util").sourceSets.main.allJava,
      project(":checker-qual").sourceSets.main.allJava,
      project(":checker").sourceSets.main.allJava,
      project(":framework").sourceSets.main.allJava,
      project(":dataflow").sourceSets.main.allJava,
      project(":javacutil").sourceSets.main.allJava,
      project(":framework-test").sourceSets.main.allJava,
      project(":annotation-file-utilities").sourceSets.main.allJava,
      )

  subprojects.each { proj ->
    proj.tasks.withType(Javadoc).each { javadocTask ->
      classpath += javadocTask.classpath
    }
  }

  // disable interpreting module-info.java files until all sub-modules support them
  modularity.inferModulePath = false

  finalizedBy("addFavicon")

  doFirst {
    source(project(":framework-test").sourceSets.taglet.allJava)
  }
}

// See documentation for allJavadoc task.
javadoc.dependsOn(allJavadoc)

tasks.register("zip", Zip) {
  description = "Creates a zip archive for the Checker Framework."
  dependsOn("buildAll")
  archiveFileName = "checker-framework-${version}.zip"
  destinationDirectory = layout.buildDirectory
  into("checker-framework-${releaseVersion}")

  from(layout.projectDirectory) {
    exclude("api/**",
        "checker/bin/README",
        "checker/dist/*.asc",
        "docs/tutorial/tests/**",
        "docs/tutorial/src/**",
        "docs/tutorial/test/**",
        "docs/tutorial/Makefile",
        "docs/tutorial/README")

    include("README.html",
        "LICENSE.txt",
        "annotation-file-utilities/bin/**",
        "annotation-file-utilities/dist/**",
        "annotation-file-utilities/LICENSE.txt",
        "checker/bin/**",
        "checker/dist/**",
        "checker/resources/**",
        "docs/CHANGELOG.md",
        "docs/annotation-file-utilities/annotation-file-utilities.html",
        "docs/annotation-file-utilities/annotation-file-format.pdf",
        "docs/annotation-file-utilities/annotation-file-format.html",
        "docs/annotation-file-utilities/*.png",
        "docs/manual/manual.html",
        "docs/manual/manual.pdf",
        "docs/manual/*.svg",
        "docs/manual/manual001.png",
        "docs/examples/InterningExample.java",
        "docs/examples/InterningExampleWithWarnings.java",
        "docs/examples/NullnessExample.java",
        "docs/examples/NullnessExampleWithWarnings.java",
        "docs/examples/NullnessReleaseTests.java",
        "docs/examples/units-extension/Demo.java",
        "docs/examples/units-extension/Expected.txt",
        "docs/examples/units-extension/Frequency.java",
        "docs/examples/units-extension/FrequencyRelations.java",
        "docs/examples/units-extension/Hz.java",
        "docs/examples/units-extension/kHz.java",
        "docs/examples/units-extension/Makefile",
        "docs/examples/units-extension/README",
        "docs/examples/MavenExample/pom.xml",
        "docs/examples/MavenExample/README",
        "docs/examples/MavenExample/src/main/java/org/checkerframework/example/MavenExample.java",
        "docs/tutorial/**")
  }

  from("dataflow/manual/checker-framework-dataflow-manual.pdf") {
    into("docs/manual/")
  }

  from("docs/logo/Logo/CFLogo.png") {
    into("docs/manual/")
  }

  from("docs/logo/Logo/CFLogo.png") {
    into("docs/tutorial/")
  }

  from("docs/logo/Logo/CFLogo.png") {
    into("docs/tutorial/webpages")
  }
}

tasks.register("cleanCfManual", Exec) {
  description = "Clean the manual"
  commandLine("make", "-C", "docs/manual", "clean")
}

tasks.register("cleanAfuManual", Exec) {
  description = "Clean the manual"
  commandLine("make", "-C", "${afuManualDir}", "clean")
}

tasks.register("cleanManual") {
  dependsOn("cleanCfManual", "cleanAfuManual")
}

clean.dependsOn(cleanManual)
clean {
  delete(file("${rootDir}/docs/api"))
  delete("${afuManualDir}/annotation-file-format.aux")
  delete("${afuManualDir}/annotation-file-format.blg")
  delete("${afuManualDir}/annotation-file-format.dvi")
  delete("${afuManualDir}/annotation-file-format.haux")
  delete("${afuManualDir}/annotation-file-format.html")
  delete("${afuManualDir}/annotation-file-format.htoc")
  delete("${afuManualDir}/annotation-file-format.log")
  delete("${afuManualDir}/annotation-file-format.pdf")
  delete("${afuManualDir}/annotation-file-format.toc")
  delete("${afuManualDir}/corresp.png")
  delete("${afuManualDir}/dataflow.png")
  delete("${afuManualDir}/nocast.png")
  delete("${afuManualDir}/typecast.png")
}

configurations {
  requireJavadoc
}
dependencies {
  requireJavadoc(libs.require.javadoc)
}
tasks.register("requireJavadoc", JavaExec) {
  description = "Ensures that Javadoc documentation exists in source code."
  group = "Documentation"
  mainClass = "org.plumelib.javadoc.RequireJavadoc"
  classpath = configurations.requireJavadoc
  args("--exclude=module-info.java", "checker/src/main/java", "checker-qual/src/main/java", "checker-util/src/main/java", "dataflow/src/main/java", "framework/src/main/java", "framework-test/src/main/java", "javacutil/src/main/java")
  jvmArgs += [
    "--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
    "--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
    "--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
    "--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
    "--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
    "--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
    "--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
    "--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
  ]
}


/**
 * Creates a task named taskName that runs javadoc with the -Xdoclint:all option.
 *
 * @param taskName the name of the task to create
 * @param taskDescription description of the task
 * @param memberLevel the JavadocMemberLevel to use
 * @return the new task
 */
def createJavadocTask(taskName, taskDescription, memberLevel) {
  tasks.register(taskName, Javadoc) {
    description = taskDescription
    destinationDir = file("${rootDir}/docs/tmpapi")
    destinationDir.mkdirs()
    subprojects.forEach {
      if (!it.name.startsWith("checker-qual-android")) {
        source += it.sourceSets.main.allJava
      }
    }

    classpath = configurations.allProjects
    // disable interpreting module-info.java files until all sub-modules support them
    modularity.inferModulePath = false

    destinationDir.deleteDir()
    options.memberLevel = memberLevel
    options.addBooleanOption("Xdoclint:all", true)
    options.addStringOption("Xmaxwarns", "99999")

    // options.addStringOption("skip", "ClassNotToCheck|OtherClass")
  }
}

createJavadocTask("javadocDoclintAll", "Runs javadoc with -Xdoclint:all option.", JavadocMemberLevel.PRIVATE)

tasks.register("makeCfManual", Exec) {
  dependsOn("allJavadoc")
  description = "Build the Checker Framework manual"
  // Don't make all because it will re-run allJavadoc which causes problems when building the release.
  commandLine("make", "-C", "docs/manual/", "manual.pdf", "manual.html")
}

tasks.register("makeAfuManual", Exec) {
  description = "Make documentation: annotation-file-format.{html,pdf}."

  executable = "make"
  args("-C", "${afuManualDir}")
}


tasks.register("manual") {
  description = "Build the manual"
  dependsOn("makeCfManual", "makeAfuManual", ":dataflow:manual")
}

tasks.register("getPlumeBib", CloneTask) {
  url.set("https://github.com/mernst/plume-bib.git")
  directory.set(file(plumeBibHome))
  outputs.upToDateWhen { false }
}

tasks.register("getGitScripts", CloneTask) {
  url.set("https://github.com/plume-lib/git-scripts.git")
  directory.set(file(gitScriptsHome))
  outputs.upToDateWhen { false }
}

tasks.register("getPlumeScripts", CloneTask) {
  url.set("https://github.com/plume-lib/plume-scripts.git")
  directory.set(file(plumeScriptsHome))
  outputs.upToDateWhen { false }
}

tasks.register("getHtmlTools", CloneTask) {
  url.set("https://github.com/plume-lib/html-tools.git")
  directory.set(file(htmlToolsHome))
  outputs.upToDateWhen { false }
}

tasks.register("getDoLikeJavac", CloneTask) {
  url.set("https://github.com/kelloggm/do-like-javac.git")
  directory.set(file(doLikeJavacHome))
  outputs.upToDateWhen { false }
}

// No group so it does not show up in the output of `gradlew tasks`
tasks.register("pythonIsInstalled", Exec) {
  description = "Check that the python3 executable is installed."
  executable = "python3"
  args("--version")
}

tasks.register("docTags", Exec) {
  group = "Emacs"
  commandLine("make", "-C", "docs/manual/", "tags")
}

tasks.register("tags", Exec) {
  dependsOn(docTags)
  description = "Create Emacs TAGS table"
  group = "Emacs"
  // running this task will also run the tags task in the subprojects, which is defined later in this file.
  commandLine("etags", "-i", "annotation-file-utilities/TAGS", "-i", "checker/TAGS", "-i", "checker-qual/TAGS", "-i", "checker-util/TAGS", "-i", "dataflow/TAGS", "-i", "framework/TAGS", "-i", "framework-test/TAGS", "-i", "javacutil/TAGS", "-i", "docs/manual/TAGS")
}

subprojects {
  configurations {
    annotatedGuava
  }

  dependencies {
    // TODO: it's a bug that annotatedlib:guava requires the error_prone_annotations dependency.
    annotatedGuava(libs.error.prone.annotations)
    annotatedGuava(libs.guava) {
      // So long as Guava only uses annotations from checker-qual, excluding it should not cause problems.
      exclude group: "org.checkerframework"
    }
  }

  if (!project.name.startsWith("checker-qual-android")) {
    tasks.register("tags", Exec) {
      description = "Create Emacs TAGS table"
      // `ctags -e -f TAGS` used to work in place of `etags`, but apparently no longer.
      commandLine("bash", "-c", "find . \\( -name build -o -name jtreg -o -name tests \\) -prune -o -name '*.java' -print | sort-directory-order | xargs etags")
    }
  }

  java {
    withJavadocJar()
    withSourcesJar()

    toolchain {
      languageVersion = JavaLanguageVersion.of(testJdkVersion)
    }
  }

  tasks.withType(JavaExec).configureEach {
    javaLauncher = javaToolchains.launcherFor {
      languageVersion = JavaLanguageVersion.of(testJdkVersion)
    }
  }

  tasks.withType(JavaCompile).configureEach { compilationTask ->
    javaCompiler = javaToolchains.compilerFor {
      languageVersion = JavaLanguageVersion.of(compilerJdkVersion)
    }
  }

  // Things in this block reference definitions in the subproject that do not exist,
  // until the project is evaluated.
  afterEvaluate {
    // Adds manifest to all Jar files
    tasks.withType(Jar).configureEach {
      includeEmptyDirs = false
      if (archiveFileName.get().startsWith("checker-qual") || archiveFileName.get().startsWith("checker-util")) {
        metaInf {
          from("./LICENSE.txt")
        }
      } else {
        metaInf {
          from("${rootDir}/LICENSE.txt")
        }
      }
      manifest {
        attributes("Implementation-Version": "${project.version}")
        attributes("Implementation-URL": "https://checkerframework.org")
        if (!archiveFileName.get().endsWith("source.jar") && !archiveFileName.get().startsWith("checker-qual")) {
          attributes("Automatic-Module-Name": "org.checkerframework." + project.name.replaceAll("-", "."))
        }
        if (archiveFileName.get().startsWith("checker-qual") || archiveFileName.get().startsWith("checker-util")) {
          attributes("Bundle-License": "MIT")
        } else {
          attributes("Bundle-License": "(GPL-2.0-only WITH Classpath-exception-2.0)")
        }
      }
    }

    // Tasks such as `checkInterning` and `checkResourceLeak` run various checkers on all the main source sets.
    // These pass and are run by the `typecheck` task.
    // When you add one here, also update a dependsOn(item for the "typecheck" task.)
    createCheckTypeTask(project.name, "Formatter",
        "org.checkerframework.checker.formatter.FormatterChecker")
    createCheckTypeTask(project.name, "Interning",
        "org.checkerframework.checker.interning.InterningChecker",
        [
          "-Astubs=javax-lang-model-element-name.astub"
        ])
    createCheckTypeTask(project.name, "Optional",
        "org.checkerframework.checker.optional.OptionalChecker",
        [
          // to avoid having to annotate JavaParser
          "-AassumePureGetters",
          "-AassumeAssertionsAreEnabled",
        ])
    createCheckTypeTask(project.name, "Purity",
        "org.checkerframework.framework.util.PurityChecker")
    createCheckTypeTask(project.name, "ResourceLeak",
        "org.checkerframework.checker.resourceleak.ResourceLeakChecker")
    createCheckTypeTask(project.name, "Signature",
        "org.checkerframework.checker.signature.SignatureChecker")

    // The checkNullness task runs on all code, but it only *checks* the following code:
    //  * All files outside the "framework", "checker", and "annotation-file-utilities" subprojects.
    //  * In the "framework", "checker", and "annotation-file-utilities" subprojects, files with `@AnnotatedFor("nullness")`.
    boolean nullnessAll = project.getProperties().containsKey("nullnessAll")
    if (!nullnessAll && (project.name.is("framework") || project.name.is("checker") || project.name.is("annotation-file-utilities"))) {
      createCheckTypeTask(project.name, "Nullness",
          "org.checkerframework.checker.nullness.NullnessChecker",
          [
            "-AskipUses=com\\.sun\\.*",
            // If a file does not contain @AnnotatedFor("nullness"), all its routines
            // are assumed to return @Nullable.
            "-AuseConservativeDefaultsForUncheckedCode=source"
          ])
    } else {
      createCheckTypeTask(project.name, "Nullness",
          "org.checkerframework.checker.nullness.NullnessChecker",
          ["-AskipUses=com\\.sun\\.*"])
    }


    createCheckTypeTask(project.name, "CompilerMessages",
        "org.checkerframework.checker.compilermsgs.CompilerMessagesChecker")
    checkCompilerMessages {
      doFirst {
        String propfiles = sourceSets.main.resources.filter { file -> file.name.equals("messages.properties") }.asPath
        if (project.name.is("checker")) {
          String frameworkPropFiles = project(":framework").sourceSets.main.resources.filter { file -> file.name.equals("messages.properties") }.asPath
          propfiles = propfiles + File.pathSeparator + frameworkPropFiles
        }
        options.compilerArgs += ["-Apropfiles=${propfiles}"]
      }
    }


    // Add jtregTests to framework and checker modules
    if (project.name.is("framework") || project.name.is("checker")) {
      tasks.register("jtregTests", Exec) {
        description = "Run the jtreg tests. Requires jtreg to be installed."
        group = "Verification"
        dependsOn("compileJava")
        dependsOn("compileTestJava")
        dependsOn("shadowJar")

        String jtregOutput = "${buildDir}/jtreg"
        String name = "all"
        String tests = "."
        executable = "jtreg"
        args = [
          "-dir:${projectDir}/jtreg",
          "-workDir:${jtregOutput}/${name}/work",
          "-reportDir:${jtregOutput}/${name}/report",
          "-verbose:error,fail,nopass",
          // Don't add debugging information
          //  "-javacoptions:-g",
          "-keywords:!ignore",
          "-samevm",
          "-javacoptions:-classpath ${tasks.shadowJar.archiveFile.get()}:${sourceSets.test.output.asPath}",
          // Required for checker/jtreg/nullness/PersistUtil.java and other tests
          "-vmoptions:-classpath ${tasks.shadowJar.archiveFile.get()}:${sourceSets.test.output.asPath}",
        ]
        args += [
          // checker/jtreg/nullness/defaultsPersist/ReferenceInfoUtil.java
          // uses the jdk.jdeps module.
          "-javacoptions:--add-modules jdk.jdeps",
          "-javacoptions:--add-exports=jdk.jdeps/com.sun.tools.classfile=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.jdeps/com.sun.tools.classfile=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
          "-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
        ]
        if (project.name.is("framework")) {
          // Do not check for the annotated JDK
          args += [
            "-javacoptions:-ApermitMissingJdk"
          ]
        } else if (project.name.is("checker")) {
          args += [
            "-javacoptions:-classpath ${sourceSets.testannotations.output.asPath}",
          ]
        }

        // Location of jtreg tests
        args += "${tests}"
      }
    }

    // Create a task for each JUnit test class whose name is the same as the JUnit class name.
    sourceSets.test.allJava.filter { it.path.contains("test/junit") }.forEach { file ->
      String junitClassName = file.name.replaceAll(".java", "")
      tasks.register("${junitClassName}", Test) {
        description = "Run ${junitClassName} tests."
        include("**/${name}.class")
        testClassesDirs = testing.suites.test.sources.output.classesDirs
        classpath = testing.suites.test.sources.runtimeClasspath
      }
    }

    // Configure JUnit tests
    tasks.withType(Test) {
      jvmArgs += compilerArgsForRunningCF

      // // maxParallelForks controls the parallelism of a single Test task.
      // // --parallel controls parallelism for the entire build.

      // // Run tests in parallel, except on CI where it seems to lead to flaky failures.
      // // The TF_BUILD environment variable is set to "True" for jobs running on Azure Pipelines.
      // if (!System.getenv("TF_BUILD")?.equals("True")) {
      //   // Not running under Azure Pipelines CI.

      //   maxParallelForks = Runtime.runtime.availableProcessors() ?: 1
      // } else {
      //   // Running under Azure Pipelines CI.

      //   // Per Manu's comment above, on CI, parallelism seems to lead to flaky failures.
      //   maxParallelForks = 1

      //   // Fork the test to try to improve performance.
      //   // https://docs.gradle.org/current/userguide/performance.html#fork_tests_into_multiple_processes
      //   tasks.withType(Test) {
      //     forkEvery = 25
      //   }
      // }

      if (project.name.is("checker")) {
        dependsOn("assembleForJavac")
      }

      if (project.hasProperty("emit.test.debug")) {
        systemProperties += ["emit.test.debug": "true"]
      }

      testLogging {
        showStandardStreams = true
        // Always run the tests
        outputs.upToDateWhen { false }

        // Show the found unexpected diagnostics and expected diagnostics not found.
        exceptionFormat = "full"
        events("failed")

        // Don't show the uninteresting stack traces from the exceptions.
        showStackTraces = false
      }
    }

    // Create a nonJunitTests task per project
    tasks.register("nonJunitTests") {
      description = "Run all Checker Framework tests except for the Junit tests and inference tests."
      group = "Verification"
      if (project.name.is("framework") || project.name.is("checker")) {
        dependsOn("jtregTests")
      }
      if (project.name.is("framework")) {
        dependsOn("loaderTests")
      }

      if (project.name.is("checker")) {
        dependsOn("jtregJdk11Tests", "nullnessExtraTests", "commandLineTests", "tutorialTests")
      }

      if (project.name.is("dataflow")) {
        dependsOn("allDataflowTests")
      }
    }

    // Create an inferenceTests task per project
    tasks.register("inferenceTests") {
      description = "Run inference tests."
      group = "Verification"
      if (project.name.is("checker")) {
        dependsOn("inferenceTests-part1", "inferenceTests-part2")
      }
    }
    tasks.register("inferenceTests-part1") {
      description = "Run inference tests (part 1)."
      group = "Verification"
      if (project.name.is("checker")) {
        dependsOn("wpiManyTest")
      }
    }
    tasks.register("inferenceTests-part2") {
      description = "Run inference tests (part 2)."
      group = "Verification"
      if (project.name.is("checker")) {
        dependsOn("ainferTest", "wpiPlumeLibTest")
      }
    }

    // Create a typecheck task per project (dogfooding the Checker Framework on itself).
    // This isn't a test of the Checker Framework as the test and nonJunitTests tasks are.
    // Tasks such as "checkInterning" are constructed by createCheckTypeTask.
    tasks.register("typecheck") {
      description = "Run the Checker Framework on itself"
      group = "Verification"
      dependsOn("typecheck-part1", "typecheck-part2")
    }
    tasks.register("typecheck-part1") {
      description = "Run the Checker Framework on itself (part 1)"
      group = "Verification"
      dependsOn("checkCompilerMessages", "checkFormatter", "checkInterning", "checkOptional", "checkPurity")
    }
    tasks.register("typecheck-part2") {
      description = "Run the Checker Framework on itself (part 2)"
      group = "Verification"
      dependsOn("checkResourceLeak", "checkSignature")
      if (!(project.name.is("framework") || project.name.is("checker"))) {
        dependsOn("checkNullness")
      }
    }

    // Create an allTests task per project.
    // allTests = test + nonJunitTests + inferenceTests + typecheck
    tasks.register("allTests") {
      description = "Run all Checker Framework tests"
      group = "Verification"
      // The "test" target is just the JUnit tests.
      dependsOn("test", "nonJunitTests", "inferenceTests", "typecheck")
    }

    tasks.register("javadocPrivate") {
      dependsOn(javadoc)
      doFirst {
        javadocMemberLevel = JavadocMemberLevel.PRIVATE
      }
      doLast {
        javadocMemberLevel = JavadocMemberLevel.PROTECTED
      }
    }
  }
}

// The `assembleForJavac` task is faster than the `assemble` task, if you only
// care about running `javac`.
// The assemble task also produces Javadoc jars, because its purpose is to build
// all artifacts produced by the Gradle project:
// https://docs.gradle.org/current/userguide/base_plugin.html#sec:base_tasks
assemble.dependsOn(":checker:assembleForJavac")

assemble.mustRunAfter(clean)

tasks.register("buildAll") {
  description = "Build all jar files and the manuals, including source and javadoc jars"
  group = "Build"
  dependsOn(allJavadoc)
  subprojects { Project subproject ->
    dependsOn("${subproject.name}:assemble")
    dependsOn("${subproject.name}:javadocJar")
    dependsOn("${subproject.name}:sourcesJar")
  }
  dependsOn("framework:allJavadocJar", "framework:allSourcesJar", "checker:allJavadocJar", "checker:allSourcesJar", "checker-qual:jar", "checker-util:jar")
  dependsOn("checker:assembleForJavac")
  dependsOn("manual")
}

// Don't create an empty checker-framework-VERSION.jar
jar.onlyIf { false }

/**
 * Adds the shared pom information to the given publication.
 * @param publication the MavenPublication
 */
final sharedPublicationConfiguration(publication) {
  publication.pom {
    url = "https://checkerframework.org/"
    developers {
      // These are the lead developers/maintainers, not all the developers or contributors.
      developer {
        id = "mernst"
        name = "Michael Ernst"
        email = "mernst@cs.washington.edu"
        url = "https://homes.cs.washington.edu/~mernst/"
        organization = "University of Washington"
        organizationUrl = "https://www.cs.washington.edu/"
      }
      developer {
        id = "smillst"
        name = "Suzanne Millstein"
        email = "smillst@cs.washington.edu"
        organization = "University of Washington"
        organizationUrl = "https://www.cs.washington.edu/"
      }
    }

    scm {
      url = "https://github.com/typetools/checker-framework.git"
      connection = "scm:git:https://github.com/typetools/checker-framework.git"
      developerConnection = "scm:git:ssh://git@github.com/typetools/checker-framework.git"
    }
  }
}

tasks.register("printJavaVersion") {
  description = "Prints the Java version used to run Gradle."
  doLast {
    println("Java version used to run Gradle: ${System.getProperty("java.version")}")
    def currentJvm = org.gradle.internal.jvm.Jvm.current()
    println(currentJvm)
  }
}
