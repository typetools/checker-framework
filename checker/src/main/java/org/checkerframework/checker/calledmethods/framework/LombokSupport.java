package org.checkerframework.checker.calledmethods.framework;

import com.sun.source.tree.NewClassTree;
import com.sun.source.tree.VariableTree;
import java.beans.Introspector;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;
import org.checkerframework.framework.type.AnnotatedTypeMirror;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;
import org.checkerframework.javacutil.AnnotationUtils;

/**
 * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code
 * generated by Lombok.
 */
public class LombokSupport implements FrameworkSupport {

    /** The type factory. */
    private CalledMethodsAnnotatedTypeFactory atypeFactory;

    /**
     * Simple constructor.
     *
     * @param atypeFactory the typechecker's type factory
     */
    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {
        this.atypeFactory = atypeFactory;
    }

    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that
    // class directly because Lombok does not provide class files for its own implementation, to
    // prevent itself from being accidentally added to clients' compile classpaths. This design
    // decision means that it is impossible to depend directly on Lombok internals.
    /** The list of annotations that Lombok treats as non-null. */
    public static final List<String> NONNULL_ANNOTATIONS =
            Collections.unmodifiableList(
                    Arrays.asList(
                            "android.annotation.NonNull",
                            "android.support.annotation.NonNull",
                            "com.sun.istack.internal.NotNull",
                            "edu.umd.cs.findbugs.annotations.NonNull",
                            "javax.annotation.Nonnull",
                            // "javax.validation.constraints.NotNull", // The field might contain a
                            // null value
                            // until it is persisted.
                            "lombok.NonNull",
                            "org.checkerframework.checker.nullness.qual.NonNull",
                            "org.eclipse.jdt.annotation.NonNull",
                            "org.eclipse.jgit.annotations.NonNull",
                            "org.jetbrains.annotations.NotNull",
                            "org.jmlspecs.annotation.NonNull",
                            "org.netbeans.api.annotations.common.NonNull",
                            "org.springframework.lang.NonNull"));

    /**
     * Keep a cache of these so that when declarationFromElement doesn't work, we can still default
     * correctly. Value is the property name to treat as defaulted.
     */
    private final Map<Element, String> defaultedElements = new HashMap<>();

    /**
     * For {@code build} methods on {@code Builder} types, the framework support should determine
     * the required properties and add a corresponding {@link
     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.
     *
     * @param t a method that is possibly the {@code build} method for a builder. The only
     *     guaranteed condition is that the enclosing class for the method is itself an inner class.
     */
    @Override
    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {
        ExecutableElement element = t.getElement();

        if (isBuilderBuildMethod(element)) {
            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
            Element nextEnclosingElement = enclosingElement.getEnclosingElement();

            List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);
            AnnotationMirror newCalledMethodsAnno =
                    atypeFactory.createAccumulatorAnnotation(requiredProperties);
            t.getReceiverType().addAnnotation(newCalledMethodsAnno);
        }
    }

    @Override
    public void handlePossibleToBuilder(AnnotatedExecutableType t) {

        AnnotatedTypeMirror returnType = t.getReturnType();
        ExecutableElement element = t.getElement();

        String methodName = element.getSimpleName().toString();

        // make sure the method is toBuilder
        if ("toBuilder".equals(methodName)) {
            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();

            if (FrameworkSupportUtils.hasAnnotation(element, "lombok.Generated")
                    || FrameworkSupportUtils.hasAnnotation(enclosingElement, "lombok.Generated")) {
                handleToBuilderType(returnType, enclosingElement);
            }
        }
    }

    /**
     * Update a particular type associated with a toBuilder with the relevant CalledMethods
     * annotation. This can be the return type of toBuilder or the corresponding generated "copy"
     * constructor.
     *
     * @param type type to update
     * @param classElement corresponding AutoValue class
     */
    private void handleToBuilderType(AnnotatedTypeMirror type, Element classElement) {
        List<String> requiredProperties = getLombokRequiredProperties(classElement);
        AnnotationMirror calledMethodsAnno =
                atypeFactory.createAccumulatorAnnotation(requiredProperties);
        type.replaceAnnotation(calledMethodsAnno);
    }

    /**
     * computes the required properties of a @lombok.Builder class, i.e., the names of the fields
     * with @lombok.NonNull annotations.
     *
     * @param lombokClassElement the class with the @lombok.Builder annotation
     * @return a list of required property names
     */
    private List<String> getLombokRequiredProperties(final Element lombokClassElement) {
        List<String> requiredPropertyNames = new ArrayList<>();
        List<String> defaultedPropertyNames = new ArrayList<>();
        for (Element member : lombokClassElement.getEnclosedElements()) {
            if (member.getKind() == ElementKind.FIELD) {
                for (AnnotationMirror anm :
                        atypeFactory.getElementUtils().getAllAnnotationMirrors(member)) {
                    //	          System.out.println();
                    if (NONNULL_ANNOTATIONS.contains(AnnotationUtils.annotationName(anm))) {
                        requiredPropertyNames.add(member.getSimpleName().toString());
                    }
                }
            } else if (member.getKind() == ElementKind.METHOD
                    && FrameworkSupportUtils.hasAnnotation(member, "lombok.Generated")) {
                String methodName = member.getSimpleName().toString();
                // Handle fields with @Builder.Default annotations.
                // If a field foo has an @Builder.Default annotation, Lombok always generates a
                // method
                // called $default$foo.
                if (methodName.startsWith("$default$")) {
                    String propName = methodName.substring(9); // $default$ has 9 characters
                    defaultedPropertyNames.add(propName);
                }
            } else if (member.getKind().isClass() && member.toString().endsWith("Builder")) {
                // If a field bar has an @Singular annotation, Lombok always generates a method
                // called
                // clearBar in the builder class itself. Therefore, search the builder for such a
                // method,
                // and extract the appropriate property name to treat as defaulted.
                for (Element builderMember : member.getEnclosedElements()) {
                    if (builderMember.getKind() == ElementKind.METHOD
                            && FrameworkSupportUtils.hasAnnotation(
                                    builderMember, "lombok.Generated")) {
                        String methodName = builderMember.getSimpleName().toString();
                        if (methodName.startsWith("clear")) {
                            String propName =
                                    Introspector.decapitalize(
                                            methodName.substring(5)); // clear has 5 characters
                            defaultedPropertyNames.add(propName);
                        }
                    } else if (builderMember.getKind() == ElementKind.FIELD) {
                        VariableTree variableTree =
                                (VariableTree) atypeFactory.declarationFromElement(builderMember);
                        if (variableTree != null && variableTree.getInitializer() != null) {
                            String propName = variableTree.getName().toString();
                            defaultedPropertyNames.add(propName);
                            defaultedElements.put(builderMember, propName);
                        } else if (defaultedElements.containsKey(builderMember)) {
                            defaultedPropertyNames.add(defaultedElements.get(builderMember));
                        }
                    }
                }
            }
        }
        requiredPropertyNames.removeAll(defaultedPropertyNames);
        return requiredPropertyNames;
    }

    @Override
    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {
        return;
    }

    @Override
    public boolean isBuilderBuildMethod(ExecutableElement element) {
        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();

        if ((FrameworkSupportUtils.hasAnnotation(enclosingElement, "lombok.Generated")
                        || FrameworkSupportUtils.hasAnnotation(element, "lombok.Generated"))
                && enclosingElement.getSimpleName().toString().endsWith("Builder")) {
            return "build".equals(element.getSimpleName().toString());
        }
        return false;
    }
}
