package org.checkerframework.checker.calledmethods.builder;

import com.sun.source.tree.NewClassTree;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.code.Types;
import com.sun.tools.javac.processing.JavacProcessingEnvironment;
import java.beans.Introspector;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;
import org.checkerframework.checker.calledmethods.qual.CalledMethods;
import org.checkerframework.framework.type.AnnotatedTypeMirror;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;
import org.checkerframework.framework.util.AnnotatedTypes;
import org.checkerframework.javacutil.AnnotationUtils;
import org.checkerframework.javacutil.ElementUtils;
import org.checkerframework.javacutil.TreeUtils;
import org.checkerframework.javacutil.TypesUtils;

/**
 * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}
 * annotations to the code generated by AutoValue.
 */
public class AutoValueSupport implements BuilderFrameworkSupport {

    /** The type factory. */
    private CalledMethodsAnnotatedTypeFactory atypeFactory;

    /**
     * Create a new AutoValueSupport.
     *
     * @param atypeFactory the typechecker's type factory
     */
    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {
        this.atypeFactory = atypeFactory;
    }

    /**
     * This method ensures that the type of a copy constructor matches the type of the AutoValue
     * toBuilder method.
     *
     * @param tree AST for the call
     * @param type type of the call expression
     */
    @Override
    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {
        ExecutableElement element = TreeUtils.elementFromUse(tree);
        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();

        if (superclass.getKind() != TypeKind.NONE
                && ElementUtils.hasAnnotation(
                        TypesUtils.getTypeElement(superclass),
                        getAutoValuePackageName() + ".AutoValue.Builder")
                && element.getParameters().size() > 0) {
            handleToBuilderType(
                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());
        }
    }

    @Override
    public boolean isBuilderBuildMethod(ExecutableElement element) {
        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
        Element nextEnclosingElement = enclosingElement.getEnclosingElement();

        if (ElementUtils.hasAnnotation(
                enclosingElement, getAutoValuePackageName() + ".AutoValue.Builder")) {
            assert ElementUtils.hasAnnotation(
                            nextEnclosingElement, getAutoValuePackageName() + ".AutoValue")
                    : "class "
                            + nextEnclosingElement.getSimpleName()
                            + " is missing @AutoValue annotation";
            // it is a build method if it returns the type with the @AutoValue annotation
            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {
                return true;
            }
        }
        return false;
    }

    /**
     * For {@code build} methods on {@code Builder} types, the builder framework support should
     * determine the required properties and add a corresponding {@link
     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.
     *
     * @param t a method that is possibly the {@code build} method for a builder. The only
     *     guaranteed condition is that the enclosing class for the method is itself an inner class.
     */
    @Override
    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {

        ExecutableElement element = t.getElement();

        if (isBuilderBuildMethod(element)) {
            // determine the required properties and add a corresponding @CalledMethods annotation
            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
            Element nextEnclosingElement = enclosingElement.getEnclosingElement();
            Set<String> avBuilderSetterNames =
                    getAutoValueBuilderSetterMethodNames(enclosingElement);
            List<String> requiredProperties =
                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);
            AnnotationMirror newCalledMethodsAnno =
                    createCalledMethodsForAutoValueProperties(
                            requiredProperties, avBuilderSetterNames);
            // only add the new @CalledMethods annotation if there is not already a @CalledMethods
            // annotation present
            AnnotationMirror possibleBuildAnnotations =
                    t.getReceiverType()
                            .getAnnotationInHierarchy(
                                    atypeFactory
                                            .getQualifierHierarchy()
                                            .getTopAnnotation(newCalledMethodsAnno));
            if (possibleBuildAnnotations == null) {
                t.getReceiverType().addAnnotation(newCalledMethodsAnno);
            }
        }
    }

    @Override
    public void handlePossibleToBuilder(AnnotatedExecutableType t) {

        AnnotatedTypeMirror returnType = t.getReturnType();
        ExecutableElement element = t.getElement();

        String methodName = element.getSimpleName().toString();

        // make sure the method is toBuilder
        if ("toBuilder".equals(methodName)) {

            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
            TypeMirror superclass = enclosingElement.getSuperclass();

            if (ElementUtils.hasAnnotation(
                            enclosingElement, getAutoValuePackageName() + ".AutoValue")
                    && element.getModifiers().contains(Modifier.ABSTRACT)) {
                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);
            }

            if (superclass.getKind() != TypeKind.NONE) {
                TypeElement superElement = TypesUtils.getTypeElement(superclass);
                if (ElementUtils.hasAnnotation(
                        superElement, getAutoValuePackageName() + ".AutoValue")) {
                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);
                }
            }
        }
    }

    /**
     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type
     * can be the return type of toBuilder or the corresponding generated "copy" constructor.
     *
     * @param type type to update
     * @param builderType type of abstract @AutoValue.Builder class
     * @param classElement corresponding AutoValue class
     */
    private void handleToBuilderType(
            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {
        Element builderElement = TypesUtils.getTypeElement(builderType);
        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);
        List<String> requiredProperties =
                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);
        AnnotationMirror calledMethodsAnno =
                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);
        type.replaceAnnotation(calledMethodsAnno);
    }

    /**
     * Creates a @CalledMethods annotation for the given property names, converting the names to the
     * corresponding setter method name in the Builder.
     *
     * @param propertyNames the property names
     * @param avBuilderSetterNames names of all methods in the builder class
     * @return a @CalledMethods annotation that indicates all the given properties have been set
     */
    private AnnotationMirror createCalledMethodsForAutoValueProperties(
            final List<String> propertyNames, Set<String> avBuilderSetterNames) {
        List<String> calledMethodNames =
                propertyNames.stream()
                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))
                        .filter(Objects::nonNull)
                        .collect(Collectors.toList());
        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);
    }

    /**
     * Converts the name of a property (i.e. a field) into the name of its setter.
     *
     * @param prop the property name
     * @param builderSetterNames names of all methods in the builder class
     * @return the name of the setter for prop
     */
    private static String autoValuePropToBuilderSetterName(
            String prop, Set<String> builderSetterNames) {
        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'
        // and 'is'.
        Set<String> possiblePropNames = new LinkedHashSet<>();
        possiblePropNames.add(prop);
        if (prop.startsWith("get") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {
            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));
        } else if (prop.startsWith("is")
                && prop.length() > 2
                && Character.isUpperCase(prop.charAt(2))) {
            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));
        }

        for (String propName : possiblePropNames) {
            // in each case, the setter may be the property name itself, or prefixed by 'set'
            HashSet<String> setterNamesToTry = new HashSet<>();
            setterNamesToTry.add(propName);
            setterNamesToTry.add("set" + BuilderFrameworkSupportUtils.capitalize(propName));
            for (String setterName : setterNamesToTry) {
                if (builderSetterNames.contains(setterName)) {
                    return setterName;
                }
            }
        }

        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is
        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .
        // For now we return null, but once that bug is fixed, this should be changed to an
        // assertion failure.
        return null;
    }

    /**
     * Computes the required properties of an @AutoValue class.
     *
     * @param autoValueClassElement the @AutoValue class
     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class
     * @return a list of required property names
     */
    private List<String> getAutoValueRequiredProperties(
            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {
        return getAllAbstractMethods(autoValueClassElement).stream()
                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))
                .map(e -> e.getSimpleName().toString())
                .collect(Collectors.toList());
    }

    /**
     * Does member represent a required property of an AutoValue class?
     *
     * @param member member of an AutoValue class or superclass
     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder
     * @return {@code true} if member is required, {@code false} otherwise
     */
    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {
        String name = member.getSimpleName().toString();
        if (IGNORED_METHOD_NAMES.contains(name)) {
            return false;
        }
        TypeMirror returnType = ((ExecutableElement) member).getReturnType();
        if (returnType.getKind() == TypeKind.VOID) {
            return false;
        }
        // shouldn't have a nullable return
        boolean hasNullable =
                Stream.concat(
                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)
                                        .stream(),
                                returnType.getAnnotationMirrors().stream())
                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(".Nullable"));
        if (hasNullable) {
            return false;
        }
        // if return type of foo() is a Guava Immutable type, not required if there is a
        // builder method fooBuilder()
        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)
                && allBuilderMethodNames.contains(name + "Builder")) {
            return false;
        }
        // if it's an Optional, the Builder will automatically initialize it
        if (isOptional(returnType)) {
            return false;
        }
        // it's required!
        return true;
    }

    /**
     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at
     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.
     */
    private static final String[] IGNORED_METHOD_VALUES =
            new String[] {"equals", "hashCode", "toString", "<init>", "toBuilder"};

    /**
     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.
     *
     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange
     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.
     */
    private static final Set<String> IGNORED_METHOD_NAMES =
            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;

    /**
     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at
     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.
     */
    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =
            new String[] {
                "com.google.common.base.Optional",
                "java.util.Optional",
                "java.util.OptionalDouble",
                "java.util.OptionalInt",
                "java.util.OptionalLong"
            };

    /** Taken from AutoValue source code */
    private static final Set<String> OPTIONAL_CLASS_NAMES =
            new HashSet<>(Arrays.asList(OPTIONAL_CLASS_NAMES_VALUES));

    /**
     * Adapted from AutoValue source code.
     *
     * @param type some type
     * @return true if type is an Optional type
     */
    static boolean isOptional(TypeMirror type) {
        if (type.getKind() != TypeKind.DECLARED) {
            return false;
        }
        DeclaredType declaredType = (DeclaredType) type;
        TypeElement typeElement = (TypeElement) declaredType.asElement();
        return OPTIONAL_CLASS_NAMES.contains(typeElement.getQualifiedName().toString())
                && typeElement.getTypeParameters().size() == declaredType.getTypeArguments().size();
    }

    /**
     * Returns the names of setter methods for an AutoValue builder.
     *
     * @param builderElement the Element for an AutoValue builder
     * @return names of all methods whose return type is the builder itself or that return a Guava
     *     Immutable type
     */
    private Set<String> getAutoValueBuilderSetterMethodNames(Element builderElement) {
        return getAllAbstractMethods(builderElement).stream()
                .filter(e -> isAutoValueBuilderSetter(e, builderElement))
                .map(e -> e.getSimpleName().toString())
                .collect(Collectors.toSet());
    }

    /**
     * Is method a setter for an AutoValue builder?
     *
     * @param method a method of builder or one of its supertypes
     * @param builderElement element for the AutoValue builder
     * @return {@code true} if e is a setter for the builder, {@code false} otherwise
     */
    private boolean isAutoValueBuilderSetter(ExecutableElement method, Element builderElement) {
        TypeMirror retType = method.getReturnType();
        if (retType.getKind() == TypeKind.TYPEVAR) {
            // instantiate the type variable for the Builder class
            retType =
                    AnnotatedTypes.asMemberOf(
                                    atypeFactory.getContext().getTypeUtils(),
                                    atypeFactory,
                                    atypeFactory.getAnnotatedType(builderElement),
                                    method)
                            .getReturnType()
                            .getUnderlyingType();
        }
        // either the return type should be the builder itself, or it should be a Guava immutable
        // type
        return BuilderFrameworkSupportUtils.isGuavaImmutableType(retType)
                || builderElement.equals(TypesUtils.getTypeElement(retType));
    }

    /**
     * Get all the abstract methods for a class. This includes inherited abstract methods that are
     * not overridden by the class or a superclass.
     *
     * @param classElement the class
     * @return list of all abstract methods
     */
    public List<ExecutableElement> getAllAbstractMethods(Element classElement) {
        List<Element> supertypes = getAllSupertypes((Symbol) classElement);
        List<ExecutableElement> abstractMethods = new ArrayList<>();
        Set<ExecutableElement> overriddenMethods = new HashSet<>();
        for (Element t : supertypes) {
            for (Element member : t.getEnclosedElements()) {
                if (member.getKind() != ElementKind.METHOD) {
                    continue;
                }
                Set<Modifier> modifiers = member.getModifiers();
                if (modifiers.contains(Modifier.STATIC)) {
                    continue;
                }
                if (modifiers.contains(Modifier.ABSTRACT)) {
                    // make sure it's not overridden
                    if (!overriddenMethods.contains(member)) {
                        abstractMethods.add((ExecutableElement) member);
                    }
                } else {
                    // exclude any methods that this overrides
                    overriddenMethods.addAll(
                            AnnotatedTypes.overriddenMethods(
                                            atypeFactory.getElementUtils(),
                                            atypeFactory,
                                            (ExecutableElement) member)
                                    .values());
                }
            }
        }
        return abstractMethods;
    }

    /**
     * Get the qualified name of the package containing AutoValue annotations. This method
     * constructs the String dynamically, to ensure it does not get rewritten due to relocation of
     * the {@code "com.google"} package during the build process.
     *
     * @return {@code "com.google.auto.value"}
     */
    private String getAutoValuePackageName() {
        String com = "com";
        return com + "." + "google.auto.value";
    }

    /**
     * @param symbol symbol for a class
     * @return list including the class and all its supertypes, with a guarantee that subtypes
     *     appear before supertypes
     */
    private List<Element> getAllSupertypes(Symbol symbol) {
        Types types =
                Types.instance(
                        ((JavacProcessingEnvironment) atypeFactory.getProcessingEnv())
                                .getContext());
        return types.closure(symbol.type).stream().map(t -> t.tsym).collect(Collectors.toList());
    }
}
