// This stub file implements the following unsound behavior:
//
// For any key or value formal parameter whose type is Object (instead of
// the element type), permit null as an argument.
//
// The affected methods are:
// containsKey(Object)
// contains(Object)
// containsValue(Object)
// frequency(Collection<?>, Object)
// get(Object)
// getOrDefault(Object, V)
// indexOf(Object)
// lastIndexOf(Object)
// removeFirstOccurrence(Object)
// removeLastOccurrence(Object )
// remove(Object)
// remove(Object, Object)
//
// A null argument may cause some implementations (like ConcurrentHashMap) to
// throw NullPointerException. However, many other common implementations permit
// such calls, so some users may wish to sacrifice soundness for convenience.
//
// To learn how to use this file, see https://checkerframework.org/manual/#stub-using .
//
// For further discussion of the challenges presented by Java's mix of
// null-friendly and null-hostile collections, see https://tinyurl.com/cfissue/3040 .

package java.util;

import org.checkerframework.checker.nullness.qual.Nullable;

public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    public int indexOf(@Nullable Object o);
    public int lastIndexOf(@Nullable Object o);
}

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    public boolean contains(@Nullable Object o);
    public int indexOf(@Nullable Object o);
    public int lastIndexOf(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

public interface Collection<E> extends Iterable<E> {
    boolean contains(@Nullable Object o);
    boolean add(@Nullable E e);
    boolean remove(@Nullable Object o);
    boolean containsAll(Collection<? extends @Nullable Object> c);
    boolean addAll(Collection<? extends @Nullable E> c);
    boolean retainAll(Collection<? extends @Nullable Object> c);
}

public interface Comparator<T> {
    int compare(@Nullable T o1, @Nullable T o2);

}

public interface Deque<E> extends Queue<E> {
    boolean removeFirstOccurrence(@Nullable Object o);
    boolean removeLastOccurrence(@Nullable Object o);
    boolean remove(@Nullable Object o);
    boolean contains(@Nullable Object o);
}

public interface List<E> extends Collection<E> {
    boolean contains(@Nullable Object o);
    boolean remove(@Nullable Object o);
    int indexOf(@Nullable Object o);
    int lastIndexOf(@Nullable Object o);
}

public interface Map<K, V> {
    boolean containsKey(@Nullable Object key);
    boolean containsValue(@Nullable Object value);
    V get(@Nullable Object key);
    V remove(@Nullable Object key);
    default V getOrDefault(@Nullable Object key, V defaultValue);
    default boolean remove(@Nullable Object key, @Nullable Object value);
    }

public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable {
    public boolean remove(@Nullable Object o);
    public boolean contains(@Nullable Object o);
}

public interface Set<E> extends Collection<E> {
    boolean contains(@Nullable Object o);
    boolean remove(@Nullable Object o);
}

public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
{
    public boolean containsKey(@Nullable Object key);
    public boolean containsValue(@Nullable Object value);
    public V get(@Nullable Object key);
    public V remove(@Nullable Object key);
}

public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
{
    public boolean contains(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

package java.util.concurrent;

public class ConcurrentLinkedDeque<E>
    extends AbstractCollection<E>
    implements Deque<E>, java.io.Serializable {
    public boolean removeFirstOccurrence(@Nullable Object o);
    public boolean removeLastOccurrence(@Nullable Object o);
    public boolean contains(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

public class ConcurrentLinkedQueue<E> extends AbstractQueue<E>
        implements Queue<E>, java.io.Serializable {
    public boolean contains(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

public interface ConcurrentMap<K,V> extends Map<K,V> {
    V putIfAbsent(@Nullable K key, @Nullable V value);
    boolean remove(@Nullable Object key, @Nullable Object value);
}

public class ConcurrentSkipListSet<E>
    extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable {
    public boolean contains(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    public boolean contains(@Nullable Object o);
    public int indexOf(@Nullable Object o);
    public int lastIndexOf(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

public class CopyOnWriteArraySet<E> extends AbstractSet<E>
        implements java.io.Serializable {
    public boolean contains(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}

public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
    implements BlockingQueue<E> {
    public boolean remove(@Nullable Object o);
}

public class SynchronousQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, java.io.Serializable {
    public boolean contains(@Nullable Object o);
    public boolean remove(@Nullable Object o);
}
