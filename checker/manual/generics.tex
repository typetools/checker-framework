% qualifier parameter syntax
%BEGIN LATEX
% This definition for LaTeX is a bit gross.  The MnSymbol package defines
% \llangle and \rrangle but also changes other things.  unicode-math gives
% \lAngle, but I have not tried it.
\newcommand{\qp}[1]{\ensuremath{\langle\!\!\langle}#1\ensuremath{\rangle\!\!\rangle}}
%END LATEX
%HEVEA \newcommand{\qp}[1]{\@print@u{X27EA}#1\@print@u{X27EB}}

\htmlhr
\chapter{Generics and polymorphism\label{polymorphism}}

This chapter describes support for Java generics (also known as
``parametric polymorphism'') and polymorphism over type qualifiers.

The Checker Framework currently supports two schemes for polymorphism over
type qualifiers.

Section~\ref{qualifier-polymorphism} describes the
original scheme, which uses method-based annotations that are meta-annotated
with \refclass{framework/qual}{PolymorphicQualifier}.

Section~\ref{qualifier-parameters} describes the qualifier parameters
scheme, in which qualifier parameters are specified for classes and methods
similarly to Java generics.
The qualifier
parameter scheme is more powerful than the original approach, but is
currently (as of February 2015)
experimental and incurs a
%% Note: The 50% performance penalty was measured by
%% comparing the classic regex checker vs the qualifier parameter
%% checker on daikon, chuckwa, and solr.
50\% performance penalty.
Currently, % February 2015
only the Tainting Checker
(Chapter~\ref{tainting-checker}) and the Regex Checker
(Chapter~\ref{regex-checker}) support qualifier parameters.


\section{Generics (parametric polymorphism or type polymorphism)\label{generics}}

The Checker Framework fully supports
type-qualified Java generic types and methods (also known in the research literature as ``parametric
polymorphism'').
When instantiating a generic type,
clients supply the qualifier along with the type argument, as in
\code{List<@NonNull String>}.


\subsection{Raw types\label{generics-raw-types}}

Before running any pluggable type-checker, we recommend that you eliminate
raw types from your code (e.g., your code should use \code{List<...>} as
opposed to \code{List}).
Your code should compile without warnings when using the standard Java
compiler and the \<-Xlint:unchecked -Xlint:rawtypes> command-line options.
Using generics helps prevent type errors just as using a pluggable
type-checker does, and makes the Checker Framework's warnings easier to
understand.

If your code uses raw types, then the Checker Framework will do its best to
infer the Java type parameters and the type qualifiers.  If it infers
imprecise types that lead to type-checking warnings elsewhere, then you have
two options.  You can convert the raw types such as \code{List} to
parameterized types such as \code{List<String>}, or you can supply the
\<-AignoreRawTypeArguments> command-line option.  That option causes the
Checker Framework to ignore all subtype tests for type arguments that
were inferred for a raw type.


\subsection{Restricting instantiation of a generic class\label{generics-instantiation}}

When you define a generic class in Java, the \<extends> clause
of the generic type parameter (known as the ``upper bound'') requires that
the corresponding type argument must be a subtype of the bound.
For example, given the definition
\verb|class G<T extends Number> {...}|,
the upper bound is \<Number>
and a client can instantiate it as \code{G<Number>} or \code{G<Integer>}
but not \code{G<Date>}.

You can write a type qualifier on the \<extends> clause to make the upper
bound a qualified type.  For example, you can declare that a generic list class can hold only non-null values:
% Similarly, a generic map
% class might indicate it requires an immutable key type, but that it
% supports both nullable and non-null value types.

\begin{Verbatim}
  class MyList<T extends @NonNull Object> {...}

  MyList<@NonNull String> m1;       // OK
  MyList<@Nullable String> m2;      // error
\end{Verbatim}

That is, in the above example, all
arguments that replace \code{T} in \code{MyList<T>} must be subtypes of
\code{@NonNull Object}.

Conceptually, each generic type parameter has two bounds --- a lower bound
and an upper bound --- and at instantiation, the type argument must be
within the bounds.  Java only allows you to specify the upper bound; the
lower bound is implicitly the bottom type \<void>.  The Checker Framework
gives you more power:  you can specify both an upper and lower bound for
type parameters and wildcards.  For the upper bound, write a type qualifier
on the \<extends> clause, and for the lower bound, write a type qualifier
on the type variable.

\begin{Verbatim}
  class MyList<@LowerBound T extends @UpperBound Object> { ... }
\end{Verbatim}

For a concrete example, recall the type system of the Regex Checker (see
Figure~\refwithpage{regex-checker}) in which
 \<@Regex(0)> :>
 \<@Regex(1)> :>
 \<@Regex(2)> :>
 \<@Regex(3)> :> \ldots.

\begin{Verbatim}
  class MyRegexes<@Regex(5) T extends @Regex(1) String> { ... }

  MyRegexes<@Regex(0) String> mu;   // error - @Regex(0) is not a subtype of @Regex(1)
  MyRegexes<@Regex(1) String> m1;   // OK
  MyRegexes<@Regex(3) String> m3;   // OK
  MyRegexes<@Regex(5) String> m5;   // OK
  MyRegexes<@Regex(6) String> m6;   // error - @Regex(6) is not a supertype of @Regex(5)
\end{Verbatim}

The above declaration states that the upper bound of the type variable
is \<@Regex(1) String> and the lower bound is \<@Regex(5) void>.  That is,
arguments that replace \code{T} in \code{MyList<T>} must be subtypes of
\code{@Regex(1) String} and supertypes of \code{@Regex(5) void}.
Since \<void> cannot be used to instantiate a generic class, \<MyList> may
be instantiated with \<@Regex(1) String> through \<@Regex(5) String>.


To specify an exact bound, place the same annotation on both bounds.  For example:

\begin{Verbatim}
  class MyListOfNonNulls<@NonNull T extends @NonNull Object> { ... }
  class MyListOfNullables<@Nullable T extends @Nullable Object> { ... }

  MyListOfNonNulls<@NonNull Number> v1;      // OK
  MyListOfNonNulls<@Nullable Number> v2;     // error
  MyListOfNullables<@NonNull Number> v4;     // error
  MyListOfNullables<@Nullable Number> v3;    // OK
\end{Verbatim}

It is an error if the lower bound is not a subtype of the upper bound.

\begin{Verbatim}
  class MyClass<@Nullable T extends @NonNull Object>  // error @Nullable is not a supertype of @NonNull
\end{Verbatim}


\subsubsection{Defaults\label{generics-defaults}}
If the \<extends> clause is omitted,
then the upper bound defaults to \<@\emph{TopType} Object>.
If no type annotation is written on the type parameter name,
then the lower bound defaults to \<@\emph{BottomType} void>.
If the \<extends> clause is written but contains no type qualifier,
then the normal defaulting rules apply to the type in the \<extends>
clause (see Section~\ref{climb-to-top}).

These rules mean that even though in Java the following two declarations
are equivalent:

\begin{Verbatim}
  class MyClass<T>
  class MyClass<T extends Object>
\end{Verbatim}

\noindent
they may specify different type qualifiers on the upper bound, depending on
the type system's defaulting rules.
% Cross-reference to the justification for this?

%% Mike is concerned that an exhaustive example here would take too
%% much space for not enough benefit.


\subsection{Type annotations on a use of a generic type variable\label{type-variable-use}}

A type annotation on a use of a generic type variable overrides/ignores any type
qualifier (in the same type hierarchy) on the corresponding actual type
argument.  For example, suppose that \code{T} is a formal type parameter.
Then using \code{@Nullable T} within the scope of \code{T} applies the type
qualifier \code{@Nullable} to the (unqualified) Java type of \code{T}\@.
This feature is only rarely used.

Here is an example of applying a type annotation to a generic type
variable:

\begin{Verbatim}
  class MyClass2<T> {
    ...
    @Nullable T myField = null;
    ...
  }
\end{Verbatim}

\noindent
The type annotation does not restrict how \code{MyClass2} may be
instantiated.  In other words, both
\code{MyClass2<@NonNull String>} and \code{MyClass2<@Nullable String>} are
legal, and in both cases \code{@Nullable T} means \code{@Nullable String}.
In \code{MyClass2<@Interned String>},
\code{@Nullable T} means \code{@Nullable @Interned String}.

% Note that a type annotation on a generic type variable does not act like
% other type qualifiers.  In both cases the type annotation acts as a type
% constructor, but as noted above they act slightly differently.


% %% This isn't quite right because a type qualifier is itself a type
% %% constructor.
% More formally, a type annotation on a generic type variable acts as a type
% constructor rather than a type qualifier.  Another example of a type
% constructor is \code{[]}.  Just as \code{T[]} is not the same type as
% \code{T}, \code{@Nullable T} is not (necessarily) the same type as
% \code{T}.


\subsection{Annotations on wildcards\label{annotations-on-wildcards}}

At an instantiation of a generic type, a Java wildcard indicates that some
constraints are known on the type argument, but the type argument is not known
exactly.
For example, you can indicate that the type parameter for variable \<ls> is
some unknown subtype of \<CharSequence>:

\begin{Verbatim}
  List<? extends CharSequence> ls;
  ls = new ArrayList<String>();      // OK
  ls = new ArrayList<Integer>();     // error - Integer is not a subtype of CharSequence
\end{Verbatim}

For more details about wildcards, see the
\href{https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html}{Java
  tutorial on wildcards} or
\href{https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1}{JLS
  \S 4.5.1}.

You can write a type annotation on the bound of a wildcard:

\begin{Verbatim}
  List<? extends @NonNull CharSequence> ls;
  ls = new ArrayList<@NonNull String>();      // OK
  ls = new ArrayList<@Nullable String>();     // error - @Nullable is not a subtype of @NonNull
\end{Verbatim}

Conceptually, every wildcard has two bounds --- an upper bound and a lower
bound.  Java only permits you to write the upper bound (with
\code{<?\ extends SomeType>}) or the lower bound (with \code{<?\ super
  OtherType>}), but not both; the unspecified bound is implicitly the
top type
\<Object> or the bottom type \<void>.  The Checker Framework is more
flexible:  it lets you simultaneously write annotations on both the top and
the bottom type.  To annotate the implicit bound, write the type annotation
before the \<?>.  For example:

\begin{Verbatim}
  List<@LowerBound ? extends @UpperBound CharSequence> lo;
  List<@UpperBound ? super @NonNull Number> ls;
\end{Verbatim}

For an unbounded wildcard (\code{<?>}, with neither
bound specified), the annotation in front of a wildcard applies
to both bounds.  The following three declarations are equivalent (except
that you cannot write the bottom type \<void>; note that
\sunjavadoc{java/lang/Void.html}{Void} does not denote the bottom type):

\begin{Verbatim}
  List<@NonNull ?> lnn;
  List<@NonNull ? extends @NonNull Object> lnn;
  List<@NonNull ? super @NonNull void> lnn;
\end{Verbatim}

\noindent
Note that the annotation in front of a type parameter always applies to its
lower bound, because type parameters can only be written with \<extends>
and never \<super>.


% Defaults are as for type variables (see Section~\ref{generics-defaults}),
% with one exception.

The defaulting rules for
wildcards also differ from those of type parameters (see
Section~\ref{inherited-wildcard-annotations}).


%% Mike isn't sure that this section pulls its weight, especially since it
%% doesn't justify why it is desirable to be able to constrain both the
%% upper and the lower bound of a type.  If readers believe that, they will
%% be OK with the syntax.
% \subsubsection{Type parameter declaration annotation rationale\label{type-parameter-rationale}}
%
% It is desirable to be able to constrain both the upper and the lower bound
% of a type, as in
%
% \begin{Verbatim}
%   class MyClass<T extends @C MyUpperBound super @D void> { ... }
% \end{Verbatim}
%
% However, doing so is not possible due to two limitations of Java's syntax.
% First, it is illegal to specify both the upper and the lower bound of a
% type parameter or wildcard.
% Second, it is impossible to specify a type annotation for a lower
% bound without also specifying a type (use of \<void> is illegal).
%
% Thus, when you wish to specify both bounds, you write one of them
% explicitly, and you write the other one in front of the type variable name
% or \<?>.  When you wish to specify two identical bounds, you write a
% single annotation in front of the type variable name or \<?>.


\subsection{Examples of qualifiers on a type parameter\label{type-parameter-qualifier-examples}}

Recall that \<@Nullable \emph{X}> is a supertype of \<@NonNull \emph{X}>,
for any \emph{X}\@.
Most of of the following types mean different things:

\begin{Verbatim}
  class MyList1<@Nullable T> { ... }
  class MyList1a<@Nullable T extends @Nullable Object> { ... } // same as MyList1
  class MyList2<@NonNull T extends @NonNull Object> { ... }
  class MyList2a<T extends @NonNull Object> { ... } // same as MyList2
  class MyList3<T extends @Nullable Object> { ... }
\end{Verbatim}

\<MyList1> and \<MyList1a> must be instantiated with a nullable type.
The implementation of \<MyList1> must be able to consume (store) a null
value and produce (retrieve) a null value.

\<MyList2> and \<MyList2a> must be instantiated with non-null type.
The implementation of \<MyList2> has to account for only non-null values --- it
does not have to account for consuming or producing null.

\<MyList3> may be instantiated either way:
with a nullable type or a non-null type.  The implementation of \<MyList3> must consider
that it may be instantiated either way --- flexible enough to support either
instantiation, yet rigorous enough to impose the correct constraints of the
specific instantiation.  It must also itself comply with the constraints of
the potential instantiations.

One way to express the difference among \<MyList1>, \<MyList2>, and
\<MyList3> is by comparing what expressions are legal in the implementation
of the list --- that is, what expressions may appear in the ellipsis in the
declarations above, such as inside a method's body.  Suppose each class
has, in the ellipsis, these declarations:

\begin{Verbatim}
  T t;
  @Nullable T nble;      // Section "Type annotations on a use of a generic type variable", below,
  @NonNull T nn;         // further explains the meaning of "@Nullable T" and "@NonNull T".
  void add(T arg) { }
  T get(int i) { }
\end{Verbatim}

\noindent
Then the following expressions would be legal, inside a given
implementation --- that is, also within the ellipses.
(Compilable source code appears as file
\<checker-framework/checker/tests/nullness/generics/GenericsExample.java>.)

\begin{tabular}{|l|c|c|c|c|c|} \hline
                        & MyList1 & MyList2 & MyList3 \\ \hline
  t = null;             & OK      & error   & error   \\ \hline
  t = nble;             & OK      & error   & error   \\ \hline
  nble = null;          & OK      & OK      & OK      \\ \hline
  nn = null;            & error   & error   & error   \\ \hline
  t = this.get(0);      & OK      & OK      & OK      \\ \hline
  nble = this.get(0);   & OK      & OK      & OK      \\ \hline
  nn = this.get(0);     & error   & OK      & error   \\ \hline
  this.add(t);          & OK      & OK      & OK      \\ \hline
  this.add(nble);       & OK      & error   & error   \\ \hline
  this.add(nn);         & OK      & OK      & OK      \\ \hline
\end{tabular}


%% This text is not very helpful.
% The
% implementation of \code{MyList2} may only place non-null objects in the
% list and may assume that retrieved elements are non-null.  The
% implementation of \code{MyList3} is similar in that it may only place
% non-null objects in the list, because it might be instantiated as, say,
% \code{MyList3<@NonNull Date>}.  When retrieving elements from the list,
% the implementation of \code{MyList3} must account for the fact that
% elements of \code{MyList3} may be null, because it might be instantiated
% as, say, \code{MyList3<@Nullable Date>}.
The differences are more
significant when the qualifier hierarchy is more complicated than just
\<@Nullable> and \<@NonNull>.

\subsection{Covariant type parameters\label{covariant-type-parameters}}

Java types are \emph{invariant} in their type parameter.  This means that
\code{A<X>} is a subtype of \code{B<Y>} only if \<X> is identical to \<Y>.  For
example, \code{ArrayList<Number>} is a subtype of \code{List<Number>}, but
neither \code{ArrayList<Integer>} nor \code{List<Integer>} is a subtype of
\code{List<Number>}.  (If they were, there would be a type hole in the Java
type system.)  For the same reason, type parameter annotations are treated
invariantly.  For example, \code{List<@Nullable String>} is not a subtype
of \code{List<String>}.

When a type parameter is used in a read-only way --- that is, when values
of that type are read but are never assigned --- then it is safe for the
type to be \emph{covariant} in the type parameter.  Use the \refqualclass{checker/nullness/qual}{Covariant} annotation to indicate
this.
When a type parameter is covariant, two instantiations of the class with
different type arguments have the same subtyping relationship as the type
arguments do.

For example, consider \<Iterator>.  Its elements can be read but not
written, so \code{Iterator<@Nullable String>} can be a subtype of
\code{Iterator<String>} without introducing a hole in the type system.
Therefore, its type parameter is annotated with \<@Covariant>.
The first type parameter of \<Map.Entry> is also covariant.
Another example would be the type parameter of a hypothetical class
\<ImmutableList>.

The \<@Covariant> annotation is trusted but not checked.
If you incorrectly specify as covariant a type parameter that that can be
written (say, the class performs a
\<set> operation or some other mutation on an object of that type), then
you have created an unsoundness in the type system.
For example, it would be incorrect to annotate the type parameter of
\<ListIterator> as covariant, because \<ListIterator> supports a \<set>
operation.


\subsection{Method type argument inference and type qualifiers\label{infer-method-type-qualifiers}}

Sometimes method type argument inference does not interact well with
type qualifiers. In such situations, you might need to provide
explicit method type arguments, for which the syntax is as follows:

\begin{alltt}
    Collections.</*@MyTypeAnnotation*/ Object>sort(l, c);
\end{alltt}

\noindent
This uses Java's existing syntax for specifying a method call's type arguments.



\section{Qualifier polymorphism\label{qualifier-polymorphism}}

This section describes the original Checker Framework scheme for qualifier
polymorphism.  Section~\ref{qualifier-parameters} describes an alternative
scheme that uses qualifier parameters.

The Checker Framework supports type \emph{qualifier} polymorphism for
methods, which permits a single method to have multiple different qualified
type signatures.  This is similar to Java's generics, but is used in
situations where you cannot use Java generics.  If you can use generics,
you typically do not need to use a polymorphic qualifier such as \<@PolyNull>.

To \emph{use} a polymorphic qualifier, just write it on a type.
For example, you can write \<@PolyNull> anywhere in a method that you would write
\<@NonNull> or \<@Nullable>.
A polymorphic qualifier can be used on a method signature or body.
It may not be used on a class or field.

A method written using a polymorphic qualifier conceptually has multiple
versions, somewhat like a template in C++ or the generics feature of Java.
In each version, each instance of the polymorphic qualifier has been
replaced by the same other qualifier from the hierarchy.  See the examples
below in Section~\ref{qualifier-polymorphism-examples}.

The method body must type-check with all signatures.  A method call is
type-correct if it type-checks under any one of the signatures.  If a call
matches multiple signatures, then the compiler uses the most specific
matching signature for the purpose of type-checking.  This is the same as
Java's rule for resolving overloaded methods.

To \emph{define} a polymorphic qualifier, mark the definition with
\refqualclass{framework/qual}{PolymorphicQualifier}.  For example,
\refqualclass{checker/nullness/qual}{PolyNull} is a polymorphic type
qualifier for the Nullness type system:

\begin{Verbatim}
  @PolymorphicQualifier
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface PolyNull { }
\end{Verbatim}

\noindent
See Section~\ref{polyall} for a way you can sometimes avoid defining a new
polymorphic qualifier.


\subsection{Examples of using polymorphic qualifiers\label{qualifier-polymorphism-examples}}

As an example of the use of \<@PolyNull>, method
\sunjavadoc{java/lang/Class.html\#cast-java.lang.Object-}{Class.cast}
returns null if and only if its argument is \<null>:

\begin{Verbatim}
  @PolyNull T cast(@PolyNull Object obj) { ... }
\end{Verbatim}

\noindent
This is like writing:

\begin{Verbatim}
   @NonNull T cast( @NonNull Object obj) { ... }
  @Nullable T cast(@Nullable Object obj) { ... }
\end{Verbatim}

\noindent
except that the latter is not legal Java, since it defines two
methods with the same Java signature.


As another example, consider

\begin{Verbatim}
  // Returns null if either argument is null.
  @PolyNull T max(@PolyNull T x, @PolyNull T y);
\end{Verbatim}

\noindent
which is like writing

\begin{Verbatim}
   @NonNull T max( @NonNull T x,  @NonNull T y);
  @Nullable T max(@Nullable T x, @Nullable T y);
\end{Verbatim}

\noindent
At a call site, the most specific applicable signature is selected.

Another way of thinking about which one of the two \code{max} variants is
selected is that the nullness annotations of (the declared types of) both
arguments are \emph{unified} to a type that is a supertype of both, also
known as the \emph{least upper bound} or lub.  If both
arguments are \code{@NonNull}, their unification (lub) is \<@NonNull>, and the
method return type is \<@NonNull>.  But if even one of the arguments is \<@Nullable>,
then the unification (lub) is \<@Nullable>, and so is the return type.



\subsection{Relationship to subtyping and generics\label{qualifier-polymorhism-vs-subtyping}}

Qualifier polymorphism has the same purpose and plays the same role as
Java's generics.  If a method is written using generics, it usually does
not need qualifier polymorphism.  If you have legacy code that is not
written generically, and you cannot change it to use generics, then you can
use qualifier polymorphism to achieve a similar effect, with respect to
type qualifiers only.  The base Java types are still treated non-generically.

Why not use ordinary subtyping to handle qualifier polymorphism?
Ordinarily, when you want a method to work on multiple types, you can just
use Java's subtyping.  For example, the \<equals> method is declared to
take an \<Object> as its first formal parameter, but it can be called on a
\<String> or a \<Date> because those are subtypes of \<Object>.

In most cases, the same subtyping mechanism works with type qualifiers.
\<String> is a supertype of \<@Interned String>, so a method \<toUpperCase>
that is declared to take a \<String> parameter can also be called on a
\<@Interned String> argument.

You use qualifier polymorphism in the same cases when you would use Java's
generics.  (If you can use Java's generics, then that is often better and
you don't also need to use qualifier polymorphism.)  One example is when
you want a method to operate on collections with different types of
elements.  Another example is when you want two different formal parameters
to be of the same type, without constraining them to be one specific type.


\subsection{Using multiple polymorphic qualifiers in a method signature\label{qualifier-polymorphism-multiple-qualifiers}}

%% I can't think of a non-clumsy way to say this.
% Each method containing a polymorphic qualifier is (conceptually) expanded
% into multiple versions completely independently.

Usually, it does not make sense to write only a single instance of a polymorphic
qualifier in a method definition:  if you write one instance of (say)
\<@PolyNull>, then you should use at least two.  (An exception is a
polymorphic qualifier on an array element type; this section ignores that
case, but see below for further details.)

For example, there is no point to writing

\begin{Verbatim}
  void m(@PolyNull Object obj)
\end{Verbatim}

\noindent
which expands to

\begin{Verbatim}
  void m(@NonNull Object obj)
  void m(@Nullable Object obj)
\end{Verbatim}

This is no different (in terms of which calls to the method will
type-check) than writing just

\begin{Verbatim}
  void m(@Nullable Object obj)
\end{Verbatim}

The benefit of polymorphic qualifiers comes when one is used multiple times
in a method, since then each instance turns into the same type qualifier.
Most frequently, the polymorphic qualifier appears on at least one formal
parameter and also on the return type.  It can also be useful to have
polymorphic qualifiers on (only) multiple formal parameters, especially if
the method side-effects one of its arguments.
For example, consider

\begin{Verbatim}
void moveBetweenStacks(Stack<@PolyNull Object> s1, Stack<@PolyNull Object> s2) {
  s1.push(s2.pop());
}
\end{Verbatim}

\noindent
In this example, if it is acceptable to rewrite your code to use Java
generics, the code can be even cleaner:

\begin{Verbatim}
<T> void moveBetweenStacks(Stack<T> s1, Stack<T> s2) {
  s1.push(s2.pop());
}
\end{Verbatim}


%% It would be nice to give an example that isn't too contrived.


\subsection{Using a single polymorphic qualifier on an element type\label{qualifier-polymorphism-element-types}}

There is an exception to the general rule that a polymorphic qualifier
should be used multiple times in a signature.  It can make sense to use a
polymorphic qualifier just once, if it is on an array or generic element
type.

For example, consider a routine that returns the index, in an array, of a
given element:

\begin{Verbatim}
  public static int indexOf(@PolyNull Object[] a, @Nullable Object elt) { ... }
\end{Verbatim}

If \<@PolyNull> were replaced with either \<@Nullable> or \<@NonNull>, then
one of these safe client calls would be rejected:

\begin{Verbatim}
  @Nullable Object[] a1;
  @NonNull Object[] a2;

  indexOf(a1, someObject);
  indexOf(a2, someObject);
\end{Verbatim}

Of course, it would be better style to use a generic method, as in either
of these signatures:

\begin{Verbatim}
 public static <T extends @Nullable Object> int indexOf(T[] a, @Nullable Object elt) { ... }
 public static <T extends @Nullable Object> int indexOf(T[] a, T elt) { ... }
\end{Verbatim}

The examples in this section use arrays, but analogous collection examples exist.

These examples show that use of a single polymorphic qualifier may be
necessary in legacy code, but can often be avoided by use of better code
style.


\subsection{The \code{@PolyAll} qualifier applies to every type system\label{polyall}}

Ordinarily, you have to create a new polymorphic type qualifier for each
type system you write.  This can be tedious.  More seriously, it can lead
to an explosion in the number of type annotations, if some method is
qualifier-polymorphic over every type qualifier hierarchy.

For example, a method that only performs \<==> on array elements will work
no matter what the array's element types are:

\begin{Verbatim}
  /** Searches for the first occurrence of the given element in the array,
   *  testing for equality using == (not the equals method). */
  public static int indexOfEq(@PolyAll Object[] a, @Nullable Object elt) {
    for (int i=0; i<a.length; i++)
      if (elt == a[i])
        return i;
    return -1;
  }
\end{Verbatim}

% TODO: As of June 2015, @PolyAll does not take an optional argument.

The \refqualclass{framework/qual}{PolyAll} qualifier takes an optional argument so that you can
specify multiple, independent polymorphic type qualifiers.  For example,
the method also works no matter what the type argument on the second
argument is.  This signature is overly restrictive:

\begin{Verbatim}
  /** Returns true if the arrays are elementwise equal,
   *  testing for equality using == (not the equals method). */
  public static int eltwiseEqualUsingEq(@PolyAll Object[] a, @PolyAll Object elt) {
    for (int i=0; i<a.length; i++)
      if (elt != a[i])
        return false;
    return true;
  }
\end{Verbatim}

\noindent
That signature requires the element type annotation to be identical for the
two arguments.  For example, it forbids this invocation:

\begin{Verbatim}
    @Mutable Object[] x;
  @Immutable Object   y;
  ... indexOf(x, y) ...
\end{Verbatim}

\noindent
A better signature lets the two arrays' element types vary independently:

\begin{Verbatim}
  public static int eltwiseEqualUsingEq(@PolyAll(1) Object[] a, @PolyAll(2) Object elt)
\end{Verbatim}

\noindent
Note that in this case, the \<@Nullable> annotation on \<elt>'s type is no
longer necessary, since it is subsumed by \<@PolyAll>.

The \<@PolyAll> annotation applies to every type qualifier hierarchy for
which no explicit qualifier is written.  For example, a declaration like
\<@PolyAll @NonNull Object elt> is polymorphic over every type system
\emph{except} the nullness type system, for which the type is fixed at
\<@NonNull>.  That would be the proper declaration for \<elt> if the body
had used \<elt.equals(a[i])> instead of \<elt == a[i]>.


% Suppose that some type system has two qualifiers, such as
% \<@Nullable> and \<@NonNull>.  When a polymorphic type qualifier such
% as \<@PolyNull> is used in a method, then the method conceptually
% has two different versions:  one in which every instance of
% \<@PolyNull> has been replaced by \<@NonNull> and one in
% which every instance of \<@PolyNull> has been replaced by
% \<@Nullable>.


\section{Qualifier parameters\label{qualifier-parameters}}

This section describes qualifier parameters which is the new, more-powerful
qualifier polymorphism scheme.  As of February 2015, only the
Tainting Checker (Chapter~\ref{tainting-checker}) and the Regex Checker
(Chapter~\ref{regex-checker}) support qualifier parameters.
Other checkers with
qualifier polymorphism support use the original qualifier polymorphism scheme
(Section~\ref{qualifier-polymorphism}).

Qualifier parameters provide a way for you to re-use the same code with
different type qualifiers in a type-safe manner.

Qualifier parameters are very similar to Java generics, so if you understand the
benefits of generics and how to use them, you will find qualifier
parameters natural.  Both mechanisms are
used on classes and methods where different instances of the class have different
types.  Without generics or qualifier parameters, the types of the members would have
to be overly general, which would cause information loss, compiler
warnings, the need for casts, and potentially run-time errors.
Generics parameterize a class or method with
a \emph{type}, so that a client can specialize the definition with a type
as in \code{List<Integer>} or \code{List<String>}.  By contrast, qualifier parameters
enable a client to specialize the definition with just a \emph{qualifier}
as in
\code{MyClass\qp{@Regex}} or \code{MyClass\qp{@NonNull}}.


\subsection{Motivation for qualifier parameters\label{qualifier-parameters-motivation}}

As an example of a problem that qualifier parameters solve, consider
the \<Holder> class below.  In some uses of \<Holder>, the \<item> field
holds a \code{@Tainted String} value, and in other uses of \<Holder>, the \<item>
field holds an \code{@Untainted String} value.  The only declaration of \<item>
that is consistent with all uses is \code{@Tainted String}, which is a supertype
of \<@Untainted String>.  When an \code{@Untainted String} value is put in a \code{Holder},
a cast is required when the value is later retrieved.

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
    class Holder {
        @Tainted String item;   // overly-general declaration, leads to casts
    }

    // taintedHolder can hold both @Tainted and @Untainted values
    Holder taintedHolder = new Holder();
    taintedHolder.item = getTaintedValue();
    @Tainted String taintedString = taintedHolder.item;  // OK; type-checks with the Tainting Checker.

    // The programmer intends untaintedHolder to hold only @Untainted values
    Holder untaintedHolder = new Holder();
    untaintedHolder.item = getUntaintedValue();
    @Untainted String untaintedString = untaintedHolder.item;  // safe code, but Tainting Checker compile-time error.
    // A cast makes the assignment type-check, but casts are unsound and error-prone.
    String untaintedString = (@Untainted untaintedString) untaintedHolder.item;
    taintedHolder.item = getTaintedValue(); // An error that we would like the type sysetm to catch
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

Qualifier parameters allow sound type-checking of this
code without the use of casts.


\subsection{Overview of qualifier parameters\label{qualifier-parameters-overview}}

These following examples add qualifier parameters to
\code{Holder} from Section~\ref{qualifier-parameters-motivation} to allow
sound type-checking.

For clarity, this section displays qualifier parameters using an idealized
syntax using double angle brackets, \code{\qp{...}}.
Note that this is not the actual
syntax you will use in source code, which is described in
Section~\ref{qualifier-parameters-syntax}.

In the qualifier parameter system, a class can declared to have one or more
qualifier parameters. For example, a qualifier parameter can be added to the
\code{Holder} class:

\begin{alltt}
    class Holder \qp{Q} \{

    \}
\end{alltt}

\noindent
This declares that \code{Holder} takes one qualifier parameter, named
\code{Q}.

\code{Q} can be referenced inside the \code{Holder} class. In the
following, \code{item} will have the same qualifier that \code{Holder} is
instantiated with:

\begin{alltt}
    class Holder \qp{Q} \{
        @Q String item;
    \}
\end{alltt}

References and instantiations of \code{Holder} specify a qualifier
argument for its parameter \code{Q}.

\begin{alltt}
    Holder\qp{Q=@Tainted} taintedHolder;
    Holder\qp{Q=@Untainted} untaintedHolder;
\end{alltt}

Qualifier parameters permit instantiating a class with the appropriate type
qualifier rather than relying on an overly-general declaration.  Therefore,
the following code type-checks without casts:

\begin{alltt}
    Holder\qp{Q=@Tainted} taintedHolder = new Holder\qp{Q=@Tainted}();
    @Tainted String s = holder.item;

    Holder\qp{Q=@Untainted} untaintedHolder = new Holder\qp{Q=@Untainted}();
    @Untainted String s = holder.item;
\end{alltt}

Like generics, two classes with different
qualifier parameters have no subtyping relationship:

\begin{alltt}
    taintedHolder = untaintedHolder;     // Error: not a subtype
    untaintedHolder = taintedHolder;     // Error: not a subtype
    Holder\qp{Q=@Tainted} taintedHolder2;
    taintedHolder = taintedHolder2;      // OK:  the qualifier argument is the same for both
\end{alltt}



\subsection{Qualifier parameter wildcards\label{qualifier-parameters-wildcards}}

As with Java generics, wildcard extends and super bounds may
be used. Wildcards create a subtyping relationship between classes with
qualifier parameters. See the Java tutorial at
\url{http://docs.oracle.com/javase/tutorial/java/generics/subtyping.html}
for more information on subtyping relationships with wildcards.

\begin{alltt}
    Holder\qp{Q=@Tainted} holder;
    Holder\qp{Q=? extends @Tainted} holderExtends;
    Holder\qp{Q=? super @Tainted} holderSuper;

    holder = holderExtends;    // Error: not a subtype
    holderExtends = holder;    // OK

    holder = holderSuper;    // Error: not a subtype
    holderSuper = holder;    // OK
\end{alltt}

For soundness, when a class is parameterized with a
wildcard, members of a qualified class that use the parameter as their type
have restrictions on their use, just as in Java.
In particular, a member of a qualified class with an extends-bounded wildcard
may only be set to \code{null}. A member of a qualified class with a
super-bounded wildcard will always have the top type when accessed.

\begin{alltt}
    Holder\qp{Q=? extends @Untainted} holderExtends;
    @Untainted String s1 = holderExtends.item;  // OK
    holderExtends.item = getTaintedString();    // Error: only null can be assigned to item

    Holder\qp{Q=? super @Untainted} holderSuper;
    @Untainted String s2 = holderSuper.item;    // Error: item has the top type
    holderSuper.item = getUntaintedString();    // OK
\end{alltt}

\subsection{Syntax of qualifier parameters\label{qualifier-parameters-syntax}}

The examples in
Sections~\ref{qualifier-parameters-overview}--\ref{qualifier-parameters-wildcards}
used double angle brackets, \code{\qp{...}}, for qualifier
parameter declarations and qualifier arguments.
In real source code, qualifier parameter declarations and uses, and qualifier
arguments, are specified via Java annotations.

\begin{itemize}
\item
To declare a qualifier parameter, use \<@Class\emph{Typesystem}Param> or
\<@Method\emph{Typesystem}Param> and give a name for the parameter, as in
\<@ClassTaintingParam("main")>.
\item
To use a qualifier parameter, write \<@Var> and indicate the parameter
being used, as in \<@Var(arg="main")>.
\item
To supply a qualifier argument,
write the argument annotation (e.g., \<@Tainted>),
but supply a \<param> argument, as in \<@Tainted("main")> which means that
\<@Tainted> is the argument to the parameter named \<main>.
\end{itemize}

These annotations are summarized in
Figure~\ref{fig-qualifier-parameter-syntax}
and are more fully explained below.

Each type system that supports qualifier parameters has its own copy of
these annotations. The functionality of the annotations is the same, but since
a java file might be annotated with annotations for multiple type systems, i.e.
have annotations for both the Regex and the Tainting checker, there must be a
different copy of each annotation so that the Checker Framework can determine
the checker that an annotation belongs to.

\begin{figure}
\begin{smaller}
%BEGIN LATEX
\setlength{\tabcolsep}{.5\tabcolsep}
\begin{smaller}
\begin{smaller}
%END LATEX
\begin{tabular}{|l|c|c|c|c|} \hline
                        & Generic Equivalent & Idealized Syntax
                        & Actual Syntax \\ \hline

  Declare a class parameter
  &
  \code{class Holder<T> \{\} }
  &
  \code{class Holder\qp{Q} \{\} }
  &
  \code{@ClassTaintingParam("Q") class Holder \{\}}
  \\ \hline

  Declare a method parameter
  &
  \code{<T> void do() \{\} }
  &
  \code{\qp{V} void do() \{\} }
  &
  \code{@MethodTaintingParam("V") void do() \{\}}
  \\ \hline

  Instantiate (supply an argument)
  &
  \code{Holder<String>}
  &
  \code{Holder\qp{Q=@Tainted}}
  &
  \code{@Tainted(param="Q") Holder}
  \\ \hline

  Use a parameter
  &
  \code{<T> void do(T t) \{\} }
  &
  \code{\qp{V} void do(@V Object o) \{\} }
  &
  \code{@MethodTaintingParam("V") void do(@Var(arg="V") Object o) \{\}}
  \\ \hline

  Use a parameter as an argument
  &
  \code{<T> void do(List<T> t) \{\} }
  &
  \code{\qp{V} void do(Holder\qp{Q=@V} h) \{\} }
  &
  \code{@MethodTaintingParam("V") void do(@Var(arg="V" param="Q") Holder o) \{\}}
  \\ \hline

  Instantiate without constraints
  &
  \code{Holder<?>}
  &
  \code{Holder\qp{Q=?}}
  &
  \code{@Wild(param="Q") Holder}
  \\ \hline

  Instantiate with upper bound
  &
  \code{Holder<?\ extends Object>}
  &
  \code{Holder\qp{Q=?\ extends @Tainted}}
  &
  \code{@Tainted(param="Q", wildcard=Wildcard.EXTENDS) Holder}
  \\ \hline

  Instantiate with lower bound
  &
  \code{Holder<?\ super Object>}
  &
  \code{Holder\qp{Q=?\ super @Tainted}}
  &
  \code{@Tainted(param="Q", wildcard=Wildcard.SUPER) Holder}
  \\ \hline

\end{tabular}
%BEGIN LATEX
\end{smaller}
\end{smaller}
%END LATEX
\end{smaller}
\caption{Comparison of the syntax of Java generics, the idealized syntax
  used in
  Sections~\ref{qualifier-parameters-overview}--\ref{qualifier-parameters-wildcards},
  and the actual syntax used in Java source code.
}
\label{fig-qualifier-parameter-syntax}
\end{figure}


\begin{description}
\item[\refqualclass{checker/tainting/qual}{ClassTaintingParam}]
Declares a qualifier parameter for a class.

\begin{alltt}

  // Equivalent to
  class Holder \qp{Q} \{

  \}

  // Declare a parameter "main"
  @ClassTaintingParam("main")
  class Holder \{

  \}

  // The parameter "main" can now be set
  @Tainted(param="main") Holder h;

\end{alltt}

\item[\refqualclass{checker/tainting/qual}{MethodTaintingParam}]
Declares a qualifier parameter for a method.

Qualifier arguments to a method are never specified explicitly; they are
inferred by the Checker Framework based on the parameters passed to the method
invocation. Unlike Java generics, there is no way to explicitly specify
method qualifier parameters on an invocation.

\begin{alltt}

  class Util \{

    // Declare a method parameter.
    @MethodTaintingParam("meth")
    public static @Var("meth") String id(@Var("meth") String in) \{
        return in;
    \}
  \}

  // Qualifier arguments are inferred.
  @Untainted String untainted = Util.id(getUntaintedString());

\end{alltt}

\item[\refqualclass{checker/tainting/qual}{Var}] Declares a use
of a qualifier parameter. The \code{arg} field
specifies which qualifier parameter in the surrounding scope the type should
get its value from. For example:

\begin{alltt}

  // Equivalent to
  class Holder \qp{Q} \{
    @Q String item;
  \}

  // Declare a parameter
  @ClassTaintingParam ("main")
  class Holder \{
    // item will have the qualifier that Holder is instantiated with
    @Var(arg="main") String item;
  \}

  @Tainted(param="main") Holder h1 = new @Tainted(param="main") Holder();
  @Tainted String value1 = h1.item;

  @Untainted(param="main") Holder h2 = new @Untainted(param="main") Holder();
  @Untainted String value1 = h2.item;

\end{alltt}

The \code{"param"} field specifies that the value of the
qualifier parameter specified by \code{"arg"} should be used as the parameter
to another qualifier type. For example:

\begin{alltt}

  // Equivalent to
  class Holder \qp{Q} \{
    @Q String item;
    Holder\qp{Q=@Q} nestedHolder;
  \}

  @ClassTaintingParam ("main")
  class Holder \{
    // item will have the qualifier that Holder is instantiated with
    @Var(arg="main") String item;

    // nestedHolder will be instantiated with the same qualifier as the
    // enclosing "main" parameter
    @Var(arg="main", param="main") Holder nestedHolder;
  \}

  @Tainted(param="main") Holder h1 = new @Tainted(param="main") Holder();
  @Tainted(param="main") Holder nestedHolder = h1;
  @Tainted String value1 = h1.nestedHolder.item;

  @Untainted(param="main") Holder h2 = new @Untainted(param="main") Holder();
  @Untainted(param="main") Holder nestedHolder2 = h2;
  @Untainted String value1 = h2.nestedHolder.item;

\end{alltt}

\item[\refqualclass{checker/tainting/qual}{Tainted}]
When the \code{param} field is not set, this annotation behaves as described in
Chapter~\ref{tainting-checker} and indicates that the value is tainted.
For example:

\begin{alltt}
  // The value should be considered tainted
  @Tainted String tainted  = getTaintedString();
\end{alltt}

When the \code{param} param field is set, the annotation indicates that the
value of the \code{@Tainted} qualifier should be used as the qualifier
argument to the class that it annotates. For example:

\begin{alltt}

  // Equivalent to Holder\qp{@Tainted} holder

  // This declares a Holder object, whose Tainting qualifier parameter is set to @Tainted.
  // Holder must have been declared to have a Tainting qualifier parameter
  // by using the @ClassTaintingParam annotation.
  @Tainted(param="main") Holder holder;
\end{alltt}

The \code{wildcard} field can be set to a
\refclass{qualframework/poly/qual}{Wildcard} value. This allows qualifier
parameters to act like wildcards.

\begin{alltt}

  // Equivalent to Holder\qp{? extends @Untainted}

  // Instantiate Holder with a wildcard parameter.
  @Untainted(param="main", wildcard=Wildcard.EXTENDS) Holder extends;

  // OK because of the extends bound
  extendsHolder = new @Untainted(param="main") Holder();
  // Error: the new Holder is not a subtype of extendsHolder
  extendsHolder = new @Untainted(param="main") Holder();

\end{alltt}

\item[\refqualclass{checker/tainting/qual}{Untainted}]
\code{@Untainted} behaves the same as \code{@Tainted} but for untainted values.

\item[\refqualclass{checker/tainting/qual}{Wild}] Declares
that a class has an unknown qualifier parameter. This is useful in cases
where the qualifier parameter in the class is not used or is used in very
limited ways.

\begin{alltt}

  // Equivalent to
  Holder\qp{?} h1 = new Holder\qp{@Untainted}();

  @Wild(param="main") Holder h1 = new @Untainted(param="main") Holder;

  // Error: item is not guaranteed to be an @Untainted value.
  @Untainted String s1 = h1.item;

\end{alltt}

\item[\refqualclass{checker/tainting/qual}{PolyTainted}]
Enables method qualifier polymorphism. When the field \code{param} is not set,
\code{@PolyTainted} behaves as described
Section~\ref{qualifier-polymorphism}. For example:

\begin{alltt}

  class Util \{
    static @PolyTainted String id(@PolyTainted String in) \{
        return in;
    \}
  \}

  @Untainted String s = Util.id(getUntaintedString());  // OK
\end{alltt}

The field \code{param} can be used to specify that the inferred qualifier
parameter should be used as an argument to another parameterized type. In
this mode \code{@PolyTainted} is a shorthand for a combination of
\code{@MethodTaintingParam} and \code{@Var}. For example:

\begin{alltt}

  class Util \{
    static @PolyTainted(param="main") Holder id(@PolyTainted(param="main") Holder in) \{
        return in;
    \}
  \}

  // Equivalent to this code
  @MethodTaintingParam("meth")
  public static @Var(arg="meth", param="main") Holder id(@Var(arg="meth", param="main) Holder in) \{
      return in;
  \}

\end{alltt}
\end{description}


\subsection{Primary qualifiers\label{primary-qualifiers}}


Type system specific annotations, like \code{@Tainted} or \code{@Regex}, have
dual uses in the qualifier parameter system. When their \code{"param"} field
is set, they are used as a argument to a qualifier parameter.

When their \code{"param"} field
is not set, they apply directly to a type and not to any qualifier
parameters of the type. We call the qualifier that applies directly to a
type the primary qualifier. For example an \code{@Tainted String}
is a String with a tainted value and its primary qualifier is \code{@Tainted}.

\code{@Var} can also be used to set primary qualifiers by omitting the
\code{"param"} field on the annotation.


% LocalWords:  nullable MyList nble nn Nullness DefaultQualifier MyClass quals
% LocalWords:  DefaultLocation subtype's ImmutableList ListIterator nullness
% LocalWords:  PolymorphicQualifier PolyNull java lub invariantly supertype's
% LocalWords:  MyList1 MyList2 MyList4 MyList3 MyClass2 toUpperCase elt
% LocalWords:  PolyAll arrays' Xlint rawtypes AignoreRawTypeArguments s1
% LocalWords:  call's Regex taintedHolder untaintedHolder taintedHolder2
% LocalWords:  wildcards holderExtends holderSuper getTaintedString s2 JLS
% LocalWords:  getUntaintedString Typesystem Param ClassTaintingParam h1
% LocalWords:  arg param MethodTaintingParam Util meth value1 h2 TopType
% LocalWords:  nestedHolder nestedHolder2 extendsHolder PolyTainted
%%  LocalWords:  BottomType CharSequence SomeType OtherType MyList1a
%%  LocalWords:  MyList2a
