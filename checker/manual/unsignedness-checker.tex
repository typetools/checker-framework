\htmlhr
\chapter{Unsignedness Checker\label{unsignedness-checker}}

The Unsignedness Checker guarantees that signed and unsigned values are not mixed 
together in a computation. In addition, it prohibits meaningless operations, such 
as division on an unsigned value.

\section{Annotations\label{unsignedness-checker-annotations}}

The Unsignedness Checker uses type annotations to indicate the signedness that the programmer intends an expression to have.

\begin{figure}
\includeimage{unsignedness}{3.5cm}
\caption{The type qualifier hierarchy of the Unsignedness annotations.
Qualifiers in gray are used internally by the type system but should never be written by a programmer.}
\label{fig-unsignedness-hierarchy}
\end{figure}

These are the qualifiers in the Unsignedness type system:

\begin{description}

\item[\refqualclass{checker/unsignedness/qual}{Unsigned}]
    indicates that the programmer intends the annotated value to be
    interpreted as unsigned.
    That is, if the most significant bit in the bitwise representation is
    set, then the bits should be interpreted as a large positive value.

\item[\refqualclass{checker/unsignedness/qual}{Signed}]
    indicates that the programmer intends the annotated value to be
    interpreted as signed.
    That is, if the most significant bit in the bitwise representation is
    set, then the bits should be interpreted as a negative value.
    This is the default annotation.

\item[\refqualclass{checker/unsignedness/qual}{Constant}]
    indicates that a value is a compile-time constant and could be
    interpreted as unsigned or signed. This is used internally, and should not 
    be written by the programmer.

\item[\refqualclass{checker/unsignedness/qual}{UnknownSignedness}]
    indicates that a value's type is not relevant or known to this checker. 
    This annotation is used internally, and should not be
    written by the programmer.

\end{description}

Unsignedness is primarily about how the bits of the representation are
interpreted, not about the values that it can represent.  An unsigned value
is always positive, but just because a variable's value is positive does
not mean that it should be marked as \<@Unsigned>.  If variable $v$ will be
compared to, or used in arithmetic operations with, a signed value, then
$v$ should have signed type.


\subsection{Default Qualifiers\label{unsignedness-checker-annotations-default-qualifiers}}

The only type qualifier that the programmer should need to write is
\code{@Unsigned}. When a programmer leaves an expression unannotated, the
Unsignedness Checker treats it in one of the following ways:

\begin{itemize}

    \item
    All \code{byte}, \code{short}, \code{int}, and \code{long} literals default
    to \refqualclass{checker/unsignedness/qual}{Constant}.
    \item
    All \code{byte}, \code{short}, \code{int}, and \code{long} variables default
    to \refqualclass{checker/unsignedness/qual}{Signed}.
    \item
    All other expressions default to \refqualclass{checker/unsignedness/qual}{UnknownSignedness}.

\end{itemize}

\section{Prohibited Operations\label{unsignedness-checker-Prohibited-Operations}}

The Unsignedness Checker prohibits the following uses of operators:

\begin{itemize}

    \item   
    Division ( \code{/} ) or modulus ( \code{\%} ) with an \code{@Unsigned}
    operand.
    \item   
    Signed right shift ( \verb|>>| ) with an \code{@Unsigned} left operand.
    \item   
    Unsigned right shift ( \verb|>>>| ) with a \code{@Signed} left operand.
    \item   
    Any other binary operator with one \code{@Unsigned} operand and one
    \code{@Signed} operand, with the exception of left shift ( \verb|<<| ).

\end{itemize}

There are also occasions when comparisons can be rendered illegitimate for
unsigned interpretations. For this reason, the Unsignedness Checker will prohibit the following uses of comparators:

\begin{itemize}

    \item   
    Greater/less than (or equal) comparators
    ( \code{<}, \code{<=}, \code{>}, \code{>=} ) with an \code{@Unsigned}
    operand.
    \item   
    Equals ( \code{==} ) and not equals ( \code{!=} ) with one \code{@Unsigned}
    operand and one \code{@Signed} operand.

\end{itemize}

The Unsignedness Checker also ensures that assignments and pseudo-assignments are
correct. For example, it is unsound to assign a \code{@Signed} expression to an
\code{@Unsigned} variable.

\section{Rationale\label{unsignedness-checker-rationale}}

The intent of the Unsignedness Checker is to prevent the misuse of unsigned
values in Java code.  Most Java operations interpret operands as signed,
rendering those operations unsound for unsigned values. A program should not use
unsigned values with such operations, because the operation would interpret a
large unsigned integer as negative, producing an undesired outcome.

Consider the following Java code:

\begin{Verbatim}
    int s1 = -1;
    int s2 = -2;

    @Unsigned int u1 = 0xFFFFFFFF;  // unsigned: 2^32 - 1, signed: -1
    @Unsigned int u2 = 0xFFFFFFFE;  // unsigned: 2^32 - 2, signed: -2

    int result;

    result = s2 / s1;   // OK: -2 / -1 is 2
    result = u2 / u1;   // ERROR: (2^32 - 1) / (2^32 - 2) should not be 2

    s1 = 0;
    s2 = 5;

    u1 = 0xFFFFFFFF;    // unsigned: 2^32 - 1, signed: -1
    u2 = 5;

    result = s1 % s2;   // OK: 0 % 5 is 0
    result = u1 % u2;   // ERROR: (2^32 - 1) % 5 should not be 4
\end{Verbatim}

These examples illustrate why any division or modulus with an unsigned operand 
is illegal. Many other uses of operators are prohibited for similar reasons.
