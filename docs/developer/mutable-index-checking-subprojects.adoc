# Ideas for limited scope project

## 1. First focus on a single collection

Checking properties involving multiple collections -- indices to multiple collections,
collections of the same length, etc., will be significantly more complex
than properties involving a single collection (such as IndexFor).
So let's focus on individual collections first, to limit the scope and make a base that can be built upon.

## 2. First focus on simple arithmetic

Code involving indices often contains simple arithmetic operations: `++i`, `i <= a.size()`,
which are well supported by the Index Checker.
Addressing complicated arithmetic, such as multiple dimensions, binary search, etc.,
will encounter limitations of the Checker Framework,
and likely produce lot of false positives without a powerful arithmetic solver.

## 3. Having more elements is fine

To check if an index is valid for a given collection, we don't need to worry if it has more elements than expected.
Adding to a collection does not invalidate any existing indices.
Therefore, for this point of view we don't need to distinguish code that can add to a collection from code that does not modify it.

## 4. Some collections only grow (= never shrink)

It is quite common to use a mutable-length collection and never remove elements from it.
For example, building up a collection by appending individual items, and after that using it in a read-only way.

As long as the collection never shrinks, the IndexFor annotations from the Index Checker will work soundly for it.

## 5. Removing elements is hard

On the other hand, removing elements can invalidate indices.
Distinguishing code that does not shrink a given collection from code that can,
brings in the whole problem of needing to reason about effects of methods and aliasing references,
which may end up in having to annotate a lot of code, inventing complicated annotations that will not cover all cases anyway, etc.

## 6. Checking that a collection is grow-only

For collections that only grow, we don't need to track what methods can mutate them,
as long as we ensure that no code ever removes from them.

We could make such collection with `@GrowOnly`, a qualifier that ensures the object can not shrink.
```java
@GrowOnly ArrayList<T> growOnlyList = new @GrowOnly ArrayList<T>();
```

On the other hand, collections that actually can shrink will be qualified Shrinkable.
Code that does not remove from a collection can accept both of these, with the qualifier `@CannotRemoveFrom`.

[%hardbreaks]
This leads to the following 4-qualifier hierarchy:
Bottom <: GrowOnly <: CannotRemoveFrom
Bottom <: Shrinkable <: CannotRemoveFrom

## 7. Limiting index checking to grow-only collections

Because checking indices for shrinkable collections is too hard,
we could limit the guarantees provided by the checker only to grow-only collections.
It would still be an improvement over the situation where indices for mutable-length collections are not checked at all.

The annotation UncheckedShrinkable would be used to opt out of index checking.
If a list is UncheckedShrinkable, then `@IndexFor(list)` would be equivalent to `@NonNegative`
-- the checker would basically assume that all indices are valid for this collection.

[%hardbreaks]
This annotation would fit into the hierarchy like this:
Bottom <: UncheckedShrinkable <: Shrinkable <: CannotRemoveFrom

## 8. Annotating the library

Checking indices of a mutable collection type (such as List) in the Java library would require annotating its methods:

* Methods that accept indices must have the parameters annotated `@IndexFor` or `@IndexOrHigh`. Missing annotation would create unsoundness.
* Methods that return indices should have the return type annotated `@IndexFor` or `@IndexOrHigh`. Missing annotation would cause false positives.
* Most methods do not remove from the collection -- the default qualifier for this type should be CannotRemoveFrom.
* Methods that can remove from the collection must use the Shrinkable annotation. Missing annotation would create unsoundness.
* Methods that allocate and return a new list could also use the Shrinkable annotation.

The annotations `@UncheckedShrinkable` and `@GrowOnly` should not be used for the library.

## 9. Annotating application code

In application code, each allocation of a list should be by default `@UncheckedShrinkable`.
If all lists are `@UncheckedShrinkable`, it would ideally result in no warnings reported.

Then, collections that are intended to be grow-only should be annotated `@GrowOnly`.
Now, the Index Checker starts providing value by checking that the accesses are not out of bounds.
Some types within the application might need to be annotated `@CannotRemoveFrom` to accept both kinds of collections.
nn
# Limited scope project proposal

- Focus on checking IndexFor annotations limited to grow-only collections.
- Implement the qualifier hierarchy (`@GrowOnly`, `@UncheckedShrinkable`, `@Shrinkable`, `@CannotRemoveFrom`).
- Annotate methods of `List` that remove elements with `@Shrinkable this`.
- Find if there are other methods in the Java library that may require `@Shrinkable`.
- Annotate methods of `List` that involve indices with `@IndexFor`/`@IndexOrHigh`.
- Enable checking IndexFor annotations for Lists, with the exception for `@UncheckedShrinkable`.
- For a case study, find a small application that uses `ArrayList` in a grow-only way.
  Start assuming that all collections are `@UncheckedShrinkable`.
  Continue by annotating allocation of collections with `@GrowOnly` where possible, and add annotations as necessary for checking.

# Ideas for advanced features

## 1. Conversion of unique references

If we know, by some means of alias tracking, that a reference to a collection is unique and used only in one place,
then it may be safely converted both ways between `@GrowOnly` and Shrinkable.
This allows to "freeze" and "unfreeze" the collection for a while.
That may be quite a common thing, so it could enable checking more code.
On the other hand, satisfying the necessary uniqueness conditions might be difficult.

## 2. Qualifier hierarchy for shrink-only

[%hardbreaks]
The above conversion could make useful a qualifier hierarchy that works in the opposite direction:
Bottom <: ShrinkOnly <: CannotAddTo
Bottom <: Growable <: CannotAddTo

[%hardbreaks]
Maybe not very useful in isolation, but common pairs of qualifiers from the two hierarchies can be:
MutableLength = Growable + Shrinkable
ImmutableLength = GrowOnly + ShrinkOnly
ConstLength = CannotAddTo + CannotRemoveFrom

That could enable reasoning about collections that need to maintain fixed length.

## 3. Same-length collections

By quickly looking at the Checker Framework source code,
it is quite common that one index variable is used for multiple collections of the same length.
The reason why this emerges is that if there is only one collection, using an index variable is not necessary, because the enhanced for loop can be used.
So this might be one of the next steps to consider.

[%hardbreaks]
If the collections are constructed with all the elements, then maintaining the following annotations should suffice to show that `@IndexFor(listA)` is also `@IndexFor(listB)`:
listA: `@ShrinkOnly`
listB: `@AtLeastSameLen(listA)` + `@GrowOnly`

To support collections that are created by adding elements to all of them in a loop,
the SameLen qualifier would need an offset that would be flow-sensitive and inferred.

## 4. Unified effect annotation

If it comes to defining method effect annotations, considering the above point "Having more elements is fine":
The methods add, remove, and non-mutating methods, can all use one annotation `@EnsuresRelativeMinLen(list, n)`,
with the meaning "sizeOfListOnReturn >= sizeOfListOnEntry + n".
Then we could have add: `@EnsuresRelativeMinLen(list, 1)`, get: `@EnsuresRelativeMinLen(list, 0)`, remove: `@EnsuresRelativeMinLen(list, -1)`.
An unrestricted method would -- implementation details aside -- be `@EnsuresRelativeMinLen(list, -infinity)`.

## 5. Simple checking of effects

Checking method effect annotation in general is hard, but a simple implementation might be able to cover a good number of cases:

* For code executed in sequence, sum together the n in the EnsuresRelativeMinLen of all called methods that can mutate the collection.
* For code executed conditionally, change `@EnsuresRelativeMinLen(list, n)` to `@EnsuresRelativeMinLen(list, 0)` if n > 0.
* For code executed in a loop, additionally change `@EnsuresRelativeMinLen(list, n)` to `@EnsuresRelativeMinLen(list, -infinity)` if n < 0.
* Consider using value range information about the loop bound, when it is available.
