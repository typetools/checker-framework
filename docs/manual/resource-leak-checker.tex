\htmlhr
\chapterAndLabel{Resource Leak Checker for must-call obligations}{resource-leak-checker}

The Resource Leak Checker guarantees that the program fulfills every object's
must-call obligations before it is de-allocated.

A resource leak occurs when a program does not explicitly dispose of some finite
resource, such as a socket, file descriptor, or database connection.  To dispose
of the resource, the program should call some method on an object.
(De-allocating or garbage-collecting the object is not sufficient.)  For
example, the program must call \<close()> on every object that implements the
interface \<java.io.Closeable>.

The Resource Leak Checker can check any property of the form ``the programmer
must call all methods \emph{M} on object \emph{O} before \emph{O} is
de-allocated''.  For resource leaks, by default \emph{M} is the set containing
\<close()> and \emph{O} is any object that implements the interface
\<java.io.Closeable>.  You can extend this guarantee to other types and methods
by writing \<@MustCall> or \<@InheritableMustCall> annotations, as described in
Section~\ref{must-call-annotations}.

The Resource Leak Checker works in three stages:
\begin{enumerate}
\item The Must Call Checker (\chapterpageref{must-call-checker})
  over-approximates each expression's must-call methods as a
  \refqualclass{checker/mustcall/qual}{MustCall} type.
\item The Called Methods Checker (\chapterpageref{called-methods-checker})
  under-approximates each expression's definitely-called methods as a
  \refqualclass{checker/calledmethods/qual}{CalledMethods} type.
\item When any program element goes out of scope (i.e., it is ready to be
  de-allocated), the Resource Leak Checker compares the types
  \<@MustCall(\emph{MC})> and \<@CalledMethods(\emph{CM})>.  It reports an error
  if there exists some method in \emph{MC} that is not in \emph{CM}.
\end{enumerate}


\sectionAndLabel{How to run the Resource Leak Checker}{resource-leak-run-checker}

\begin{Verbatim}
javac -processor ResourceLeak MyFile.java ...
\end{Verbatim}

The Resource Leak Checker supports the following optional command-line arguments,
in addition to those listed in Section~\ref{called-methods-run-checker} for
the Called Methods Checker:
\begin{itemize}
\item The \<-AnoLightweightOwnership> option disables ownership annotations,
  ignoring them in favor of the default ownership assumptions.
  See Section~\ref{resource-leak-ownership}.
\item The \<-AnoResourceAliasing> option disables resource alias support,
  treating \<@MustCallAlias> identically to \<@PolyMustCall>.
  See Section~\ref{resource-leak-resource-alias}.
\item The \<-AnoCreatesObligation> option disables obligation creation,
  instead issuing errors whenever a new obligation might be created.
  See Section~\ref{resource-leak-creates-obligation}.
\item The \<-AcountMustCall> option prints an estimate of the number of
  must-call obligations in the analyzed program.
\end{itemize}


\sectionAndLabel{Resource Leak Checker annotations}{resource-leak-annotations}

The Resource Leak Checker relies on the type qualifiers of its constituent checkers:
the Must Call Checker (Section~\ref{must-call-annotations}) and
the Called Methods Checker (Section~\ref{called-methods-spec}). You might need
to write qualifiers from either type hierarchy. The most common annotations from
these checkers that you might need to write are:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{MustCall}{String[] value}]
for example on an element with static type \<Object> that might contain a \<Socket>.

\item[\refqualclasswithparams{checker/mustcall/qual}{InheritableMustCall}{String[] value}]
on any classes defined in your program that have must-call obligations. See Section~\ref{must-call-on-class}.

\item[\refqualclass{checker/calledmethods/qual}{EnsuresCalledMethods}] on a method in
your code that fulfills a must-call obligation of one of its parameters or of a field.
See Section~\ref{called-methods-ensurescalledmethods}.

\end{description}

The Resource Leak Checker supports annotations that express common
aliasing patterns related to resource leaks:

\begin{description}

\item[\refqualclass{checker/mustcall/qual}{Owning}]
\item[\refqualclass{checker/mustcall/qual}{NotOwning}]
  expresses ownership.  When two aliases exist to the same Java object,
  \<@Owning> and \<@NotOwning> indicate which of the two is responsible for
  fulfilling must-call obligations.  For details, see
  Section~\ref{resource-leak-ownership}.

\item[\refqualclass{checker/mustcall/qual}{MustCallAlias}]
  represents a ``resource-aliasing'' relationship.  Resource aliases are
  distinct Java objects that nevertheless control the same resource(s):
  fulfilling the must-call obligations of one is equivalent to
  fulfills the obligations of the other.  For details,
  see Section~\ref{resource-leak-resource-alias}.

\end{description}

The Resource Leak Checker also supports an annotations to permit re-assigning
fields or re-opening resources:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{CreatesObligation}{String value}]
  is a declaration annotation that indicates that the annotated method ``resets'' the must-call
  obligations of some expression.  Multiple \<@CreatesObligation>
  annotations can be written on the same method.  For more details
  on obligation creation, see Section~\ref{resource-leak-creates-obligation}.

\end{description}


\sectionAndLabel{Aliased references and ownership transfer}{resource-leak-ownership}

Resource leak checking is complicated by aliasing: two or more Java
objects may refer to the same underlying resource, but each resource
actually only needs to be closed once.
For example, consider the following code that safely closes a \<Socket>:

\begin{verbatim}
  void example(String myHost, int myPort) {
    Socket s = new Socket(myHost, myPort);
    closeSocket(s);
  }
  void closeSocket(@Owning @MustCall("close") Socket t) {
    t.close();
  }
\end{verbatim}

There are two aliases for a socket object: \<s> in \<example()> and \<t> in
\<closeSocket()>.  Ordinarily, the Resource Leak Checker requires that
\<close()> is called on every expression of type \<Socket>, but that is not
necessary here.  In particular, the Resource Leak Checker should not warn when
\<s> goes out of scope in \<example()>, because \<closeSocket()> takes ownership
of the socket --- that is, \<closeSocket()> takes responsibility for closing
it. The \<@Owning> annotation on \<t>'s declaration expresses this fact; it
tells the Resource Leak Checker that \<t> is the reference that ought to be
checked, and that \<s> can be safely ignored.

Constructor returns are always \<@Owning>.
Method returns default to \<@Owning>,
and for unannotated parameters and fields is \<@NotOwning>. This treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library will be tracked by default, and the checker
never assumes that passing an object to an unannotated library will satisfy its obligations.

\<@Owning> and \<@NotOwning> always \emph{transfer} must-call obligations: must-call
obligations are conserved (i.e. neither created nor destroyed) by any ownership annotations
that you write, by construction. Writing \<@Owning> or \<@NotOwning> can never make the checker
unsound (i.e. a real warning can never be hidden by them),
but writing (or failing to write) these annotations can introduce false positives (i.e. extra warnings).

The features described in this section can be disabled by passing the \<-AnoLightweightOwnership>
command-line parameter to the Resource Leak Checker.
In this mode, the defaults described in the previous paragraph are always used, and explicit \<@Owning>
and \<@NotOwning> annotations are ignored.


\subsectionAndLabel{Owning fields}{resource-leak-owning-fields}

Unannotated fields are treated as non-owning.

The Resource Leak Checker treats all static fields as non-owning, meaning that no assignment to one
can satisfy a must-call obligation.

Additional class-level checking is required for \<@Owning>
fields, as the code
satisfying their must-call obligations nearly always spans multiple
procedures.

For final, non-static owning fields,
the Resource Leak Checker enforces the ``resource acquisition is
initialization (RAII)'' programming idiom.  Some
``destructor''-like method \<d()> must satisfy the field's must-call obligation
(and this fact must be expressed via a corresponding \<@EnsuresCalledMethods> annotation),
and the enclosing class must have a \<@MustCall("d")> obligation to
ensure the destructor is called.

Non-final, non-static owning fields usually require one or more \<@CreatesObligation> annotations
when they might be re-assigned. See Section~\ref{resource-leak-non-final-fields} for
more details on how to annotate a non-final, non-static owning field.


\sectionAndLabel{Resource aliasing}{resource-leak-resource-alias}

A \emph{resource alias} set is a set of Java objects that
correspond to the same underlying system resource,
even though they may have different Java types.
Calling a must-call method on any member of a resource-alias set
fulfills that obligation for all members of the set.

Programmers most often encounter resource alaising when using \emph{wrapper types}.
For example, the Java \<BufferedOutputStream> wrapper adds buffering to a
delegate stream.
The wrapper's \<close()> method invokes \<close()> on the delegate.  Calling
\<close()> on either object has the same effect:  it closes the underlying resource.

A resource aliasing relationship is expressed in source code via a pair of \<@MustCallAlias> annotations:
one on a parameter of a method or constructor, and another on its return type.
For example, one constructor of \<BufferedOutputStream> has these annotations in
the annotated JDK:
\begin{Verbatim}
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream out);
\end{Verbatim}

When a pair of \<@MustCallAlias> annotations is written on a method or constructor \<m>'s return type
and its parameter \<p>, the Resource Leak Checker requires one of the following:
\begin{enumerate}
\item \<p> is passed to another method or constructor (including \<super>) in a
  \<@MustCallAlias> position, and \<m> returns that method's result, or
\item \<p> is stored in an \<@Owning> field of the enclosing class.
\end{enumerate}

Support for \<@MustCallAlias> can be disabled by passing the \<-AnoResourceAliases> command-line
argument to the checker. In this mode, resource-alias sets are not tracked by the checker,
and \<@MustCallAlias> is treated identically to \<@PolyMustCall>.


\sectionAndLabel{Creating obligations}{resource-leak-creates-obligation}

In a class that has must-call obligations,
every constructor implicitly creates obligations for the newly-created object.
However, non-constructor methods may also create obligations
when re-assigning non-final, owning fields or allocating
new system-level resources.

A post-condition annotation,
\<@CreatesObligation>,
indicates for which expression an obligation is created.
If you write \<@CreatesObligation(>\emph{T}\<)> on a method \emph{M} that
overrides a method \emph{N}, then \emph{N} must also be annotated as
\<@CreatesObligation(>\emph{T}\<)>.  (\emph{N} may also have other
\<@CreatesObligation> annotations that \emph{M} does not.)
If you write \<@CreatesObligation> on a method that does not actually
create an obligation, the checker may issue false positive warnings at calls to
that method, but it never causes
missed warnings (i.e., the checker is sound).

At a call site to a method annotated as
\<@CreatesObligation(>\emph{expr}<)>, the Resource Leak Checker
\begin{enumerate}
\item
  treats any existing \<@MustCall> obligations of \emph{expr} as \emph{satisfied},
\item
  creates a fresh obligation to check, as if \emph{expr} was a newly-allocated local
  variable.
\item
  Requires that the expression corresponding to \emph{expr} (that is, \emph{expr}
  viewpoint-adapted to the method call site) is owning.  Otherwise, the checker
  will issue a \<reset.not.owning> error at the call-site. You can avoid this
  error by extracting the relevant expression into a new local variable (because
  locals are \<@Owning> by default).
\end{enumerate}

Treating the obligation before the call as satisfied is sound: the
checker creates a new obligation for calls to \<@CreatesObligation> methods,
and the Must Call Checker (\chapterpageref{must-call-checker}) ensures the
\<@MustCall> type for the target will have a \emph{superset} of any methods
present before the call. Intuitively, calling an \<@CreatesObligation> method
"resets" the obligations of the target, so whether they were satisfied before
the call or not is irrelevant.

If an \<@CreatesObligation>
method is invoked within a method that has an \<@CreatesObligation> annotation
with the same target---imposing the obligation on its caller---then
the newly-created obligation is treated as satisfied immediately (because it is instead imposed
on the callee of the method being checked).

Support for \<@CreatesObligation> can be disabled by passing the \<-AnoCreatesObligation> command-line
argument to the checker. In this mode, \<@CreatesObligation> annotations on methods are ignored at call-sites,
and re-assigning a non-final, owning field is always an error.


\subsectionAndLabel{Re-assigning to non-final, owning fields}{resource-leak-non-final-fields}

\<@CreatesObligation> allows the Resource Leak Checker to verify uses of non-final fields
that contain a resource, even if they are re-assigned. Consider
the following example:

\begin{verbatim}
  @MustCall("close") // default qualifier for uses of SocketContainer
  class SocketContainer {
    private @Owning Socket sock;

    public SocketContainer() { sock = ...; }

    void close() { sock.close() };

    @CreatesObligation("this")
    void reconnect() {
      if (!sock.isClosed()) {
        sock.close();
      }
      sock = ...;
    }
  }
\end{verbatim}

In the lifetime of a \<SocketContainer> object, \<sock>
might be re-assigned arbitrarily many times: once at each
call to \<reconnect()>. This code is safe, however: \<reconnect()>
ensures that \<sock> is closed before re-assigning it.

The Resource Leak Checker enforces two rules to ensure that
re-assignments to non-final, owning fields like \<sock> in the example
above are sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with a \<@CreatesObligation> annotation
  that targets that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$,
  its inferred \<@MustCall> obligation must be contained in its \<@CalledMethods>
  type at the program point before $s$.
\end{itemize}
\noindent
The first rule ensures that \<close()> is called after the last call
to \<reconnect()>, and the second rule ensures that \<reconnect()>
safely closes \<sock> before re-assigning it. Because the Called Methods Checker
treats calls to an \<@CreatesObligation> method like \<reconnect()> as if the call might
cause arbitrary side-effects, after such a call the only method known to have been
definitely called is the \<@CreatesObligation> method: previous calls
(including e.g. to \<close()>) are discarded.

% TODO: should this section also include text about unconnected sockets, or is what's here sufficient?

% LocalWords:  de subchecker OutputStream MustCall MustCallUnknown
% LocalWords:  PolyMustCall InheritableMustCall MultiRandSelector
% LocalWords:  Partitioner
