\htmlhr
\chapter{How to create a new checker\label{creating-a-checker}}
\label{writing-a-checker} % for old links; don't use any more!

\newcommand{\TreeAPIBase}{https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source}
\newcommand{\refTreeclass}[2]{\href{\TreeAPIBase{}/#1/#2.html?is-external=true}{\<#2>}}
\newcommand{\ModelAPIBase}{http://docs.oracle.com/javase/8/docs/api/javax/lang/model}
\newcommand{\refModelclass}[2]{\href{\ModelAPIBase{}/#1/#2.html?is-external=true}{\<#2>}}

This chapter describes how to create a checker
--- a type-checking compiler plugin that detects bugs or verifies their
absence.  After a programmer annotates a program,
the checker plugin verifies that the code is consistent
with the annotations.
If you only want to \emph{use} a checker, you do not need to read this
chapter.


Writing a simple checker is easy!  For example, here is a complete, useful
type-checker:

\begin{Verbatim}
@SubtypeOf(Unqualified.class)
@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
public @interface Encrypted {}
\end{Verbatim}

This checker is so short because it builds on the Subtyping Checker
(Chapter~\ref{subtyping-checker}).
See Section~\ref{subtyping-example} for more details about this particular checker.
When you wish to create a new checker, it is often easiest to begin by
building it declaratively on top of the Subtyping Checker, and then return to
this chapter when you need more expressiveness or power than the Subtyping
Checker affords.

You can also create your own checker by customizing a different existing
checker.  Specific checkers that are designed for extension include
the Subtyping Checker (\chapterpageref{subtyping-checker}),
the Fake Enumeration Checker (\chapterpageref{fenum-checker}),
the Units Checker (\chapterpageref{units-checker}),
 and a typestate checker (\chapterpageref{typestate-checker}).
Or, you can copy and then modify a different existing checker --- whether
one distributed with the Checker Framework or a third-party one.
(One good choice to copy and modify is the Regex Checker
(\chapterpageref{regex-checker}); a bad choice is the Nullness Checker,
which is more sophisticated than anything you want to start out building.)

\begin{sloppypar}
You can place your checker's source files wherever you like.  When you
compile your checker, \<\$CHECKERFRAMEWORK/framework/dist/framework.jar> and \<\$CHECKERFRAMEWORK/framework/dist/javac.jar>
should be on your classpath.  (If you wish to modify an existing checker in place,
or to place the source code for your new checker in your own private copy of the
Checker Framework source code, then you need to be able to re-compile the
Checker Framework, as described in Section~\ref{build-source}.)
\end{sloppypar}

The rest of this chapter contains many details for people who want to write more powerful
checkers.
You do not need all of the details, at least at first.
In addition to reading this chapter of the manual, you may find it helpful
to examine the implementations of the checkers that are distributed with
the Checker Framework.  You can even create your checker by modifying one
of those.
The Javadoc documentation of the framework and the checkers is in the
distribution and is also available online at
\myurl{https://checkerframework.org/api/}.

If you write a new checker and wish to advertise it to the world, let us
know so we can mention it in the Checker Framework Manual, link to
it from the webpages, or include it in the Checker Framework distribution.
For examples, see \chapterpageref{third-party-checkers}.


\section{How checkers build on the Checker Framework\label{creating-tool-relationships}}

This table shows the relationship among tools that the Checker Framework
builds on or that are built on the Checker Framework.
All of the tools support the Java 8 type annotation syntax.
You use the Checker Framework to build pluggable type systems, and the
Annotation File Utilities to manipulate \code{.java} and \code{.class} files.

\newlength{\bw}
\setlength{\bw}{.5in}

%% Strictly speaking, "Subtyping Checker" should sit on top of Checker
%% Framework and below all the specific checkers.  But omit it for simplicity.

% Unfortunately, Hevea inserts a horizontal line between every pair of rows
% regardless of whether there is a \hline or \cline.  So, make paragraphs.
\begin{center}
\begin{tabular}{|p{\bw}|p{\bw}|p{\bw}|p{\bw}|p{.4\bw}|p{\bw}|p{1.5\bw}|p{1\bw}|}
\cline{1-4} \cline{6-6}
\centering Subtyping \par Checker &
\centering Nullness \par Checker &
\centering Mutation \par Checker &
\centering Tainting \par Checker &
\centering \ldots &
\centering Your \par Checker &
\multicolumn{2}{c}{}
\\ \hline
\multicolumn{6}{|p{6\bw}|}{\centering Base Checker \par (enforces subtyping rules)} &
\centering Type \par inference &
% Adding "\centering" here causes a LaTeX alignment error
Other \par tools
\\ \hline
\multicolumn{6}{|p{6\bw}|}{\centering Checker Framework \par (enables creation of pluggable type-checkers)} &
\multicolumn{2}{p{3\bw}|}{\centering \href{https://checkerframework.org/annotation-file-utilities/}{Annotation File Utilities} \par (\code{.java} $\leftrightarrow$ \code{.class} files)}
\\ \hline
\multicolumn{8}{|p{8.5\bw}|}{\centering
  \href{https://checkerframework.org/jsr308/}{Type Annotations} syntax
  and classfile format (``JSR 308'') \par \centering (no built-in semantics)} \\ \hline
\end{tabular}
\end{center}


The Base Checker
(more precisely, the \refclass{common/basetype}{BaseTypeChecker})
enforces the standard subtyping rules on extended types.
The Subtyping Checker is a simple use of the Base Checker that supports
providing type qualifiers on the command line.
You usually want to build your checker on the Base Checker.


\section{The parts of a checker\label{creating-parts-of-a-checker}}

The Checker Framework provides abstract base classes (default
implementations), and a specific checker overrides as little or as much of
the default implementations as necessary.
%
Sections~\ref{creating-typequals}--\ref{creating-compiler-interface} describe
the components of a type system as written using the Checker Framework:

\begin{description}

\item{\ref{creating-typequals}}
  \textbf{Type qualifiers and hierarchy.}  You define the annotations for
  the type system and the subtyping relationships among qualified types
  (for instance, that \<@NonNull Object> is a subtype of \<@Nullable
  Object>).

\item{\ref{creating-extending-visitor}}
  \textbf{Type rules.}  You specify the type system semantics (type
  rules), violation of which yields a type error.  There are two types of
  rules.
\begin{itemize}
\item
  Subtyping rules related to the type hierarchy, such as that every
  assignment and pseudo-assignment satisfies a subtyping relationship.
  Your checker automatically inherits these subtyping rules from the Base
  Checker (Chapter~\ref{subtyping-checker}), so there is nothing for you to do.
\item
  Additional rules that are specific to your particular checker.  For
  example, in the Nullness type system, only references with a
  \refqualclass{checker/nullness/qual}{NonNull} type may be dereferenced.  You
  write these additional rules yourself.
\end{itemize}

\item{\ref{creating-type-introduction}}
  \textbf{Type introduction rules.}  For some types and
  expressions, a qualifier should be treated as implicitly present even if a
  programmer did not explicitly write it.  For example, in the Nullness
  type system every literal
  other than \<null> has a \refqualclass{checker/nullness/qual}{NonNull} type;
  examples of literals include \code{"some string"} and \<java.util.Date.class>.

\item{\ref{creating-dataflow}}
  \textbf{Dataflow rules.}  These optional rules enhance flow-sensitive
  type qualifier inference (local variable type inference).

\item{\ref{creating-compiler-interface}}
  \textbf{Interface to the compiler.}  The compiler interface indicates
  which annotations are part of the type system, which command-line options
  and \<@SuppressWarnings> annotations the checker recognizes, etc.
\end{description}


\subsection{Tips for creating a checker\label{creating-tips}}

To make your job easier, we recommend that you build your type-checker
incrementally, testing at each phase rather than trying to build the whole
thing at once.

Here is an example of one good way to proceed.

\begin{enumerate}
\item
  Before you start coding, first write the user manual, which explains the
  type system, what it guarantees, how to use it, etc., from the point of
  view of a user.
  This will help you flesh out your goals and the concepts, which are
  easier to understand and change in text than in an implementation.
  Section~\ref{creating-documenting-a-checker} gives a suggested structure for the
  manual chapter, which will help you avoid omitting any parts.

  Once you have designed and documented the parts of your type system, you
  may also want to choose some case studies and play computer to ensure
  that they give the expected results.  During manual checking, ask
  yourself what reasoning you applied, what information you needed, and
  whether your written-down rules were sufficient.

\item
  Implement the type qualifiers and hierarchy
  (Section~\ref{creating-typequals}).

  Write simple test cases to test your type hierarchy.  For instance, if
  your type hierarchy consists of a supertype \<@UnknownSign> and a subtype
  \<@NonNegative>, then you could write a test case such as:

\begin{Verbatim}
  void foo(@UnknownSign int us, @NonNegative int nn) {
    @UnknownSign int a = us;
    @UnknownSign int b = nn;
    @NonNegative int c = us;  // expected error on this line
    @NonNegative int d = nn;
  }
\end{Verbatim}

  Type-check these test files using the Subtyping Checker
  (\chapterpageref{subtyping-checker}).

\item
  Write the checker class itself
  (Section~\ref{creating-compiler-interface}).
  Ensure that you can still type-check your test files and that the results
  are the same.

\item
  Implement type rules, if any (Section~\ref{creating-extending-visitor}).

  Write simple test cases to test the type rules, and ensure that the
  type-checker behaves as expected on those test files.
  For example, if your type system forbids indexing an array by a
  possibly-negative value, then you would write a test case such as:

\begin{Verbatim}
  void foo(String[] myarray, @UnknownSign int us, @NonNegative int nn) {
    myarray[us];  // expected error on this line
    myarray[nn];
  }
\end{Verbatim}

\item
  Implement and test type introduction rules, if any (Section~\ref{creating-type-introduction}).

  For example, if your type system sets the qualifier for manifest literal
  integers and for array lengths, you would write a test case like the following:

\begin{Verbatim}
  void foo(String[] myarray) {
    @NonNegative nn1 = -1;  // expected error on this line
    @NonNegative nn2 = 0;
    @NonNegative nn3 = 1;
    @NonNegative nn4 = myarray.length;
  }
\end{Verbatim}

\item
  Optionally, implement and test dataflow refinement rules
  (Section~\ref{creating-dataflow}).

  For instance, if after an arithmetic comparison, your type system infers
  which expressions are now known to be non-negative, you could write a
  test case such as:

\begin{Verbatim}
  void foo(@UnknownSign int us, @NonNegative int nn) {
    @NonNegative nn2;
    nn2 = us;  // expected error on this line
    if (us > j) {
      nn2 = us;
    }
    if (us >= j) {
      nn2 = us;
    }
    if (j < us) {
      nn2 = us;
    }
    if (j <= us) {
      nn2 = us;
    }
    nn = us;  // expected error on this line
  }
\end{Verbatim}

\end{enumerate}




\section{Annotations: Type qualifiers and hierarchy\label{creating-typequals}}

A type system designer specifies the qualifiers in the type system (Section~\ref{creating-define-type-qualifiers})
and
the type hierarchy that relates them.
The type hierarchy --- the subtyping relationships among the qualifiers ---
can be defined either
declaratively via meta-annotations (Section~\ref{creating-declarative-hierarchy}), or procedurally through
subclassing \refclass{framework/type}{QualifierHierarchy} or
\refclass{framework/type}{TypeHierarchy} (Section~\ref{creating-procedural-hierarchy}).


\subsection{Defining the type qualifiers\label{creating-define-type-qualifiers}}

%% True, but seems irrelevant here, so it detracts from the message.
% Each qualifier restricts the values that
% a type can represent.  For example \<@NonNull String> type can only
% represent non-null values, indicating that the variable may not hold
% \<null> values.

Type qualifiers are defined as Java annotations.  In Java, an
annotation is defined using the Java \code{@interface} keyword.
For example, to define a two-qualifier hierarchy: the \<@Nullable> annotation which is the top
qualifier in its type hierarchy:

\begin{Verbatim}
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Target;
  import org.checkerframework.framework.qual.SubtypeOf;
  import org.checkerframework.framework.qual.DefaultQualifierInHierarchy;
  @DefaultQualifierInHierarchy
  @SubtypeOf({})
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface UnknownSign {}


  import java.lang.annotation.ElementType;
  import java.lang.annotation.Target;
  import org.checkerframework.framework.qual.SubtypeOf;
  @SubtypeOf({UnknownSign.class})
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface NonNegative {}
\end{Verbatim}

The \refqualclass{framework/qual}{SubtypeOf} meta-annotation
indicates the parent in the type hierarchy.

The \sunjavadocanno{java/lang/annotation/Target.html}{Target}
meta-annotation indicates where the annotation
may be written. All type qualifiers that users can write in source code should
have the value \<ElementType.TYPE\_USE> and optionally with the additional value
of \<ElementType.TYPE\_PARAMETER>, but no other \<ElementType> values.
%% This feels like clutter that distracts from the main point of the section.
% (Terminological note:  a \emph{meta-annotation} is an annotation that
% is written on an annotation definition, such as
% \refqualclass{framework/qual}{SubtypeOf} and
% \sunjavadocanno{java/lang/annotation/Target.html}{Target}.)

The annotations should be placed within a directory called \<qual>, and this
directory should be placed in the same directory as your Checker's source file.

For example, the Nullness Checker's source file is located at
\<.../nullness/NullnessChecker.java>. The \<NonNull> qualifier is located in the
directory \<.../nullness/qual>.

The Checker Framework automatically treats any annotation that has this value
and is declared in the qual package as a type qualifier.
(See Section \ref{creating-indicating-supported-annotations} for more details.)

% \noindent
% The \<@Target({ElementType.TYPE\_USE})> meta-annotation
% distinguishes it from an ordinary
% annotation that applies to a declaration (e.g., \<@Deprecated> or
% \<@Override>).
% The framework ignores any annotation whose
% declaration does not bear the \<@Target({ElementType.TYPE\_USE})>
% meta-annotation (with minor
% exceptions, such as \<@SuppressWarnings>).

Your type system should include a top qualifier and a bottom qualifier
(Section~\ref{creating-bottom-and-top-qualifier}).  You should also define a
polymorphic qualifier \<@Poly\emph{MyTypeSystem}>
(Section~\ref{qualifier-polymorphism}).


\subsection{Declaratively defining the qualifier hierarchy\label{creating-declarative-hierarchy}}

Declaratively, the type system designer uses two meta-annotations (written
on the declaration of qualifier annotations) to specify the qualifier
hierarchy.

\begin{itemize}

\item \refqualclass{framework/qual}{SubtypeOf} denotes that a qualifier is a subtype of
  another qualifier or qualifiers, specified as an array of class
  literals.  For example, for any type $T$,
  \refqualclass{checker/nullness/qual}{NonNull} $T$ is a subtype of \refqualclass{checker/nullness/qual}{Nullable} $T$:

  \begin{Verbatim}
    @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
    @SubtypeOf( { Nullable.class } )
    public @interface NonNull { }
  \end{Verbatim}

  % (The actual definition of \refclass{checker/nullness/qual}{NonNull} is slightly more complex.)


  %% True, but a distraction.  Move to Javadoc?
  % (It would be more natural to use Java subtyping among the qualifier
  % annotations, but Java forbids annotations from subtyping one another.)
  %
  \refqualclass{framework/qual}{SubtypeOf} accepts multiple annotation classes as an argument,
  permitting the type hierarchy to be an arbitrary DAG\@.

% TODO: describe multiple type hierarchies
% TODO: describe multiple polymorphic qualifiers and PolyAll
% TODO: the code consistently uses "top" for type qualifiers and
%       "root" for ASTs, in particular for CompilationUnitTrees.

  All type qualifiers, except for polymorphic qualifiers (see below and
  also Section~\ref{qualifier-polymorphism}), need to be
  properly annotated with \refclass{framework/qual}{SubtypeOf}.

  The top qualifier is annotated with
  \<@SubtypeOf( \{ \} )>.  The top qualifier is the qualifier that is
  a supertype of all other qualifiers.  For example, \refqualclass{checker/nullness/qual}{Nullable}
  is the top qualifier of the Nullness type system, hence is defined as:

  \begin{Verbatim}
    @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
    @SubtypeOf( { } )
    public @interface Nullable { }
  \end{Verbatim}

  \begin{sloppypar}
  If the top qualifier of the hierarchy is the unqualified type, then its children
  will use \code{@SubtypeOf(Unqualified.class)}, but no \code{@SubtypeOf(\{\})} annotation on the top qualifier is necessary.  For an example, see the
  \<Encrypted> type system of Section~\ref{encrypted-example}.
  \end{sloppypar}

\item \refqualclass{framework/qual}{PolymorphicQualifier} denotes that a qualifier is a
  polymorphic qualifier.  For example:

  \begin{Verbatim}
    @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
    @PolymorphicQualifier
    public @interface PolyNull { }
  \end{Verbatim}

  For a description of polymorphic qualifiers, see
  Section~\ref{qualifier-polymorphism}.  A polymorphic qualifier needs
  no \refqualclass{framework/qual}{SubtypeOf} meta-annotation and need not be
  mentioned in any other \refqualclass{framework/qual}{SubtypeOf}
  meta-annotation.

\end{itemize}

The declarative and procedural mechanisms for specifying the hierarchy can
be used together.  In particular, when using the \refqualclass{framework/qual}{SubtypeOf}
meta-annotation, further customizations may be
performed procedurally (Section~\ref{creating-procedural-hierarchy})
by overriding the \refmethodterse{framework/util}{GraphQualifierHierarchy}{isSubtype}{-java.util.Collection-java.util.Collection-} method in the checker class
(Section~\ref{creating-compiler-interface}).
However, the declarative mechanism is sufficient for most type systems.


\subsection{Procedurally defining the qualifier hierarchy\label{creating-procedural-hierarchy}}

While the declarative syntax suffices for many cases, more complex
type hierarchies can be expressed by overriding, in your subclass of \refclass{common/basetype}{BaseTypeVisitor},
either \refmethodterse{framework/type}{AnnotatedTypeFactory}{createQualifierHierarchy}{--} or \refmethodterse{framework/type}{AnnotatedTypeFactory}{createTypeHierarchy}{--} (typically
only one of these needs to be overridden).
For more details, see the Javadoc of those methods and of the classes
\refclass{framework/type}{QualifierHierarchy} and \refclass{framework/type}{TypeHierarchy}.

The \refclass{framework/type}{QualifierHierarchy} class represents the qualifier hierarchy (not the
type hierarchy).  A type-system designer may subclass
\refclass{framework/type}{QualifierHierarchy} to express customized qualifier
relationships (e.g., relationships based on annotation
arguments).

The \refclass{framework/type}{TypeHierarchy} class represents the type hierarchy ---
that is, relationships between
annotated types, rather than merely type qualifiers, e.g., \<@NonNull
Date> is a subtype of \<@Nullable Date>.  The default \refclass{framework/type}{TypeHierarchy} uses
\refclass{framework/type}{QualifierHierarchy} to determine all subtyping relationships.
The default \refclass{framework/type}{TypeHierarchy} handles
generic type arguments, array components, type variables, and
wildcards in a similar manner to the Java standard subtype
relationship but with taking qualifiers into consideration.  Some type
systems may need to override that behavior.  For instance, the Java
Language Specification specifies that two generic types are subtypes only
if their type arguments are identical:  for example,
\code{List<Date>} is not a subtype of \code{List<Object>}, or of any other
generic \code{List}.
(In the technical jargon, the generic arguments are ``invariant'' or ``novariant''.)


\subsection{Defining a default annotation\label{creating-typesystem-defaults}}

A type system applies a default qualifier where the user has not written a
qualifier (and no implicit qualifier is applicable), as explained in
Section~\ref{defaults}.

The type system designer may specify a default annotation declaratively,
using the \refqualclass{framework/qual}{DefaultQualifierInHierarchy}
meta-annotation.
Note that the default will apply to any source code that the checker reads,
including stub libraries, but will not apply to compiled \code{.class}
files that the checker reads.

\begin{sloppypar}
Alternately, the type system designer may specify a default procedurally,
by overriding the
\refmethod{framework/type}{GenericAnnotatedTypeFactory}{addCheckedCodeDefaults}{-org.checkerframework.framework.util.defaults.QualifierDefaults-}
method.  You may do this even if you have declaratively defined the
qualifier hierarchy.
\end{sloppypar}

If the default qualifier in the type hierarchy requires a value, there are ways for the type system designer to specify a default value both declaratively and procedurally, as well. To do so declaratively, append the string ``default <value>'' where ``<value>'' is the actual value you want to be the default, after the declaration of the value in the qualifier file. For instance, \code{int value() default 0;} would make \code{value} default to zero. Alternatively, the procedural method described above can be used.


\subsection{Relevant Java types\label{creating-relevant-java-types}}

A checker can use the \refqualclass{framework/qual}{RelevantJavaTypes}
annotation on the checker class to specify which Java types are relevant to the
checker.  All irrelevant types without explicit annotations are defaulted to
the top annotation.


\subsection{Do not re-use type qualifiers\label{creating-do-not-re-use-type-qualifiers}}

Every annotation should belong to only one type system.  No annotation
should be used by multiple type systems.  This is true even of annotations
that are internal to the type system and are not intended to be written by
the programmer.

Suppose that you have two type systems that both use the same type
qualifier \<@A>.  In a client program, a use of type \<T> may require type
qualifier \<@A> for one type system but a different qualifier for the other
type system.  There is no annotation that a programmer can write to make
the program type-check under both type systems.

This also applies to type qualifiers that a programmer does not write,
because the compiler outputs \<.class> files that contain an explicit type
qualifier on every type --- a defaulted or inferred type qualifier if the
programmer didn't write a type qualifier explicitly.


\subsection{Completeness of the type hierarchy\label{creating-bottom-and-top-qualifier}}

When you define a type system, its type hierarchy must be a
complete lattice --- that is, there must be a top type that is a
supertype of all other types, and there must be a bottom type that is a
subtype of all other types.
Furthermore, it is best if the top type and bottom type are defined
explicitly for the type system, rather than (say) reusing a qualifier from the
Checker Framework such as \<@Unqualified>.

It is possible that a single type-checker checks multiple type hierarchies.
An example is the Nullness Checker, which has three separate type
hierarchies, one each for
nullness, initialization, and map keys.  In this case, each type hierarchy
would have its own top qualifier and its own bottom qualifier; they don't
all have to share a single top qualifier or a single bottom qualifier.


\paragraph{Bottom qualifier\label{creating-bottom-qualifier}}
Your type hierarchy must have a bottom qualifier
--- a qualifier that is a (direct or indirect) subtype of every other
qualifier.

Your type system must give \<null> the bottom type.  (The only exception
is if the type system has special treatment for \<null> values, as the
Nullness Checker does.)  This legal code
will not type-check unless \<null> has the bottom type:
\begin{Verbatim}
<T> T f() {
    return null;
}
\end{Verbatim}

% \begin{sloppypar}
% You don't necessarily have to define a new bottom qualifier.  You can
% use \<org.checkerframework.framework.qual.Bottom> if your type system does not already have an
% appropriate bottom qualifier.
% \end{sloppypar}

If your type system has a special bottom type that is used \emph{only} for
the \code{null} value, then users should only write the bottom qualifier
on explicit bounds.  To ensure this, write
\<@TargetLocations(\{ TypeUseLocation.EXPLICIT\_LOWER\_BOUND, TypeUseLocation.EXPLICIT\_UPPER\_BOUND \})>
on the definition of the bottom qualifier.
Furthermore, by convention the name of such a qualifier ends with ``\<Bottom>''.

The hierarchy shown in Figure~\ref{fig-initialization-hierarchy} lacks
a bottom qualifier, but the actual implementation does contain a (non-user-visible) bottom qualifier.


\paragraph{Top qualifier\label{creating-top-qualifier}}
Your type hierarchy must have a top qualifier
--- a qualifier that is a (direct or indirect) supertype of every other
qualifier.
Here is the reason.
The default type for local variables is the top
qualifier (that type is then flow-sensitively
refined depending on what values are stored in the local variable).
If there is no single top qualifier, then there is no
unambiguous choice to make for local variables.

Furthermore, it is most convenient to users if the top qualifier is defined
by the type system.  It is possible to use the framework's
\<@Unqualified> as the top type, but this is poor practice.
Users lose
flexibility in expressing defaults:  there is no
way for a user to change the default qualifier for just that type system.
If a user specifies
\<@DefaultQualifier(Unqualified.class)>,
then the default would apply to every
type system that uses \<@Unqualified>, which is unlikely to be desired.


\subsection{Annotations whose argument is a Java expression (dependent type annotations)\label{dependent-types}}
\label{expression-annotations}

Sometimes, an annotation needs to refer to a Java expression.
Section~\ref{java-expressions-as-arguments} gives examples of such
annotations and also explains what Java expressions can and cannot be
referred to.

This section explains the Checker Framework's functionality to support such
annotations.

A ``dependent type annotation''
must have one attribute, \<value>, that is an
array of strings.  The Checker Framework verifies that the annotation's
arguments are valid expressions according to the rules of
Section~\ref{java-expressions-as-arguments}.  If
the expression is not valid, an error is issued and the string in the
annotation is changed to indicate that the expression is not valid.

The Checker Framework standardizes the expression strings.  For example, a
field \<f> can be referred to as either ``f'' or ``this.f''.  If the
programmer writes ``f'', the the Checker Framework changes it to
``this.f'', as if the programmer had written that.
An advantage of this canonicalization is that
that comparisons, such as \<isSubtype>, can be implemented as string comparisons.

The Checker Framework viewpoint-adapts type annotations on method, constructor,
and field declarations at uses for those methods.  For example, given the
following class

\begin{Verbatim}
class MyClass {
   Object field = ...;
   @Anno("this.field") Object field2 = ...;
}
\end{Verbatim}
and assuming the variable \<myClass> is of type \<MyClass>, then the type of
\<myClass.field> is viewpoint-adapted to \<@Anno("myClass.field")>.

To use this built-in functionality, add a \refqualclass{framework/qual}{JavaExpression} annotation
to any annotation element that should be interpreted as a Java expression.  The type of the
element must be an array of Strings.  If your checker requires special handling of Java expressions,
your checker implementation should override
\refmethod{framework/type}{GenericAnnotatedTypeFactory}{createDependentTypesHelper}{--}
to return a subclass of \<DependentTypesHelper>.

Given a specific expression in the program (of type Tree or Node), a
checker may need to obtain its canonical string representation.  This
enables the checker to create an dependent type annotation that refers to
it, or to compare to the string expression of an existing expression
annotation.
To obtain the string, first create a
\refclass{dataflow/analysis}{FlowExpressions.Receiver} object by calling
\refmethodanchortext{dataflow/analysis}{FlowExpressions}{internalReprOf}{-org.checkerframework.javacutil.AnnotationProvider-com.sun.source.tree.ExpressionTree-}{internalReprOf(AnnotationProvider,
ExpressionTree)} or
\refmethodanchortext{dataflow/analysis}{FlowExpressions}{internalReprOf}{-org.checkerframework.javacutil.AnnotationProvider-org.checkerframework.dataflow.cfg.node.Node-}{internalReprOf(AnnotationProvider,
Node)}.
Then, call \<toString()> on the \<FlowExpressions.Receiver> object.


\section{Visitor: Type rules\label{creating-extending-visitor}}

A type system's rules define which operations on values of a
particular type are forbidden.
These rules must be defined procedurally, not declaratively.

The Checker Framework provides a \textit{base visitor class},
\refclass{common/basetype}{BaseTypeVisitor}, that performs type-checking at each node of a
source file's AST\@.  It uses the visitor design pattern to traverse
Java syntax trees as provided by Oracle's
\href{http://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/}{Tree
API},
and it issues a warning (by calling
\refmethod{framework/source}{SourceChecker}{report}
{-org.checkerframework.framework.source.Result-java.lang.Object-})
whenever the type system is violated.

A checker's visitor overrides one method in the base visitor for each special
rule in the type qualifier system.  Most type-checkers
override only a few methods in \refclass{common/basetype}{BaseTypeVisitor};
the overridden version does its own checks and also invokes the version in
its superclass so that standard checks are also performed.  For example, the
visitor for the Nullness type system of Chapter~\ref{nullness-checker}
contains a single 4-line method that warns if an expression of nullable type
is dereferenced, as in:
\begin{Verbatim}
  myObject.hashCode();  // invalid dereference
\end{Verbatim}



By default, \refclass{common/basetype}{BaseTypeVisitor} performs subtyping checks that are
similar to Java subtype rules, but taking the type qualifiers into account.
\refclass{common/basetype}{BaseTypeVisitor} issues these errors:

\begin{itemize}

\item invalid assignment (type.incompatible) for an assignment from
  an expression type to an incompatible type.  The assignment may be a
  simple assignment, or pseudo-assignment like return expressions or
  argument passing in a method invocation

  In particular, in every assignment and pseudo-assignment, the
  left-hand side of the assignment is a supertype of (or the same type
  as) the right-hand side.  For example, this assignment is not
  permitted:

  \begin{Verbatim}
    @Nullable Object myObject;
    @NonNull Object myNonNullObject;
    ...
    myNonNullObject = myObject;  // invalid assignment
  \end{Verbatim}

\item invalid generic argument (type.argument.type.incompatible) when a type
  is bound to an incompatible generic type variable

\item invalid method invocation (method.invocation.invalid) when a
  method is invoked on an object whose type is incompatible with the
  method receiver type

\item invalid overriding parameter type (override.parameter.invalid)
  when a parameter in a method declaration is incompatible with that
  parameter in the overridden method's declaration

\item invalid overriding return type (override.return.invalid) when a
  parameter in a method declaration is incompatible with that
  parameter in the overridden method's declaration

\item invalid overriding receiver type (override.receiver.invalid)
  when a receiver in a method declaration is incompatible with that
  receiver in the overridden method's declaration

\end{itemize}


\subsection{AST traversal\label{creating-ast-traversal}}

The Checker Framework needs to do its own traversal of the AST even though
it operates as an ordinary annotation processor~\cite{JSR269}.  Annotation
processors can utilize a visitor for Java code, but that visitor only
visits the public elements of Java code, such as classes, fields, methods,
and method arguments --- it does not visit code bodies or various other
locations.  The Checker Framework hardly uses the built-in visitor --- as
soon as the built-in visitor starts to visit a class, then the Checker
Framework's visitor takes over and visits all of the class's source code.

Because there is no standard API for the AST of Java code\footnote{Actually,
there is a standard API for Java ASTs --- JSR 198 (Extension API for
Integrated Development Environments)~\cite{JSR198}.  If tools were to
implement it
(which would just require writing wrappers or adapters), then the Checker
Framework and similar tools could be portable among different compilers and
IDEs.}, the Checker
Framework uses the javac implementation.  This is why the Checker Framework
is not deeply integrated with Eclipse, but runs as an external tool (see
Section~\ref{eclipse}).


\subsection{Avoid hardcoding\label{creating-avoid-hardcoding}}

It may be tempting to write a type-checking rule for method invocation,
where your rule checks the name of the method being called and then treats
the method in a special way.  This is usually the wrong approach.  It
is better to write annotations, in a stub file
(Chapter~\ref{annotating-libraries}), and leave the work to the standard
type-checking rules.


\section{Type factory: Implicit annotations (type introduction rules)\label{creating-type-introduction}}

For some types and expressions, a qualifier should be treated as present
even if a programmer did not explicitly write it.  For example, every
literal (other than \<null>) has a \refqualclass{checker/nullness/qual}{NonNull} type.
Section~\ref{effective-qualifier} explains the meaning of implicit
qualifiers, such as that they cannot be overridden.

The implicit annotations may be specified declaratively
(Section~\ref{creating-declarative-type-introduction}) and/or procedurally
(Section~\ref{creating-procedurally-specifying-implicit-annotations}).
It is easiest to specify them declaratively, when the declarative method is
sufficiently expressive.


\subsection{Declaratively specifying implicit annotations\label{creating-declarative-type-introduction}}

The \refqualclass{framework/qual}{ImplicitFor} meta-annotation indicates
implicit annotations.
When written on a qualifier, \refclass{framework/qual}{ImplicitFor}
specifies the trees (AST nodes) and types for which the framework should
automatically add that qualifier.

In short, the types and trees can be
specified via any combination of four fields in \refclass{framework/qual}{ImplicitFor}.

For example, consider the definitions of the
\refqualclass{checker/nullness/qual}{Nullable} and
\refqualclass{checker/nullness/qual}{NonNull}
type qualifiers:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  @SubtypeOf({})
  @ImplicitFor(literals = { LiteralKind.NULL },
               typeNames = { java.lang.Void.class })
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface Nullable { }

  @SubtypeOf( { Nullable.class } )
  @ImplicitFor(types = { TypeKind.PACKAGE,
                         TypeKind.INT, TypeKind.BOOLEAN, TypeKind.CHAR,
                         TypeKind.DOUBLE, TypeKind.FLOAT, TypeKind.LONG,
                         TypeKind.SHORT, TypeKind.BYTE },
      // All literals except NULL_LITERAL:
      literals = { LiteralKind.BOOLEAN, LiteralKind.CHAR, LiteralKind.DOUBLE,
                   LiteralKind.FLOAT, LiteralKind.INT, LiteralKind.LONG,
                   LiteralKind.STRING })
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface NonNull {  }
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

For more details, see the Javadoc for the \refclass{framework/qual}{ImplicitFor}
annotation, and the Javadoc for the javac classes that are linked from
it.  You only need to understand a small amount about the javac AST, such
as the
\href{\TreeAPIBase{}/tree/Tree.Kind.html?is-external=true}{\code{Tree.Kind}}
and
\refModelclass{type}{TypeKind}
enums.  All the information you need is in the Javadoc, and
Section~\ref{creating-javac-tips} can help you get started.


\subsection{Procedurally specifying implicit annotations\label{creating-procedurally-specifying-implicit-annotations}}

If the \<@ImplicitFor> annotation is not sufficiently expressive, then you
can write code to set implicit annotations.  To do so, create a subclass of
\refclass{framework/type}{AnnotatedTypeFactory} and override its
\<addComputedTypeAnnotations> methods.

\<AnnotatedTypeFactory>, when given a program
expression, returns the expression's type.  This should include not only
the qualifiers that the programmer explicitly wrote in the source code, but
also default and implicit annotations, and flow-sensitive local type
inference (see Section~\ref{effective-qualifier} for explanations of these
concepts).

To add implicit annotations, you should override
\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}
(or
\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}
if extending \code{GenericAnnotatedTypeFactory})
and
\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.
The methods operate on \refclass{framework/type}{AnnotatedTypeMirror},
which is the Checker Framework's representation of an annotated type.



\section{Dataflow: enhancing flow-sensitive type qualifier inference\label{creating-dataflow}}

By default, every checker performs automatic type refinement, also known as
flow inference, as described
in Section~\ref{type-refinement}.

In the uncommon case that you wish to disable flow inference in your
checker, put the following two lines at the beginning of the constructor
for your subtype of
\refclass{common/basetype}{BaseAnnotatedTypeFactory}:

\begin{Verbatim}
        // use true to enable flow inference, false to disable it
        super(checker, false);
\end{Verbatim}

You can enhance the Checker Framework's built-in flow-sensitive type refinement,
so that it is more powerful and is customized to your type system. In
particular, your enhancement will yield a more refined type for certain
expressions.

Most enhancements to type refinement are based on a
run-time test specific to the type system, and not all type systems have
applicable run-time tests.  See
Section~\refwithpageparen{type-refinement-runtime-tests} to determine whether
run-time tests are applicable to your type system.

The Checker Framework's type refinement is implemented with a dataflow algorithm
which can be customized to enhance the built-in type refinement. The next
sections detail dataflow customization.  It would also be helpful to read the
\href{https://checkerframework.org/manual/checker-framework-dataflow-manual.pdf}
{Dataflow Manual}, which gives a more in-depth description of the Checker
Framework's dataflow framework.

The steps to customizing type refinement are:
\begin{enumerate}
\item{\ref{creating-dataflow-create-classes}} Create required class and configure its
    use
\item{\ref{creating-dataflow-override-methods}} Override methods that handle
    \refclass{dataflow/cfg/node}{Node}s of interest
\item{\ref{creating-dataflow-determine-expressions}} Determine which expressions will be
    refined
\item{\ref{creating-dataflow-implement-refinement}} Implement the refinement
\end{enumerate}

The Regex Checker's dataflow customization for the
\refmethod{checker/regex}{RegexUtil}{asRegex}{-java.lang.String-}
run-time check is used as an example throughout the steps.


\subsection{Create required class and configure its use\label{creating-dataflow-create-classes}}

The following class must be created to customize dataflow. This class must
be included on the classpath like other components of your checker.

\begin{enumerate}
\item \textbf{Create a class that extends
    \refclass{framework/flow}{CFTransfer}}

  \refclass{framework/flow}{CFTransfer} performs the default Checker
  Framework type refinement.  The extended class will add functionality by
  overriding superclass methods.

  The Regex Checker's extended \refclass{framework/flow}{CFTransfer} is
  \refclass{checker/regex}{RegexTransfer}.

\item \textbf{Configure the checker's type factory to use the extended
    \refclass{framework/flow}{CFTransfer}}

If the checker's extended \refclass{framework/flow}{CFTransfer}
starts with the name of the type system, then the type factory will use the
transfer class without further configuration. For example, if the checker
class is \<FooChecker>, then if the transfer class is \<FooTransfer>, then it is
not necessary to configure the type factory
to use \<FooTransfer>.  If some other naming convention is used, then
to configure your checker's type factory to use the new extended
\refclass{framework/flow}{CFTransfer}, override the
\code{createFlowTransferFunction} method in your type factory to return a new instance
of the extended \refclass{framework/flow}{CFTransfer}.

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  @Override
  public CFTransfer createFlowTransferFunction(
          CFAbstractAnalysis<CFValue, CFStore, CFTransfer> analysis) {
      return new RegexTransfer((CFAnalysis) analysis);
  }
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

%% The text below is true, but not required.
%\item \textbf{Create a class that extends
%    \refclass{framework/flow}{CFAbstractAnalysis} and uses the extended
%    \refclass{framework/flow}{CFAbstractTransfer}}
%
%  \begin{sloppypar}
%  \refclass{framework/flow}{CFAbstractTransfer} and its superclass,
%  \refclass{dataflow/analysis}{Analysis}, are the central coordinating classes
%  in the Checker Framework's dataflow algorithm. The
%  \code{createTransferFunction} method must be overridden in an extended
%  \refclass{framework/flow}{CFAbstractTransfer} to return a new instance of the
%  extended \refclass{framework/flow}{CFAbstractTransfer}.
%  \end{sloppypar}
%
%  \begin{sloppypar}
%  The Regex Checker's extended \refclass{framework/flow}{CFAbstractAnalysis} is
%  \refclass{checker/regex/classic}{RegexAnalysis}, which overrides the
%  \code{createTransferFunction} to return a new
%  \refclass{checker/regex/classic}{RegexTransfer} instance:
%  \end{sloppypar}
%
%%BEGIN LATEX
%\begin{smaller}
%%END LATEX
%\begin{Verbatim}
%  @Override
%  public RegexTransfer createTransferFunction() {
%      return new RegexTransfer(this);
%  }
%\end{Verbatim}
%%BEGIN LATEX
%\end{smaller}
%%END LATEX
%
%\item \textbf{Configure the checker's type factory to use the extended
%    \refclass{framework/flow}{CFAbstractAnalysis}}
%
%\begin{sloppypar}
%To configure your checker's type factory to use the new extended
%\refclass{framework/flow}{CFAbstractAnalysis}, override the
%\code{createFlowAnalysis} method in your type factory to return a new instance
%of the extended \refclass{framework/flow}{CFAbstractAnalysis}.
%\end{sloppypar}
%
%%BEGIN LATEX
%\begin{smaller}
%%END LATEX
%\begin{Verbatim}
%  @Override
%  protected RegexAnalysis createFlowAnalysis(
%          List<Pair<VariableElement, CFValue>> fieldValues) {
%
%      return new RegexAnalysis(checker, this, fieldValues);
%  }
%\end{Verbatim}
%%BEGIN LATEX
%\end{smaller}
%%END LATEX

\end{enumerate}

\subsection{Override methods that handle Nodes of interest\label{creating-dataflow-override-methods}}

At this point, your checker is configured to use your extended
\refclass{framework/flow}{CFTransfer}, but it uses only the default
behavior. Next, in your extended \refclass{framework/flow}{CFTransfer}
override the visitor method that handles the \refclass{dataflow/cfg/node}{Node}s
relevant to your run-time check or run-time operation can be used to refine
types.

A \refclass{dataflow/cfg/node}{Node} is basically equivalent to a javac compiler
\refTreeclass{tree}{Tree}.  A tree is a node in the abstract syntax tree of the
program being checked. See Section~\ref{creating-javac-tips} for more information about trees.

As an example, for the statement \<String a = "";>, the corresponding
abstract syntax tree structure is:
\begin{Verbatim}
VariableTree:
  name: "a"
  type:
    IdentifierTree
      name: String
  initializer:
    LiteralTree
      value: ""
\end{Verbatim}

A \refclass{dataflow/cfg/node}{Node} generally maps one-to-one with a
\refTreeclass{tree}{Tree}. When dataflow processes a method, it translates
\refTreeclass{tree}{Tree}s into \refclass{dataflow/cfg/node}{Node}s and then
calls the appropriate visit method on
\refclass{framework/flow}{CFAbstractTransfer} which then performs the dataflow
analysis for the passed in \refclass{dataflow/cfg/node}{Node}.

Decide what \refclass{dataflow/cfg/node}{Node} kinds are of interest with
respect to the run-time checks or run-time operations you are trying to support.
The \refclass{dataflow/cfg/node}{Node} subclasses can be found in the
\code{org.checkerframework.dataflow.cfg.node} package.  Some examples are
\refclass{dataflow/cfg/node}{EqualToNode},
\refclass{dataflow/cfg/node}{LeftShiftNode},
\refclass{dataflow/cfg/node}{VariableDeclarationNode}.

The Regex Checker refines the type of a run-time test method call, so
\refclass{checker/regex}{RegexTransfer} overrides the method that handles
\refclass{dataflow/cfg/node}{MethodInvocationNode}s,
\code{visitMethodInvocation}.

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  public TransferResult<CFValue, CFStore> visitMethodInvocation(
    MethodInvocationNode n, TransferInput<CFValue, CFStore> in)  { ... }
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\subsection{Determine the expressions to refine the types of\label{creating-dataflow-determine-expressions}}

There are usually multiple expressions used in a run-time check or run-time
operation; determine which expression the customization will refine.  This is
usually specific to the type system and run-time test.

\begin{sloppypar}
Expressions are refined by modifying the return value of a visitor method in
\refclass{framework/flow}{CFAbstractTransfer}.
\refclass{framework/flow}{CFAbstractTransfer} visitor methods return a
\refclass{dataflow/analysis}{TransferResult}.  The constructor of a
\refclass{dataflow/analysis}{TransferResult} takes two parameters: the resulting
type for the \refclass{dataflow/cfg/node}{Node} being evaluated (the result
type) and a map from expressions in scopes to estimates of their types (a
\refclass{dataflow/analysis}{Store}).
\end{sloppypar}

For the program operation \code{op(a,b)}, an enhancement may improve the Checker
Framework's types in either or both of the following ways:
\begin{enumerate}
\item Changing the resulting type to refine the estimate of the type of entire
    expression \code{op(a,b)}.

As an example (and as the running example of
implementing a dataflow refinement),
the \code{RegexUtil.asRegex} method is declared as:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  @Regex(0) String asRegex(String s, int groups) { ... }
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
which means that an expression such as \code{RegexUtil.asRegex(myString, myInt)}
has type \code{@Regex(0) String}. When \code{int} parameter \code{group} is
known or can be inferred at compile time, a better estimate can be given.  For
example, \code{RegexUtil.asRegex(myString, 2)} has type \code{@Regex(2) String}.

\begin{sloppypar}
Changing the \refclass{dataflow/analysis}{TransferResult}'s result type changes
the type that is returned by the \refclass{framework/type}{AnnotatedTypeFactory}
for the tree corresponding to the \refclass{dataflow/cfg/node}{Node} that was
visited.  (Remember that \refclass{common/basetype}{BaseTypeVisitor} uses the
\refclass{framework/type}{AnnotatedTypeFactory} to look up the type of a
\refTreeclass{tree}{Tree}, and then performs checks on types of one or more
\refTreeclass{tree}{Tree}s.)
\end{sloppypar}

When \refclass{checker/regex}{RegexTransfer} evaluates a
\code{RegexUtils.asRegex} invocation, it updates the
\refclass{dataflow/analysis}{TransferResult}'s result type. This changes the
type of the \code{RegexUtils.asRegex} invocation when its
\refTreeclass{tree}{Tree} is looked up by the
\refclass{framework/type}{AnnotatedTypeFactory}.  Regex Checker's
\code{visitMethodInvocation} is shown in more detail in
Section~\ref{creating-dataflow-implement-refinement}.

\item Changing the store to refine the estimate of some other expression, such
    as \code{a} or \code{b}.

As an example, consider an equality test.

\begin{Verbatim}
  @Nullable String s;
    if (s != null) {
    ...
    }
\end{Verbatim}

The type of \<s != null> is always \<@NonNull boolean> (dataflow analysis
does not affect it), but in the true branch, the type of \<s> can be
refined to \<@NonNull String>.


Updating the \refclass{dataflow/analysis}{Store} treats an expression as a
having a refined type for the remainder of the method or conditional block. For
example, when the Nullness Checker's dataflow evaluates \code{myvar != null}, it
updates the \refclass{dataflow/analysis}{Store} to specify that the variable
\code{myvar} should be treated as having type \code{@NonNull} for the rest of the
then conditional block.  Not all kinds of expressions can be refined; currently
method return values, local variables, fields, and array values can be stored in
the \refclass{dataflow/analysis}{Store}.  Other kinds of expressions, like
binary expressions or casts, cannot be stored in the
\refclass{dataflow/analysis}{Store}.

\end{enumerate}


\subsection{Implement the refinement\label{creating-dataflow-implement-refinement}}

\begin{sloppypar}
This section details implementing the visitor method
\code{RegexTransfer.visitMethodInvocation} for the \code{RegexUtil.asRegex}
run-time test.  You can find other examples of visitor methods in
\refclass{checker/lock}{LockTransfer} and
\refclass{checker/formatter}{FormatterTransfer}.
\end{sloppypar}

\begin{enumerate}
\item \textbf{Determine if the visited \refclass{dataflow/cfg/node}{Node} is of
    interest}

The visitor method for a \refclass{dataflow/cfg/node}{Node} is invoked for all
instances of that \refclass{dataflow/cfg/node}{Node} kind in the program, so the
\refclass{dataflow/cfg/node}{Node} must be inspected to determine if it is an
instance of the desired run-time test or operation. For example,
\code{visitMethodInvocation} is called when dataflow processes any method
invocation, but the \refclass{checker/regex}{RegexTransfer} should only refine
the result of \code{RegexUtils.asRegex} invocations:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  @Override
  public TransferResult<CFValue, CFStore> visitMethodInvocation(...)
    ...
    MethodAccessNode target = n.getTarget();
    ExecutableElement method = target.getMethod();
    Node receiver = target.getReceiver();
    if (receiver instanceof ClassNameNode) {
      ClassNameNode cn = (ClassNameNode) receiver;
      String receiverName = cn.getElement().toString();

      // Is this a RegexUtil.isRegex(s, groups) method call?
      if (isRegexUtil(receiverName)) {
        if (ElementUtils.matchesElement(method,
          null, IS_REGEX_METHOD_NAME, String.class, int.class)) {
            ...
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\item \textbf{Determine the refined type}

Some run-time tests, like the null comparison test, have a deterministic type
refinement, e.g. the Nullness Checker always refines the argument in the
expression to \code{@NonNull}.  However, sometimes the refined type is dependent
on the parts of run-time test or operation itself, such as arguments passed to
it.

For example, the refined type of \code{RegexUtils.asRegex} is dependent on the
integer argument to the method call. The \refclass{checker/regex}{RegexTransfer}
uses this argument to build the resulting type \code{@Regex(i)}, where \code{i}
is the value of the integer argument.  Note that currently this code only uses
the value of the integer argument if the argument was an integer literal.  It
could be extended to use the value of the argument if it was any compile-time
constant or was inferred at compile time by another analysis, such as the
\ref{constant-value-checker}.

%BEGIN LATEX
\begin{smaller}
%END LATEX
  \begin{Verbatim}
  AnnotationMirror regexAnnotation;
  Node count = n.getArgument(1);
  if (count instanceof IntegerLiteralNode) {
    IntegerLiteralNode iln = (IntegerLiteralNode) count;
    Integer groupCount = iln.getValue();
    regexAnnotation = factory.createRegexAnnotation(groupCount);

\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

If the integer argument was not a literal integer, the
\refclass{checker/regex}{RegexTransfer} falls back to refining the type to just
\code{@Regex(0)}.

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  } else {
    regexAnnotation = AnnotationUtils.fromClass(factory.getElementUtils(), Regex.class);
  }
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\item \textbf{Return a \refclass{dataflow/analysis}{TransferResult} with the
    refined types}

As discussed in Section~\ref{creating-dataflow-determine-expressions}, the type of an
expression is refined by modifying the
\refclass{dataflow/analysis}{TransferResult}.  Since the
\refclass{checker/regex}{RegexTransfer} is updating the type of the run-time
test itself, it will update the result type and not the
\refclass{dataflow/analysis}{Store}.

A \refclass{framework/flow}{CFValue} is created to hold the type inferred.
\refclass{framework/flow}{CFValue} is a wrapper class for values being inferred
by dataflow:
%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  CFValue newResultValue = analysis.createSingleAnnotationValue(regexAnnotation,
      result.getResultValue().getType().getUnderlyingType());
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

Then, RegexTransfer's \code{visitMethodInvocation} creates and returns a
\refclass{dataflow/analysis}{TransferResult} using \code{newResultValue} as the
result type.

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  return new RegularTransferResult<>(newResultValue, result.getRegularStore());
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

Finally, when the Regex Checker encounters a \code{RegexUtils.asRegex} method
call, the checker will refine the return type of the method if it can determine
the value of the integer parameter at compile time.

\end{enumerate}


\section{The checker class:  Compiler interface\label{creating-compiler-interface}}

A checker's entry point is a subclass of
\refclass{framework/source}{SourceChecker}, and is usually a direct subclass
of either \refclass{common/basetype}{BaseTypeChecker} or
\refclass{framework/source}{AggregateChecker}.
This entry
point, which we call the checker class, serves two
roles:  an interface to the compiler and a factory for constructing
type-system classes.

Because the Checker Framework provides reasonable defaults, oftentimes the
checker class has no work to do.  Here are the complete definitions of the
checker classes for the Interning Checker and the Nullness Checker:

\begin{Verbatim}
  @SupportedLintOptions({"dotequals"})
  public final class InterningChecker extends BaseTypeChecker { }

  @SupportedLintOptions({"flow", "cast", "cast:redundant"})
  public class NullnessChecker extends BaseTypeChecker { }
\end{Verbatim}

(The \refqualclass{framework/source}{SupportedLintOptions} annotation is
optional, and many checker classes do not have one.)

The checker class bridges between the compiler and the rest of the checker.  It
invokes the type-rule check visitor on every Java source file being
compiled, and provides a simple API,
\refmethod{framework/source}{SourceChecker}{report}
{-org.checkerframework.framework.source.Result-java.lang.Object-}, to issue
errors using the compiler error reporting mechanism.

Also, the checker class follows the factory method pattern to
construct the concrete classes (e.g., visitor, factory) and annotation
hierarchy representation.  It is a convention that, for
a type system named Foo, the compiler
interface (checker), the visitor, and the annotated type factory are
named as \<FooChecker>, \<FooVisitor>, and \<FooAnnotatedTypeFactory>.
\refclass{common/basetype}{BaseTypeChecker} uses the convention to
reflectively construct the components.  Otherwise, the checker writer
must specify the component classes for construction.

\begin{sloppypar}
A checker can customize the default error messages through a
\sunjavadoc{java/util/Properties.html}{Properties}-loadable text file named
\<messages.properties> that appears in the same directory as the checker class.
The property file keys are the strings passed to \refmethodterse{framework/source}{SourceChecker}{report}{-org.checkerframework.framework.source.Result-java.lang.Object-}
(like \code{type.incompatible}) and the values are the strings to be
printed (\code{"cannot assign ..."}).
The \<messages.properties> file only need to mention the new messages that
the checker defines.
It is also allowed to override messages defined in superclasses, but this
is rarely needed.
For more details about message keys, see Section~\refwithpageparen{compiler-message-keys}.
\end{sloppypar}

\subsection{Indicating supported annotations\label{creating-indicating-supported-annotations}}

A checker must indicate the annotations that it supports (make up its type
hierarchy), including whether it supports the polymorphic qualifier
\refqualclass{framework/qual}{PolyAll}.

By default, a checker supports \<PolyAll>, and all annotations located in a
subdirectory called \<qual> that's located in the same directory as the checker.
Note that only annotations defined with the \<@Target({ElementType.TYPE\_USE})>
meta-annotation (and optionally with the additional value of
\<ElementType.TYPE\_PARAMETER>, but no other \<ElementType> values)
are automatically considered as supported annotations.

To indicate support for annotations that are located outside of the \<qual>
subdirectory, annotations that have other \<ElementType> values, or to indicate
whether a checker supports the polymorphic qualifier
\refqualclass{framework/qual}{PolyAll}, checker writers can override the
\refmethodterse{framework/type}{AnnotatedTypeFactory}{createSupportedTypeQualifiers}{--}
method (open the link for details).

An aggregate checker (which extends
\refclass{framework/source}{AggregateChecker}) does not need to specify its
type qualifiers, but each of its component checkers should do so.




\subsection{Bundling multiple checkers\label{creating-bundling-multiple-checkers}}

Sometimes, multiple checkers work together and should always be run
together.  There are two different ways to bundle multiple checkers
together, by creating an ``aggregate checker'' or a ``compound checker''.


\begin{enumerate}
\item
An aggregate checker runs multiple independent, unrelated checkers.  There
is no communication or cooperation among them.

The effect is the same as if a user passes
multiple processors to the \<-processor> command-line option.

For example, instead of a user having to run

\begin{Verbatim}
  javac -processor DistanceUnitChecker,VelocityUnitChecker,MassUnitChecker ... files ...
\end{Verbatim}

\noindent
the user can write

\begin{Verbatim}
  javac -processor MyUnitCheckers ... files ...
\end{Verbatim}

\noindent
if you define an aggregate checker class.  Extend \refclass{framework/source}{AggregateChecker} and override
the \<getSupportedTypeCheckers> method, like the following:

\begin{Verbatim}
  public class MyUnitCheckers extends AggregateChecker {
    protected Collection<Class<? extends SourceChecker>> getSupportedCheckers() {
      return Arrays.asList(DistanceUnitChecker.class,
                           VelocityUnitChecker.class,
                           MassUnitChecker.class);
    }
  }
\end{Verbatim}

% This is the *only* example, as of July 2015.
An example of an aggregate checker is \refclass{checker/i18n}{I18nChecker}
(see \chapterpageref{i18n-checker}), which consists of
\refclass{checker/i18n}{I18nSubchecker} and
\refclass{checker/i18n}{LocalizableKeyChecker}.

\item
Use a compound checker to express dependencies among checkers.  Suppose it
only makes sense to run MyChecker if MyHelperChecker has already been run;
that might be the case if MyHelperChecker computes some information that
MyChecker needs to use.

Override
\<MyChecker.\refmethodterse{common/basetype}{BaseTypeChecker}{getImmediateSubcheckerClasses}{--}>
to return a list of the checkers that MyChecker depends on.  Every one of
them will be run before MyChecker is run.  One of MyChecker's subcheckers
may itself be a compound checker, and multiple checkers may declare a
dependence on the same subchecker.  The Checker Framework will run each
checker once, and in an order consistent with all the dependences.

A checker obtains information from its subcheckers (those that ran before
it) by querying their \refclass{framework/type}{AnnotatedTypeFactory} to
determine the types of variables.

\end{enumerate}



\subsection{Providing command-line options\label{creating-providing-command-line-options}}

A checker can provide two kinds of command-line options:
boolean flags and
named string values (the standard annotation processor
options).

\subsubsection{Boolean flags\label{creating-providing-command-line-options-boolean-flags}}

To specify a simple boolean flag, add:

\begin{alltt}
\refqualclass{framework/source}{SupportedLintOptions}(\{"myflag"\})
\end{alltt}

to your checker subclass.
The value of the flag can be queried using

\begin{Verbatim}
checker.getLintOption("myflag", false)
\end{Verbatim}

The second argument sets the default value that should be returned.

To pass a flag on the command line, call javac as follows:

\begin{Verbatim}
javac -processor MyChecker -Alint=myflag
\end{Verbatim}


\subsubsection{Named string values\label{creating-providing-command-line-options-named-string-values}}

For more complicated options, one can use the standard annotation
processing \code{@SupportedOptions} annotation on the checker, as in:

\begin{alltt}
\refqualclass{framework/source}{SupportedOptions}(\{"myoption"\})
\end{alltt}

The value of the option can be queried using

\begin{Verbatim}
checker.getOption("myoption")
\end{Verbatim}

To pass an option on the command line, call javac as follows:

\begin{Verbatim}
javac -processor MyChecker -Amyoption=p1,p2
\end{Verbatim}

The value is returned as a single string and you have to perform the
required parsing of the option.


% TODO: describe -ANullnessChecker_option=value mechanism.


\section{Annotated JDK\label{creating-a-checker-annotated-jdk}}

You will need to supply annotations for relevant parts of the JDK;
otherwise, your type-checker may produce spurious warnings for code that
uses the JDK.  As described in Section~\ref{annotated-libraries-creating},
there are two general ways to supply an annotated library:  in Java files
that will be compiled to \<.class> files, or as stub files (partial Java source files).

To supply an annotated JDK that will be compiled, see Section~\ref{annotating-jdk}.

To supply an annotated JDK as a stub file, create a file \<jdk.astub> in
the checker's main source directory.  It will be automatically used by the
checker.
You can also supply \<.astub> files in that directory for other libraries.
You should list them in a
\refqualclass{framework/qual}{StubFiles} annotation on the checker's main
class, so that they will also be automatically used.


\section{Testing framework\label{creating-testing-framework}}

\begin{sloppypar}
The Checker Framework provides a convenient way to write tests for your
checker.
% Don't repeat the information here, to prevent them from getting out of sync.
It is extensively documented in file \<checker-framework/checker/tests/README>.
\end{sloppypar}


\section{Debugging options\label{creating-debugging-options}}

The Checker Framework provides debugging options that can be helpful when
writing a checker. These are provided via the standard \code{javac} ``\code{-A}''
switch, which is used to pass options to an annotation processor.


\subsection{Amount of detail in messages\label{creating-debugging-options-detail}}

\begin{itemize}
\item \code{-AprintAllQualifiers}: print all type qualifiers, including
qualifiers like \code{@Unqualified} which are usually not shown.
(Use the \code{@InvisibleQualifier} meta-annotation on a qualifier to hide it.)

\item \code{-AprintVerboseGenerics}: print more information about type
  parameters and wildcards when they appear in warning messages.  This
  produces a subset of the information than \code{-AprintAllQualifiers} does.

\item \code{-Adetailedmsgtext}: Output error/warning messages in a
  stylized format that is easy for tools to parse.  This is useful for
  tools that run the Checker Framework and parse its output, such as IDE
  plugins.  See the source code of \<SourceChecker.java> for details about
  the format.

\item \code{-AprintErrorStack}: print a stack trace whenever an
internal Checker Framework error occurs.

\item \code{-Anomsgtext}: use message keys (such as ``\code{type.invalid}'')
rather than full message text when reporting errors or warnings.  This is
used by the Checker Framework's own tests, so they do not need to be
changed if the English message is updated.

\end{itemize}

\subsection{Stub and JDK libraries\label{creating-debugging-options-libraries}}

\begin{itemize}

\item \code{-Aignorejdkastub}:
  ignore the \<jdk.astub> file in the checker directory. Files passed
  through the \code{-Astubs} option are still processed. This is useful
  when experimenting with an alternative stub file.

\item \code{-Anocheckjdk}:
  don't issue an error if no annotated JDK can be found.

\item \code{-AstubDebug}:
  Print debugging messages while processing stub files.

\end{itemize}

\subsection{Progress tracing\label{creating-debugging-options-progress}}

\begin{itemize}

\item \code{-Afilenames}: print the name of each file before type-checking it.

\item \code{-Ashowchecks}: print debugging information for each
pseudo-assignment check (as performed by
\refclass{common/basetype}{BaseTypeVisitor}; see
Section~\ref{creating-extending-visitor}).

\end{itemize}

\subsection{Saving the command-line arguments to a file\label{creating-debugging-options-output-args}}

\begin{itemize}

\item \code{-AoutputArgsToFile}:
  This saves the final command-line parameters as passed to the compiler in a file.
  This file can be used as a script (if the file is marked as executable on Unix, or
  if it includes a \code{.bat} extension on Windows) to re-execute the same compilation command.
  Note that this argument cannot be included in a file containing command-line arguments
  passed to the compiler using the @argfile syntax.

  Example usage: \code{-AoutputArgsToFile=\$HOME/scriptfile}

\end{itemize}

\subsection{Visualizing the dataflow graph\label{creating-debugging-dataflow-graph}}

\begin{itemize}

\item \code{-Aflowdotdir=\emph{somedir}}:
  Specify directory for \<.dot> files visualizing the CFG\@.
  Shorthand for\\
  \<-Acfgviz=org.checkerframework.dataflow.cfg.DOTCFGVisualizer,outdir=\emph{somedir}>.
  % TODO: create the directory if it doesn't exist.
  The directory must already exist.

\item \code{-Averbosecfg}:
  Enable additional output in the CFG visualization.
  Equivalent to passing \<verbose> to \<cfgviz>, e.g. as in
  \<-Acfgviz=MyVisualizer,verbose>

\item \code{-Acfgviz=\emph{VizClassName}[,\emph{opts},...]}:
  Mechanism to visualize the control flow graph (CFG) of
  all the methods and code fragments
  analyzed by the dataflow analysis (Section~\ref{creating-dataflow}).
  The graph also contains information about flow-sensitively refined
  types of various expressions at many program points.

  The argument is a comma-separated sequence of values or key-value pairs.
  The first argument is the fully-qualified name of the
  \<org.checkerframework.dataflow.cfg.CFGVisualizer> implementation
  that should be used. The remaining values or key-value pairs are
  passed to \<CFGVisualizer.init>.

\end{itemize}

You can visualize \<.dot> graph files with the \ahref{http://www.graphviz.org}{Graphviz} program.  For
example, to convert a \<.dot> file to PDF:

\begin{Verbatim}
dot -Tpdf -o myfile.pdf myfile.dot
\end{Verbatim}

\subsection{Miscellaneous debugging options\label{creating-debugging-options-misc}}

\begin{itemize}

\item \code{-AresourceStats}:
  Whether to output resource statistics at JVM shutdown.

\end{itemize}


\subsection{Examples\label{creating-debugging-options-examples}}

The following example demonstrates how these options are used:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
$ javac -processor org.checkerframework.checker.interning.InterningChecker \
    docs/examples/InternedExampleWithWarnings.java -Ashowchecks -Anomsgtext -Afilenames

[InterningChecker] InterningExampleWithWarnings.java
 success (line  18): STRING_LITERAL "foo"
     actual: DECLARED @org.checkerframework.checker.interning.qual.Interned java.lang.String
   expected: DECLARED @org.checkerframework.checker.interning.qual.Interned java.lang.String
 success (line  19): NEW_CLASS new String("bar")
     actual: DECLARED java.lang.String
   expected: DECLARED java.lang.String
docs/examples/InterningExampleWithWarnings.java:21: (not.interned)
    if (foo == bar)
            ^
 success (line  22): STRING_LITERAL "foo == bar"
     actual: DECLARED @org.checkerframework.checker.interning.qual.Interned java.lang.String
   expected: DECLARED java.lang.String
1 error
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\subsection{Using an external debugger\label{creating-debugging-options-external}}

\begin{sloppypar}
You can use any standard debugger to observe the execution of your checker.
Set the execution main class to \code{com.sun.tools.javac.Main}, and insert
the Checker Framework javac.jar (resides in
\code{\$CHECKERFRAMEWORK/checker/dist/javac.jar}).  If using an IDE, it is
recommended that you add \code{.../jsr308-langtools} as a project, so you
can step into its source code if needed.
\end{sloppypar}

You can also set up remote (or local) debugging using the following command as a template:

\begin{Verbatim}
java -jar "$CHECKERFRAMEWORK/framework/dist/framework.jar" \
    -J-Xdebug -J-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005 \
    -processor org.checkerframework.checker.nullness.NullnessChecker \
    src/sandbox/FileToCheck.java

\end{Verbatim}

% TODO: show example -AprintErrorStack usage. Update text above to
% refer to it.

% $ javac -processor org.checkerframework.checker.fenum.FenumChecker IdentityArrayList.java
% error: GraphQualifierHierarchy found an unqualified type.  Please ensure that your implicit rules cover all cases and/or use a @DefaulQualifierInHierarchy annotation.
% 1 error

% $ javac -processor org.checkerframework.checker.fenum.FenumChecker -AprintErrorStack IdentityArrayList.java
%% error: GraphQualifierHierarchy found an unqualified type.  Please ensure that your implicit rules cover all cases and/or use a @DefaulQualifierInHierarchy annotation.
%%   checkers.util.GraphQualifierHierarchy.checkAnnoInGraph(GraphQualifierHierarchy.java:253)
%%   checkers.util.GraphQualifierHierarchy.isSubtype(GraphQualifierHierarchy.java:243)
%%   checkers.fenum.FenumChecker$FenumQualifierHierarchy.isSubtype(FenumChecker.java:129)
%%   checkers.types.QualifierHierarchy.isSubtype(QualifierHierarchy.java:78)
%%   checkers.types.TypeHierarchy.isSubtypeImpl(TypeHierarchy.java:122)
%%   checkers.types.TypeHierarchy.isSubtype(TypeHierarchy.java:67)
%%   checkers.basetype.BaseTypeChecker.isSubtype(BaseTypeChecker.java:323)
%%   checkers.basetype.BaseTypeVisitor.commonAssignmentCheck(BaseTypeVisitor.java:608)
%%   checkers.basetype.BaseTypeVisitor.checkTypeArguments(BaseTypeVisitor.java:680)
%%   checkers.basetype.BaseTypeVisitor.visitMethodInvocation(BaseTypeVisitor.java:299)
%%   checkers.basetype.BaseTypeVisitor.visitMethodInvocation(BaseTypeVisitor.java:1)
%%   com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1351)
%%   com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:67)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:122)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:1)
%%   com.sun.source.util.TreeScanner.visitExpressionStatement(TreeScanner.java:241)
%%   com.sun.tools.javac.tree.JCTree$JCExpressionStatement.accept(JCTree.java:1176)
%%   com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:67)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:122)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:1)
%%   com.sun.source.util.TreeScanner.scan(TreeScanner.java:90)
%%   com.sun.source.util.TreeScanner.visitBlock(TreeScanner.java:160)
%%   com.sun.tools.javac.tree.JCTree$JCBlock.accept(JCTree.java:793)
%%   com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:67)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:122)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:1)
%%   com.sun.source.util.TreeScanner.scanAndReduce(TreeScanner.java:80)
%%   com.sun.source.util.TreeScanner.visitMethod(TreeScanner.java:143)
%%   checkers.basetype.BaseTypeVisitor.visitMethod(BaseTypeVisitor.java:218)
%%   checkers.basetype.BaseTypeVisitor.visitMethod(BaseTypeVisitor.java:1)
%%   com.sun.tools.javac.tree.JCTree$JCMethodDecl.accept(JCTree.java:693)
%%   com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:67)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:122)
%%   checkers.basetype.BaseTypeVisitor.scan(BaseTypeVisitor.java:1)
%%   com.sun.source.util.TreeScanner.scanAndReduce(TreeScanner.java:80)
%%   com.sun.source.util.TreeScanner.scan(TreeScanner.java:90)
%%   com.sun.source.util.TreeScanner.scanAndReduce(TreeScanner.java:98)
%%   com.sun.source.util.TreeScanner.visitClass(TreeScanner.java:132)
%%   checkers.basetype.BaseTypeVisitor.visitClass(BaseTypeVisitor.java:158)
%%   checkers.basetype.BaseTypeVisitor.visitClass(BaseTypeVisitor.java:1)
%%   com.sun.tools.javac.tree.JCTree$JCClassDecl.accept(JCTree.java:617)
%%   com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:49)
%%   checkers.source.SourceChecker.typeProcess(SourceChecker.java:337)
%%   com.sun.source.util.AbstractTypeProcessor$AttributionTaskListener.finished(AbstractTypeProcessor.java:211)
%%   com.sun.tools.javac.main.JavaCompiler.flow(JavaCompiler.java:1272)
%%   com.sun.tools.javac.main.JavaCompiler.flow(JavaCompiler.java:1231)
%%   com.sun.tools.javac.main.JavaCompiler.compile2(JavaCompiler.java:885)
%%   com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:844)
%%   com.sun.tools.javac.main.Main.compile(Main.java:419)
%%   com.sun.tools.javac.main.Main.compile(Main.java:333)
%%   com.sun.tools.javac.main.Main.compile(Main.java:324)
%%   com.sun.tools.javac.Main.compile(Main.java:76)
%%   com.sun.tools.javac.Main.main(Main.java:61)
%% 1 error



\section{Documenting the checker\label{creating-documenting-a-checker}}

This section describes how to write a chapter for this manual that
describes a new type-checker.  This is a prerequisite to having your
type-checker distributed with the Checker Framework, which is the best way
for users to find it and for it to be kept up to date with Checker
Framework changes.  Even if you do not want your checker distributed with
the Checker Framework, these guidelines may help you write better
documentation.

When writing a chapter about a new type-checker, see the existing chapters
for inspiration.  (But recognize that the existing chapters aren't perfect:
maybe they can be improved too.)

A chapter in the Checker Framework manual should generally have the
following sections:

\begin{description}
\item[Chapter: Belly Rub Checker]
  The text before the first section in the chapter should state the
  guarantee that the checker provides and why it is important.  It should
  give an overview of the concepts.  It should state how to run the checker.
\item[Section: Belly Rub Annotations]
  This section includes descriptions of the annotations with links to the
  Javadoc.  Separate type annotations from declaration annotations, and put
  any type annotations that a programmer may not write (they are only used
  internally by the implementation) last within variety of annotation.

  Draw a diagram of the type hierarchy.  A textual description of
  the hierarchy is not sufficient; the diagram really helps readers to
  understand the system.
  The diagram will appear in directory \<docs/manual/figures/>;
  see its \<README> file for tips.

  The Javadoc for the annotations deserves the same care as the manual
  chapter.  Each annotation's Javadoc comment should use the
  \<@checker\_framework.manual> Javadoc taglet to refer to the chapter that
  describes the checker; see \refclass{javacutil/dist}{ManualTaglet}.
\item[Section: What the Belly Rub Checker checks]
  This section gives more details about when an error is issued, with examples.
  This section may be omitted if the checker does not contain special
  type-checking rules --- that is, if the checker only enforces the usual
  Java subtyping rules.
\item[Section: Examples]
  Code examples.
\end{description}

Sometimes you can omit some of the above sections.  Sometimes there are
additional sections, such as tips on suppressing warnings, comparisons to
other tools, and run-time support.

You will create a new \<belly-rub-checker.tex> file,
then \verb|\input| it at a logical place in \<manual.tex> (not
necessarily as the last checker-related chapter).  Also add two references
to the checker's chapter:  one at the beginning of
chapter~\ref{introduction}, and identical text in
Section~\ref{type-refinement-runtime-tests} (both of these lists appear in
the same order as the manual chapters, to help us notice if anything is
missing).

Every chapter and (sub)*section should have a label defined \emph{within} the
\verb|\section| command.  Section labels should start with the checker
name (as in \verb|\label{bellyrub-examples}|) and not with ``\<sec:>''.
These conventions are for the benefit of the Hevea program that produces
the HTML version of the manual.

Don't forget to write Javadoc for any annotations that the checker uses.
That is part of the documentation and is the first thing that many users
may see.  Also ensure that the Javadoc links back to the manual, using the
\<@checker\_framework.manual> custom Javadoc tag.

There are several other miscellaneous tasks:
\begin{itemize}
\item
  Add its \<messages.properties> file to the \<check-compilermsgs> target in
  file \<checker/build.xml>.
\item
  Integrate your new checker with the Eclipse plugin.
  See \$CHECKERFRAMEWORK/eclipse/README-developers.html\#add-checker for instructions.
\end{itemize}


\section{javac implementation survival guide\label{creating-javac-tips}}

Since this section of the manual was written, the useful ``The Hitchhiker's
Guide to javac'' has become available at
\url{http://openjdk.java.net/groups/compiler/doc/hhgtjavac/index.html}.
See it first, and then refer to this section.  (This section of the manual
should be revised, or parts eliminated, in light of that document.)


A checker built using the Checker Framework makes use of a few interfaces
from the underlying compiler (Oracle's OpenJDK javac).
This section describes those interfaces.




\subsection{Checker access to compiler information\label{creating-compiler-information}}

The compiler uses and exposes three hierarchies to model the Java
source code and classfiles.


\subsubsection{Types --- Java Language Model API\label{creating-javac-types}}

A \refModelclass{type}{TypeMirror} represents a Java type.
% Java declaration, statement, or expression.

\begin{sloppypar}
There is a \code{TypeMirror} interface to represent each type kind,
e.g., \code{PrimitiveType} for primitive types, \code{ExecutableType}
for method types, and \code{NullType} for the type of the \code{null} literal.
\end{sloppypar}

\code{TypeMirror} does not represent annotated types though.  A checker
should use the Checker Framework types API,
\refclass{framework/type}{AnnotatedTypeMirror}, instead.  \code{AnnotatedTypeMirror}
parallels the \code{TypeMirror} API, but also present the type annotations
associated with the type.

The Checker Framework and the checkers use the types API extensively.


\subsubsection{Elements --- Java Language Model API\label{creating-javac-elements}}

An \refModelclass{element}{Element} represents a potentially-public
declaration that can be accessed from elsewhere:  classes, interfaces, methods, constructors, and
fields.  \<Element> represents elements found in both source
code and bytecode.

There is an \code{Element} interface to represent each construct, e.g.,
\code{TypeElement} for class/interfaces, \code{ExecutableElement} for
methods/constructors, \code{VariableElement} for local variables and
method parameters.

If you need to operate on the declaration level, always use elements rather
than trees
% in same subsection, which is the limit of the numbering.
% (Section~\ref{javac-trees})
(see below).  This allows the code to work on
both source and bytecode elements.

Example: retrieve declaration annotations, check variable
modifiers (e.g., \code{strictfp}, \code{synchronized})


\subsubsection{Trees --- Compiler Tree API\label{creating-javac-trees}}

A \refTreeclass{tree}{Tree} represents a syntactic unit in the source code,
like a method declaration, statement, block, \<for> loop, etc. Trees only
represent source code to be compiled (or found in \code{-sourcepath});
no tree is available for classes read from bytecode.

There is a Tree interface for each Java source structure, e.g.,
\code{ClassTree} for class declaration, \code{MethodInvocationTree}
for a method invocation, and \code{ForEachTree} for an enhanced-for-loop
statement.

You should limit your use of trees. A checker uses Trees mainly to
traverse the source code and retrieve the types/elements corresponding to
them.  Then, the checker performs any needed checks on the types/elements instead.


\subsubsection{Using the APIs\label{creating-using-the-apis}}

The three APIs use some common idioms and conventions; knowing them will
help you to create your checker.

\emph{Type-checking}:
Do not use \code{instanceof} to determine the class of the object,
because you cannot necessarily predict the run-time type of the object that
implements an interface.  Instead, use the \code{getKind()} method.  The
method returns \refModelclass{type}{TypeKind},
\refModelclass{element}{ElementKind}, and \refTreeclass{tree}{Tree.Kind}
for the three interfaces, respectively.

\emph{Visitors and Scanners}:
The compiler and the Checker Framework use the visitor pattern
extensively. For example, visitors are used to traverse the source tree
(\refclass{common/basetype}{BaseTypeVisitor} extends
\refTreeclass{util}{TreePathScanner}) and for type
checking (\refclass{framework/type/treeannotator}{TreeAnnotator} implements
\refTreeclass{tree}{TreeVisitor}).

\emph{Utility classes}:
Some useful methods appear in a utility class.  The Oracle convention is that
the utility class for a \code{Foo} hierarchy is \code{Foos} (e.g.,
\refModelclass{util}{Types}, \refModelclass{util}{Elements}, and
\refTreeclass{util}{Trees}).  The Checker Framework uses a common
\code{Utils} suffix instead (e.g., \refclass{javacutil}{TypesUtils},
\refclass{javacutil}{TreeUtils}, \refclass{javacutil}{ElementUtils}), with one
notable exception: \refclass{framework/util}{AnnotatedTypes}.


\subsection{How a checker fits in the compiler as an annotation processor\label{creating-checker-as-annotation-processor}}

The Checker Framework builds on the Annotation Processing API
introduced in Java 6.  A type annotation processor is one that extends
\refclass{javacutil}{AbstractTypeProcessor}; these get run on each class
source file after the compiler confirms that the class is valid Java code.

The most important methods of \refclass{javacutil}{AbstractTypeProcessor}
are \code{typeProcess} and \code{getSupportedSourceVersion}. The former
class is where you would insert any sort of method call to walk the AST\@,
and the latter just returns a constant indicating that we are targeting
version 8 of the compiler. Implementing these two methods should be enough
for a basic plugin; see the Javadoc for the class for other methods that
you may find useful later on.

The Checker Framework uses Oracle's Tree API to access a program's AST\@.
The Tree API is specific to the Oracle OpenJDK, so the Checker Framework only
works with the OpenJDK javac, not with Eclipse's compiler ecj.
This also limits the tightness of
the integration of the Checker Framework into other IDEs such as \href{http://www.jetbrains.com/idea/}{IntelliJ IDEA}\@.
An implementation-neutral API would be preferable.
In the future, the Checker Framework
can be migrated to use the Java Model AST of JSR 198 (Extension API for
Integrated Development Environments)~\cite{JSR198}, which gives access to
the source code of a method.  But, at present no tools
implement JSR~198.  Also see Section~\ref{creating-ast-traversal}.



\subsubsection{Learning more about javac\label{creating-learning-more-about-javac}}

Sun's javac compiler interfaces can be daunting to a
newcomer, and its documentation is a bit sparse. The Checker Framework
aims to abstract a lot of these complexities.
You do not have to understand the implementation of javac to
build powerful and useful checkers.
Beyond this document,
other useful resources include the Java Infrastructure
Developer's guide at
\url{http://wiki.netbeans.org/Java_DevelopersGuide} and the compiler
mailing list archives at
\url{http://mail.openjdk.java.net/pipermail/compiler-dev/}
(subscribe at
\url{http://mail.openjdk.java.net/mailman/listinfo/compiler-dev}).


\section{Integrating a checker with the Checker Framework\label{creating-integrating-a-checker}}

% First version of how to integrate a new checker into the release.
% TODO: what steps are missing?

To integrate a new checker with the Checker Framework release, perform
the following:

\begin{itemize}

\item Add a \code{XXX-tests} build target in file
  \<checker-framework/checker/build.xml> and ensure all tests pass.

\item Make sure \code{all-tests} tests the new checker.

\item Extend the \code{check-compilermsgs} target to include the
compiler messages property file of the new checker in
the \code{checker-args} list.  (Keep the list in alphabetical order.)

\item Make sure \code{check-compilermsgs} and \code{check-purity} run
without warnings or errors.

\end{itemize}


% LocalWords:  plugin javac's SourceChecker AbstractProcessor getMessages quals
% LocalWords:  getSourceVisitor SourceVisitor getFactory AnnotatedTypeFactory
% LocalWords:  SupportedAnnotationTypes SupportedSourceVersion TreePathScanner
% LocalWords:  TreeScanner visitAssignment AssignmentTree AnnotatedClassTypes
% LocalWords:  SubtypeChecker SubtypeVisitor NonNull isSubtype getClass nonnull
% LocalWords:  AnnotatedClassType isAnnotatedWith hasAnnotationAt TODO src jdk
% LocalWords:  processor NullnessChecker InterningChecker Nullness Nullable
% LocalWords:  AnnotatedTypeMirrors BaseTypeChecker BaseTypeVisitor basetype
% LocalWords:  Aqual Anqual java CharSequence getAnnotatedType UseLovely
% LocalWords:  AnnotatedTypeMirror LovelyChecker Anomsgtext Ashowchecks enums
% LocalWords:  Afilenames dereferenced SuppressWarnings declaratively SubtypeOf
% LocalWords:  TypeHierarchy GraphQualifierHierarchy Foo qual UnknownSign
% LocalWords:  QualifierHierarchy QualifierRoot createQualifierHierarchy util
% LocalWords:  createTypeHierarchy ImplicitFor treeClasses TypeMirror Anno
% LocalWords:  LiteralTree ExpressionTree typeClasses addComputedTypeAnnotations nullable
% LocalWords:  createSupportedTypeQualifiers FooChecker nullness PolyAll
% LocalWords:  FooVisitor FooAnnotatedTypeFactory basicstyle InterningVisitor
% LocalWords:  InterningAnnotatedTypeFactory QualifierDefaults TypeKind getKind
% LocalWords:  setAbsoluteDefaults PolymorphicQualifier TreeVisitor subnodes
% LocalWords:  SimpleTreeVisitor TreePath instanceof subinterfaces TypeElement
% LocalWords:  ExecutableElement PackageElement DeclaredType VariableElement
% LocalWords:  TypeParameterElement ElementVisitor javax getElementUtils NoType
% LocalWords:  ProcessingEnvironment ExecutableType MethodTree ArrayType Warski
% LocalWords:  MethodInvocationTree PrimitiveType BlockTree TypeVisitor blog
% LocalWords:  AnnotatedTypeVisitor SimpleAnnotatedTypeVisitor html langtools
% LocalWords:  AnnotatedTypeScanner bootclasspath asType stringPatterns Foos
% LocalWords:  DefaultQualifierInHierarchy invocable wildcards novariant Utils
% LocalWords:  AggregateChecker getSupportedTypeCheckers Uninterned sourcepath
% LocalWords:  DefaultQualifier bytecode NullType strictfp ClassTree TypesUtils
% LocalWords:  ForEachTree ElementKind TreeAnnotator TreeUtils ElementUtils ecj
% LocalWords:  AnnotatedTypes AbstractTypeProcessor gcj hardcoding jsr api
% LocalWords:  typeProcess getSupportedSourceVersion fenum classpath astub
%%  LocalWords:  addAbsoluteDefault BaseAnnotatedTypeFactory superclasses
%%  LocalWords:  SupportedOptions AprintAllQualifiers InvisibleQualifier
%%  LocalWords:  Adetailedmsgtext AprintErrorStack Aignorejdkastub Astubs
%%  LocalWords:  Anocheckjdk AstubDebug Aflowdotdir AresourceStats Regex
%%  LocalWords:  classfiles CHECKERFRAMEWORK RegexUtil asRegex myString
%%  LocalWords:  myInt CFAbstractTransfer RegexTransfer CFAbstractAnalysis
%%  LocalWords:  createTransferFunction RegexAnalysis createFlowAnalysis
%%  LocalWords:  EqualToNode LeftShiftNode VariableDeclarationNode myvar
%%  LocalWords:  MethodInvocationNode visitMethodInvocation TransferResult
%%  LocalWords:  RegexUtils LockTransfer FormatterTransfer CFValue argfile
%%  LocalWords:  RegexTransfer's newResultValue subcheckers taglet tex XXX
%%  LocalWords:  ParameterizedCheckerTest AoutputArgsToFile ManualTaglet
%%  LocalWords:  Hevea Hitchhiker's compilermsgs args Poly MyTypeSystem
%%  LocalWords:  I18nChecker i18n I18nSubchecker LocalizableKeyChecker
%%  LocalWords:  MyChecker MyHelperChecker getImmediateSubcheckerClasses
%%  LocalWords:  MyChecker's subchecker plugins ElementType myClass myflag
%%  LocalWords:  CheckerFrameworkTest GenericAnnotatedTypeFactory MyClass
%%  LocalWords:  addCheckedCodeDefaults RelevantJavaTypes TargetLocations
%%  LocalWords:  TypeUseLocation createExpressionAnnoHelper internalReprOf
%%  LocalWords:  ExpressionAnnotationHelper FlowExpressions CFTransfer
%%  LocalWords:  AnnotationProvider FooTransfer createFlowTransferFunction
%%  LocalWords:  SupportedLintOptions myoption StubFiles scriptfile outdir
%%  LocalWords:  somedir Acfgviz Averbosecfg cfgviz MyVisualizer init
%%  LocalWords:  VizClassName CFGVisualizer
