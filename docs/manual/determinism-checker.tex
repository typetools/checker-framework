\htmlhr
\chapter{Determinism Checker\label{determinism-checker}}

A nondeterministic program is one that may produce different output when
run twice on the same input.  It is easier to test a deterministic program,
because nondeterminism can lead to flaky tests that sometimes succeed and
sometimes fail.  It is easier for a user or programmer to compare two
deterministic executions than two nondeterministic executions.  It is
easier to reproduce a bug in a deterministic program.
Therefore, it is desirable for programs to be deterministic.
The Determinism Checker helps you to achieve this goal.

Even single-threaded programs are frequently nondeterministic.
One cause is calls to Random, Date, and Time.
Another cause is use of hash tables (including \<HashSet>s and
\<HashMap>s), whose iteration order is nondeterministic across runs.
For example, even if the set contains the same values, the following code
may produce output in different orders:

\begin{Verbatim}
  for (Object x : mySet) {
    System.out.println(x);
  }
\end{Verbatim}

The Determinism Checker enables a programmer to indicate which
computations should be the same across runs of a single-threaded program,
and then the Determinism Checker verifies that property.

Another common cause of nondeterminism is the operating system scheduler,
for concurrent programs.  The Determinism Checker does not address this
cause of nondeterminism.  Also, the Determinism Checker does not warn
about the possibility that the file system contains different files or
contents on different runs of a program.

To run the Determinism Checker, supply the
\code{-processor DeterminismChecker}
command-line option to javac.
For example:

\begin{alltt}
  javac -processor DeterminismChecker InputFile.java
\end{alltt}

%./bin/javac -cp NonDetTypeChecker/jsr308/checker-framework/checker/build -processor org.checkerframework.checker.determinism.DeterminismChecker NDCheckerTest/src/TestListUnsafe2.java


\section{Determinism qualifiers\label{determinism-qualifiers}}

The Determinism type system uses the following type qualifiers (see Figure~\ref{fig-determinism-hierarchy}):
\begin{description}
\item[\refqualclass{checker/determinism/qual}{NonDet}] indicates
  that the expression might have different values in two different executions.
\item[\refqualclass{checker/determinism/qual}{OrderNonDet}] indicates that
  a collection will have the same elements in every execution, but in a
  possibly different order.  \<@OrderNonDet> may only be written on
  collections.
\item[\refqualclass{checker/determinism/qual}{Det}] indicates that
  the expression evaluates to the same value (up to equality) on all
  executions; for a collection, iteration yields the values in the same
  order.
  This is the default qualifier.
\end{description}

Section~\ref{determinism-polymorphism} explains polymorphic qualifiers.

\begin{figure}
  \begin{center}
    \includeimage{determinism}{4cm}
  \end{center}
\caption{Determinism type hierarchy}
\label{fig-determinism-hierarchy}
\end{figure}


\section{Valid collection types\label{determinism-collection-types}}

The (determinism) type of a Collection must be a supertype or equal to
the type of the type parameter.  For example, you may declare a
deterministic list of deterministic integers, but not a deterministic
list of nondeterministic integers.

For example, these types are valid:
\begin{itemize}
    \item \code{@Det List<@Det Integer>}
    \item \code{@NonDet List<@OrderNonDet Set<@Det String>}\code{>}
\end{itemize}

These types are invalid:
  \begin{itemize}
    \item \code{@Det Set<@NonDet Integer>}
    \item \code{@OrderNonDet String}
  \end{itemize}

Figure~\ref{fig-determinism-collections} illustrates the valid
relationships between collection types and type parameters.

\begin{figure}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    &   &  \multicolumn{3}{l|}{Type Parameter}                                                                       \\ \hline
    &             & NonDet                                     & OrderNonDet              & Det \\ \cline{2-5}
              & NonDet &                                                 &                          &     \\ \cline{2-5}
Collection    & OrderNonDet &   invalid  &                          &     \\ \cline{2-5}
              & Det         &   invalid               &    invalid  &     \\ \hline
  \end{tabular}
  \caption{Valid Collection declarations}
  \label{fig-determinism-collections}
\end{figure}

%Formally, the type validity rule is stated as follows:

%\begin{prooftree}
%  \AxiomC{is\_Collection\_Type(tc)}
%  \AxiomC{outer\_type(tx) <= tc}
%  \BinaryInfC{|- : tc<tx> }
%\end{prooftree}

% \begin{verbatim}
% Type outer_type( Type tx )
% {
%     if ( ! is_Generic_type(tx) )
%         return tx
%     Assert (tx == ty<tz>)
%         return ty
% }
% \end{verbatim}


\section{Controlling polymorphism\label{determinism-polymorphism}}

\begin{description}
\item[\refqualclass{checker/determinism/qual}{PolyDet}] is a
  polymorphic qualifier over nondeterminism (see Section~\ref{qualifier-polymorphism}).
\end{description}

The Determinism Checker makes
several enhancements to standard polymorphic qualifiers.


\subsection{Avoiding @OrderNonDet\label{determinism-polymorphism-ordernondet}}

\begin{description}
\item[\refqualclass{checker/determinism/qual}{PolyDet}\<("down")>]
  Acts like \<@Det> when the polymorphic qualifier is instantiated as
  \<@OrderNonDet>.
  ``\<down>'' refers to the direction in the qualifier hierarchy:
  \<@OrderNonDet> is changed to a lower qualifer that is a subtype of it.
\item[\refqualclass{checker/determinism/qual}{PolyDet}\<("up")>]
  Acts like \<@NonDet> when the polymorphic qualifier is instantiated as
  \<@OrderNonDet>.
  ``\<up>'' refers to the direction in the qualifier hierarchy:
  \<@OrderNonDet> is changed to a higher qualifer that is a supertype of it.
\end{description}

Ordinarily, every occurrence of \<@PolyDet> is instantiated at the same
type.  Sometimes this does not capture the desired behavior.  For instance,
there should be three versions of the \<List.add> and \<List.hashCode> routines:

\begin{Verbatim}
         @NonDet boolean add(      @NonDet List<E> this, E e)
            @Det boolean add( @OrderNonDet List<E> this, E e)
            @Det boolean add(         @Det List<E> this, E e)

         @NonDet int hashCode(     @NonDet List<E> this)
         @NonDet int hashCode(@OrderNonDet List<E> this)
            @Det int hashCode(        @Det List<E> this)
\end{Verbatim}

A standard polymorphic annotation

\begin{Verbatim}
        @PolyDet boolean add(     @PolyDet List<E> this, E e)
        @PolyDet int hashCode(    @PolyDet List<E> this)
\end{Verbatim}

\noindent
can express the first and third versions of each routine, but not the
second one.  The \refqualclass{checker/determinism/qual}{PolyDet}\<("down")> and
\refqualclass{checker/determinism/qual}{PolyDet}\<("up")> annotations enable
expressing the method behavior:

\begin{Verbatim}
@PolyDet("down") boolean add(     @PolyDet List<E> this, E e)
  @PolyDet("up") int hashCode(    @PolyDet List<E> this)
\end{Verbatim}

See the annotated JDK for more examples of the annotations.


\subsection{Distinguishing bindings and uses\label{determinism-polymorphism-binding}}

\begin{description}
\item[\refqualclass{checker/determinism/qual}{PolyDet}\<("use")>]
  Has the same type as any \<@PolyDet> annotations in the method
  declaration, but does not affect their instantiation.
\end{description}

As explained in Section~\ref{qualifier-polymorphism},
all of the \<@PolyDet> annotations in a method declaration are given the same
instantiation, which is one that works for all of the actual arguments
(their least upper bound).

The \<@PolyDet("use")> annotation is given the same instantiation as all of the
\<@PolyDet> annotations, but does not affect the instantiation.

As an example of the need for the \<@PolyDet("use")> annotation, consider the
\<List.set> method.  There should be two versions of it (\<@OrderNonDet
int> is not a valid type, so no \<@OrderNonDet> instantiation is created):

\begin{Verbatim}
E set(@NonDet List<E> this, @NonDet int index, E element)
E set(   @Det List<E> this,    @Det int index, E element)
\end{Verbatim}

\noindent
However, it should \emph{not} be legal for a client to make a call such as
the following:

\begin{Verbatim}
@Det List<...> myDetList;
@NonDet int random;
myDetList.set(random, ...);
\end{Verbatim}

\noindent
even though the arguments are legal for the first instantiation:
each argument type is a subtype of the corresponding declared type.
The type system must forbid this call, because it modifies a
\<@Det> list in a nondeterministic way.

To solve this problem, the instantiation is chosen based only on the first
argument (the \<List> argument).  To have this effect, the library method
annotation is annotated as:

\begin{Verbatim}
E set(@PolyDet List<E> this, @PolyDet("use") int index, E element)
\end{Verbatim}



\section{How to customize the Determinism Checker\label{determinism-customization}}

In the JDK, printing methods such as \<println> are annotated as taking a
deterministic result.  This guarantees that a program's output will be
deterministic, but it may be too restrictive.  You can define your own
printing methods, some of which can take nondeterministic inputs.  You can
also override the JDK annotations by providing a stub file.

\section{Default annotations on method parameters and returns\label{determinism-param-default}}

Any unannotated method parameter or return type is annotated with the \<@PolyDet> annotation.
This is less restrictive than having \<@Det> as the default for these types. So if you
want to type check method parameters and return types to be deterministic at the call site, you
must anotate the method declaration appropriately.

\section{Annotating local arrays and generic types\label{determinism-local-arrays}}

For locally declared arrays without explicit type annotations, the array type follows the CLIMB to top rule (see Section~\ref{climb-to-top}) and
the component type gets the default type qualifier (\<@Det> in this case).
For example, the array declaration \<int[] a;> is annotated as \<@Det int @NonDet [] a;> by default.
So you must explicitly annotate all local arrays.
Similarly for all local variables with generic type parameters.


%%  LocalWords:  DeterminismChecker HashSet InputFile NonDet Det
%%  LocalWords:  OrderNonDet PolyDet UsePolyDet println
