\htmlhr
\chapter{Frequently Asked Questions (FAQs)\label{faq}}

These are some common questions about the Checker Framework and about
pluggable type-checking in general.  Feel free to suggest improvements to
the answers, or other questions to include here.

There is a separate FAQ for the type annotations syntax
(\url{http://types.cs.washington.edu/jsr308/jsr308-faq.html}).

% Not supported by Hevea, so don't bother; instead do by hand:
% \minitoc

%BEGIN LATEX
~
%END LATEX

\noindent
\textbf{Contents:} \\
\ref{faq-ease-of-use}: Are type annotations easy to read and write? \\
\ref{faq-code-clutter}: Will my code become cluttered with type annotations? \\
\ref{never-make-type-errors}: I don't make type errors, so would pluggable type-checking help me? \\
\ref{faq-handling-warnings}: What should I do if a checker issues a warning about my code? \\
\ref{faq-no-absolute-guarantee}: Can a pluggable type-checker give an absolute guarantee of correctness? \\
\ref{faq-concurrency}: What guarantee does the Checker Framework give for concurrent code? \\
\ref{faq-awarns}: How do I make compilation succeed even if a checker issues errors? \\
\ref{faq-100-warnings}: Why does the checker always say there are 100 errors or warnings? \\
\ref{faq-slowdown}: Will using the Checker Framework slow down my program?  Will it slow down the compiler? \\
\ref{faq-run-time-checking}: How can I do run-time monitoring of properties that were not statically checked? \\
\ref{faq-annotate-existing-program}: How do I get started annotating an existing program? \\
\ref{faq-shorten-command-line}: How do I shorten the command line when invoking a checker? \\
\ref{faq-qualifiers-vs-subclasses}: When should I use type qualifiers, and when should I use subclasses? \\
\ref{faq-create-a-checker}: How do I create a new checker? \\
\ref{faq-declarative-syntax-for-type-rules}: Why is there no declarative syntax for writing type rules? \\
\ref{faq-type-checking-vs-bug-detectors}: Why not just use a bug detector (like FindBugs)? \\
\ref{faq-jml}: How does pluggable type-checking compare with JML? \\
\ref{faq-no-annotation-on-types-and-declarations}: Why shouldn't a qualifier apply to both types and declarations? \\
\ref{faq-receiver}: What is a ``receiver''? \\
\ref{faq-annotation-after-type}: What is the meaning of an annotation after a type, such as \<@NonNull Object @Nullable>? \\
\ref{faq-array-syntax-meaning}: What is the meaning of array annotations such as \<@NonNull Object @Nullable []>? \\
\ref{faq-list-map-nonnull-typeargs}: Why are the type parameters to \<List> and \<Map> annotated as \<@NonNull>? \\
\ref{faq-checker-framework-part-of-java}: Is the Checker Framework an official part of Java? \\



% This FAQ also appears in the JSR 308 FAQ.
\section{Are type annotations easy to read and write?\label{faq-ease-of-use}}

The paper
\ahref{http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html}{``Practical
  pluggable types for Java''}~\cite{PapiACPE2008} discusses case studies in
which programmers
found type annotations to be natural to read and write.  The code
continued to feel like Java, and the type-checking errors were easy to
comprehend and often led to real bugs.

You don't have to take our word for it, though.  You can try the
Checker Framework for yourself.

The difficulty of adding and verifying annotations depends on your program.
If your program is well-designed and -documented, then skimming the
existing documentation and writing type annotations is extremely easy.
Otherwise, you may find yourself spending a lot of time trying to
understand, reverse-engineer, or fix bugs in your program, and then just a
moment writing a type annotation that describes what you discovered.  This
process inevitably improves your code.  You must decide whether it is a
good use of your time.  For code that is not causing trouble now and is
unlikely to do so in the future (the code is bug-free, and you do not
anticipate changing it or using it in new contexts), then the
effort of writing type annotations for it may not be justified.


\section{Will my code become cluttered with type annotations?\label{faq-code-clutter}}

% This FAQ also appears in the JSR 308 FAQ.
% When I update one, also update the other.

As with any language feature, it is possible to write ugly code that
over-uses annotations.  However, in normal use, very few annotations need
to be written.  Figure 1 of the paper
\ahref{http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html}{Practical
  pluggable types for Java}~\cite{PapiACPE2008} reports data for over
350,000 lines of type-annotated code:

\begin{itemize}
\item
    1 annotation per 62 lines for nullness annotations (\<@NonNull>, \<@Nullable>, etc.)
    % (/ (+ 4640 3961 10798) (+ 107 35 167))
\item
    1 annotation per 1736 lines for interning annotations (\<@Interned>)
    % (/ 224048 129)
\item
    1 annotation per 27 lines for immutability annotations (IGJ type system)
    % (/ (+ 6236 18159 30507 8691 59221 26828) (+ 315 1125 1386 384 1815 450))
\end{itemize}

These numbers are for annotating existing code.  New code that
is written with the type annotation system in mind is cleaner and more
correct, so it requires even fewer annotations.

Each annotation that a programmer writes replaces a sentence or phrase of
English descriptive text that would otherwise have been written in the
Javadoc.  So, use of annotations actually reduces the overall size of the
documentation, at the same time as making it less ambiguous and
machine-processable.

In summary:  annotations do not clutter code; they are used much
less frequently than generic types, which Java programmers find acceptable;
and they reduce the overall volume of documentation that a codebase needs.


\section{I don't make type errors, so would pluggable type-checking help me?\label{never-make-type-errors}}

Occasionally, a developer says that he makes no errors that type-checking
could catch, or that any such errors are unimportant because they have low
impact and are easy to fix.  When I investigate the claim, I invariably
find that the developer is mistaken.

Very frequently, the developer has underestimated what type-checking can
discover.  Not every type error leads to an exception being thrown; and
even if an exception is thrown, it may not seem related to classical types.
Remember that a type system can discover
null pointer dereferences,
incorrect side effects, 
security errors such as information leakage or SQL injection,
partially-initialized data,
wrong units of measurement,
and many other errors.  Even where type-checking does not discover a
problem directly, it can indicate code with bad smells, thus revealing
problems, improving documentation, and making future maintenance easier.

There are other ways to discover errors, including extensive testing and
debugging.  You should continue to use these.
But type-checking is a good complement to these.  Type-checking is more
effective for some problems, and less effective for other problems.  It can
reduce (but not eliminate) the time and effort that you spend on other
approaches.  There are many important errors that type-checking and other
automated approaches cannot find; pluggable type-checking gives you more
time to focus on those.


\section{What should I do if a checker issues a warning about my code?\label{faq-handling-warnings}}

For a discussion of this issue, see Section~\ref{handling-warnings}.


\section{Can a pluggable type-checker give an absolute guarantee of correctness?\label{faq-no-absolute-guarantee}}

Each checker looks for certain errors.  You can use multiple checkers, but
even then your program might still contain other kinds of errors.

If you run a pluggable checker on only part of the code of a program, then
you do not get a guarantee that all parts of the program satisfy the type
system (that is, are error-free).  An example is a framework that clients
are intended to extend.  In this case, you should recommend that clients
run the pluggable checker.  There is no way to force users to do so, so you
may want to retain dynamic checks or use other mechanisms to detect errors.

There are other circumstances in which a static type-checker may fail to
detect a possible type error.  In Java, these include arrays, casts,
reflection, separate compilation (bytecodes from unverified sources),
native code, etc.  (For details, see section~\ref{checker-guarantees}.)
Java uses dynamic checks for most of these, so that the
type error cannot cause a security vulnerability or a crash.  The pluggable
type-checkers inherit many (not all) of these weaknesses of Java
type-checking, but do not currently have built-in dynamic checkers.
Writing dynamic checkers would be an interesting and valuable project.

% This paragraph is weak.

Even if a tool such as a pluggable checker cannot give an ironclad
guarantee of correctness, it is still useful.  It can finding errors, 
excluding certain types of possible problems (e.g., restricting the
possible class of problems), and increasing confidence in a piece of
software.


\section{What guarantee does the Checker Framework give for concurrent code?\label{faq-concurrency}}

The Checker Framework currently assumes that the code that it is checking
is sequential:  that is, there are no concurrent accesses from another
thread.  This means that The Checker Framework is unsound for concurrent
code, in the sense that it may fail to warn about a possible null
dereference.  For example, the Nullness Checker issues no warning for this
code:

\begin{Verbatim}
  if (myobject.myfield != null) {
    myobject.myfield.toString();
  }
\end{Verbatim}

\noindent
However, in the presence of multithreading, the call to \<toString> may
fail because another thread may set \<myobject.myfield> to \<null> after
the nullness check in the \<if> condition, but before the \<if> body is
executed.

In the future, the Checker Framework developers plan to add a concurrent
mode that would warn about any error that could happen due to concurrent
accesses to data structures.  This extension is non-trivial, and enabling
it by default would yield many unhelpful warnings for sequential code.

The Lock Checker (see Chapter~\ref{lock-checker}) offers a way to detect
and prevent certain concurrency errors.


% If you are concerned about concurrency, then the ``fix''
% of putting data in a local variable doesn't fix the problem,
% just masks it from one particular checker.  This is bad style and may make
% debugging harder rather than easier.
% 
% For instance, suppose you you have
% 
% if (x.val != null) {
%   x.val = x.val + 1;
% }
% 
% which can suffer a null pointer exception if another thread nulls out
% x.val.  The underlying problem is the possible concurrency error:  the user
% should have used locks or some other mechanism to protect access to x.val.
% 
% Changing this to
% 
% myval = x.val;
% if (myval != null) {
%   x.val = myval + 1;
% }
% 
% does not fix the concurrency error, because no locking has been introduced.
% The code still has a data race that can lose updates or corrupt data
% structures.  The code has been transformed so that the Nullness Checker
% does not issue a warning, but this is scant comfort since the code is no
% more correct than it was before.
% 
% If you want to detect concurrency errors, then it is better to use a
% correct checker that is concurrency-aware, rather than an unsound one that
% encourages incorrect workarounds.  Another way to put this is that a static
% checker should encourage better overall design, not just different bad
% designs.


\section{How do I make compilation succeed even if a checker issues errors?\label{faq-awarns}}

Section~\ref{running} describes the \<-Awarns> command-line
option that turns checker errors into warnings, so type-checking errors
will not cause \<javac> to exit with a failure status.


\section{Why does the checker always say there are 100 errors or warnings?\label{faq-100-warnings}}

By default, javac only reports the first 100 errors or warnings.
Furthermore, once javac encounters an error, it doesn't try compiling any
more files (but does complete compilation of all the ones that it has
started so far).

To see more than 100 errors or warnings, use the javac options \<-Xmaxerrs>
and \<-Xmaxwarns>.  To convert Checker Framework errors into warnings so
that javac will process all your source files, use the option \<-Awarns>.
See Section~\ref{running} for more details.


\section{Will using the Checker Framework slow down my program?  Will it slow down the compiler?\label{faq-slowdown}}

Using the Checker Framework has no impact on the execution of your program:
the Type Annotations compiler emits the identical bytecodes as the Java 8
compiler and so there is no run-time effect.  Because there is no run-time
representation of type qualifiers, there is no way to use reflection to
query the qualifier on a given object, though you can use reflection to
examine a class/method/field declaration.

Using the Checker Framework does increase compilation time.  In theory it
should only add a few percent overhead, but our current implementation
can double the compilation time --- or more, if you run many pluggable
type-checkers at once.  This is especially true if you run pluggable
type-checking on every file (as we recommend) instead of just on the ones
that have recently changed.
Nonetheless, compilation with pluggable type-checking still feels like
compilation, and you can do it as part of your normal development process.


\section{How can I do run-time monitoring of properties that were not statically checked?\label{faq-run-time-checking}}

Some properties are not checked statically (see
Chapter~\ref{warnings-and-legacy} for reasons that code might not be
statically checked).  In such cases, it would be desirable to check the
property dynamically, at run time.
Currently, the Checker Framework has no support for adding code to perform
run-time checking.

Adding such support would be an interesting and valuable project.
An example would be an option that causes the Checker Framework to
automatically insert a run-time check anywhere that static checking is
suppressed.
% such as casts
If you
are able to add run-time verification functionality, we would gladly
welcome it as a contribution to the Checker Framework.

Some checkers have library methods that you can explicitly insert in your
source code.
Examples include the Nullness Checker's
\refmethod{nullness}{NullnessUtils}{castNonNull}{(T)} method (see
Section~\ref{suppressing-warnings-with-assertions}) and the Regex Checker's
\<RegexUtil> class (see Section~\ref{regexutil-methods}).
But, it would be better to have more general support that does not require
the user to explicitly insert method calls.


\section{How do I get started annotating an existing program?\label{faq-annotate-existing-program}}

See Section~\ref{get-started-with-legacy-code}.


\section{How do I shorten the command line when invoking a checker?\label{faq-shorten-command-line}}

The compile options to javac can be a pain to type; for example,
\code{javac -processor checkers.nullness.NullnessChecker ...}.
See Section~\ref{checker-auto-discovery} for a way to avoid the need for
the \code{-processor} command-line option.


\section{When should I use type qualifiers, and when should I use subclasses?\label{faq-qualifiers-vs-subclasses}}

In brief, use subtypes when you can, and use type qualifiers when you cannot
use subtypes.
For more details, see section~\ref{when-to-use-type-qualifiers}.


\section{How do I create a new checker?\label{faq-create-a-checker}}

In addition to using the checkers that are distributed with the Checker
Framework, you can write your own checker to check specific properties that
you care about.  Thus, you can find and prevent the bugs that are most
important to you.

Chapter~\ref{writing-a-checker} gives
complete details regarding how to write a checker.  It also suggests places
to look for more help, such as the \ahref{doc/}{Checker Framework
API documentation (Javadoc)} and the source code of the distributed
checkers.

To whet your interest and demonstrate how easy it is to get started, here
is an example of a complete, useful type-checker.

\begin{Verbatim}
  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface Encrypted { }
\end{Verbatim}

Section~\ref{basic-example} explains this checker and tells
you how to run it.


\section{Why is there no declarative syntax for writing type rules?\label{faq-declarative-syntax-for-type-rules}}

A type system implementer can declaratively specify the type qualifier
hierarchy (Section~\ref{declarative-hierarchy}) and the type introduction rules
(Section~\ref{declarative-type-introduction}).  However, the Checker
Framework uses a procedural syntax for specifying type-checking
rules (Section~\ref{extending-visitor}).
A declarative syntax might be more concise, more readable, and more
verifiable than a procedural syntax.

We have not found the procedural syntax to be the most important impediment
to writing a checker.

Previous attempts to devise a declarative syntax 
for realistic type systems have failed; see a technical
paper~\cite{PapiACPE2008} for a discussion.  When an
adequate syntax exists, then the Checker Framework can be extended to
support it.


\section{Why not just use a bug detector (like FindBugs)?\label{faq-type-checking-vs-bug-detectors}}

Pluggable type-checking finds more bugs than a bug detector does, for any
given variety of bug.

A bug detector like \ahref{http://findbugs.sourceforge.net/}{FindBugs}~\cite{HovemeyerP2004,HovemeyerSP2005},
\ahref{http://jlint.sourceforge.net/}{Jlint}~\cite{Artho2001}, or
\ahref{http://pmd.sourceforge.net/}{PMD}~\cite{Copeland2005} aims to find \emph{some}
of the most obvious bugs in your program.  It uses a lightweight analysis,
then uses heuristics to discard some of its warnings.  Thus, even if the tool
prints no warnings, your code might still have errors --- maybe the
analysis was too weak to find them, or the tool's heuristics classified the
warnings as likely false positives and discarded them.

A type-checker aims to find \emph{all} the bugs (of certain varieties).
It requires you to write type qualifiers in your program, or to use a tool
that infers types.  Thus, it requires more work from the programmer, and in
return it gives stronger guarantees.

Each tool is useful in different circumstances, depending on how important
your code is and your desired level of confidence in your code.  For more
details on the comparison, see section~\ref{other-tools}.  For a case study
that compared the nullness analysis of FindBugs, Jlint, PMD, and the
Checker Framework, see section 6 of the paper
\ahref{http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008.pdf}{``Practical pluggable types for Java''}~\cite{PapiACPE2008}.


\section{How does pluggable type-checking compare with JML?\label{faq-jml}}

\ahref{http://www.cs.ucf.edu/~leavens/JML/}{JML}, the Java Modeling
Language~\cite{LeavensBR2006:JML}, is a language for writing formal
specifications.  JML aims to be more expressive than pluggable
type-checking.  JML is not as practical as pluggable type-checking.

A programmer can write a JML specification that
describes arbitrary facts about program behavior.  Then, the programmer can
use formal reasoning or a theorem-proving tool to verify that the code
meets the specification.  Run-time checking is also possible.
By contrast, pluggable type-checking can express a more limited set of
properties about your program.

The JML toolset is less mature.  For instance, if your code uses
generics or other features of Java 5, then you cannot use JML.  
However, JML has a run-time checker, which the Checker Framework currently
lacks.


\section{Why shouldn't a qualifier apply to both types and declarations?\label{faq-no-annotation-on-types-and-declarations}}

It is bad style for an annotation to apply to both types and declarations.
In other words, every annotation should have a \<@Target> meta-annotation,
and the \<@Target> meta-annotation should list either only declaration
locations or only type annotations.  (It's OK for an annotation to target
both \<ElementType.TYPE\_PARAMETER> and \<ElementType.TYPE\_USE>, but no
other declaration location along with \<ElementType.TYPE\_USE>.)

Sometimes, it may seem tempting for an annotation to apply to both type
uses and (say) method declarations.  Here is a hypothetical example:

\begin{quote}
  ``Each \<Widget> type may have a \<@Version> annotation.
  I wish to prove that versions of widgets don't get assigned to
  incompatible variables, and that older code does not call newer code (to
  avoid problems when backporting).

  A \<@Version> annotation could be written like so:

\begin{Verbatim}
  @Version("2.0") Widget createWidget(String value) { ... }
\end{Verbatim}

\<@Version("2.0")> on the method could mean that the \<createWidget> method
only appears in the 2.0 version.  \<@Version("2.0")> on the return type
could mean that the returned \<Widget> should only be used by code that
uses the 2.0 API of \<Widget>.  It should be possible to specify these
independently, such as a 2.0 method that returns a value that allows the
1.0 API method invocations.''
\end{quote}

Both of these are type properties and should be specified with type
annotations.  No method annotation is necessary or desirable.  The best way
to require that the receiver has a certain property is to use a type
annotation on the receiver of the method.  (Slightly more formally, the
property being checked is compatibility between the annotation on the type
of the formal parameter receiver and the annotation on the type of the
actual receiver.)  If you do not know what ``receiver'' means, see the next
question.


Another example of a type-and-declaration annotation that represents poor
design is JCIP's \<@GuardedBy> annotation~\cite{Goetz2006}.  As discussed
in Section~\ref{jcip-annotations}, it means two different things when
applied to a field or a method.  To reduce confusion and increase
expressiveness, the Lock Checker (see Chapter~\ref{lock-checker}) uses the
\<@Holding> annotation for one of these meanings, rather than overloading
\<@GuardedBy> with two distinct meanings.



\section{What is a ``receiver''?\label{faq-receiver}}

The \emph{receiver} of a method is the \<this> formal parameter, sometimes
also called the ``current object''.  Within the method declaration, \<this>
is used to refer to the receiver formal parameter.  At a method call, the
receiver actual argument is written before the method name.

The method \<compareTo> takes \emph{two} formal parameters.  At a call site
like \<x.compareTo(y)>, the two arguments are \<x> and \<y>.  It is
desirable to be able to annotate the types of both of the formal
parameters, and doing so is supported by both Java's type annotations
syntax and by the Checker Framework.

A type annotation on the receiver is treated exactly like a type annotation
on any other formal parameter.  At each call site, the type of the argument
must be a consistent with (a subtype of or equal to) the declaration of the
corresponding formal parameter.  If not, the type-checker issues a warning.

Here is an example.  Suppose that \<@A Object> is a supertype of \<@B
Object> in the following declaration:

\begin{Verbatim}
  class MyClass {
    void requiresA(@A MyClass this) { ... }
    void requiresB(@B MyClass this) { ... }
  }
\end{Verbatim}

\noindent
Then the behavior of four different invocations is as follows:

\begin{Verbatim}
  @A MyClass myA = ...;
  @B MyClass myB = ...;

  myA.requiresA()    // OK
  myA.requiresB()    // compile-time error
  myB.requiresA()    // OK
  myB.requiresB()    // OK
\end{Verbatim}

The invocation \<myA.requiresB()> does not type-check because the actual
argument's type is not a subtype of the formal parameter's type.

A top-level constructor does not have a receiver.  An inner class
constructor does have a receiver, whose type is the same as the containing
outer class.  The receiver is distinct from the object being constructed.
In a method of a top-level class, the receiver is named \<this>.  In a
constructor of an inner class, the receiver is named \<Outer.this> and the
result is named \<this>.


\section{What is the meaning of an annotation after a type, such as \<@NonNull Object @Nullable>?\label{faq-annotation-after-type}}

In a type such as \<@NonNull Object @Nullable []>, it may appear that the
\<@Nullable> annotation is written \emph{after} the type \<Object>.  In
fact, \<@Nullable> modifies \<[]>.  See the next FAQ, about array
annotations (Section~\ref{faq-array-syntax-meaning}).


\section{What is the meaning of array annotations such as \<@NonNull Object @Nullable []>?\label{faq-array-syntax-meaning}}

You should parse this as:
(\textbf{\<@NonNull Object>}) (\textbf{\<@Nullable []>}).
Each annotation precedes the component of the type that it qualifies.

Thus,
\<@NonNull Object @Nullable []> is a possibly-null array of non-null
objects.  Note that the first token in the type,
``\<@NonNull>'', applies to the element
type \<Object>, not to the array type as a whole.  The annotation \<@Nullable> applies to the
array (\<[]>).

Similarly,
\<@Nullable Object @NonNull []> is a non-null array of possibly-null
objects.


Some older tools interpret a declaration like \<@NonEmpty String[] var> as
``non-empty array of strings''.  This is in conflict with the Java type
annotations specification, which defines it as meanning ``array of
non-empty strings''.
% (and has since October 2007)
If you use one of these
older tools, you will find this incompatibility confusing.
You will have to live with it until the older
tool is updated to conform to the Java specification, or until you
transition to a newer tool that conforms to the Java specification.


\section{Why are the type parameters to \<List> and \<Map> annotated as \<@NonNull>?\label{faq-list-map-nonnull-typeargs}}

The annotation on \<java.util.Collection> only allows non-null elements:

\begin{Verbatim}
  public interface Collection<E extends @NonNull Object> {
    ...
  }
\end{Verbatim}

\noindent
Thus, you will get a type error if you write code like
\code{Collection<@Nullable Object>}.
A nullable
type parameter is also forbidden for certain other collections, including
\<AbstractCollection>, \<List>, \<Map>, and \<Queue>.

% AbstractCollection has no documentation of its own regarding nullness,
% but it implements Collection.

% The JML specifications of the add() method says
%       @   signals (NullPointerException)
%       @             (* not allowed to add null *);
%       ...
%       @   signals (NullPointerException)
%       @             (* not allowed to add null *);
% In other words, the method might throw NullPointerException, but the JML
% spec does not say under what circumstances.

The \<extends @NonNull Object> bound is a direct consequence of the design
of the collections classes; it merely formalizes the Javadoc specification.
The Javadoc for \<Collection> states:

\begin{quote}
  Some list implementations have restrictions on the elements that they may
  contain. For example, some implementations prohibit null elements, \ldots
\end{quote}

Here are some consequences of the requirement to detect all nullness errors
at compile time.  If even one subclass of a given collection class may
prohibit null, then the collection class and all its subclasses must
prohibit null.  Conversely, if a collection class is specified to accept
null, then all its subclasses must honor that specification.

The Checker Framework's annotations make apparent a flaw in the JDK
design, and helps you to avoid problems that might be caused by that flaw.


\paragraph{Justification from type theory}
Suppose \<B> is a subtype of \<A>.
Then an overriding method in \<B> must have a stronger (or equal) signature
than the overridden method in~\<A>.  In a stronger signature, the formal
parameter types may be supertypes, and the return type may be a subtype.
Here are examples:

\begin{Verbatim}
  class A           {  @NonNull Object Number m1( @NonNull Object arg) { ... } }
  class B extends A { @Nullable Object Number m1( @NonNull Object arg) { ... } } // error!
  class C extends A {  @NonNull Object Number m1(@Nullable Object arg) { ... } } // OK
  class D           { @Nullable Object Number m2(@Nullable Object arg) { ... } }
  class E extends D {  @NonNull Object Number m2(@Nullable Object arg) { ... } } // OK
  class F extends D { @Nullable Object Number m2( @NonNull Object arg) { ... } } // error!
\end{Verbatim}

According to these rules, since some subclasses of \<Collection> do not
permit nulls, then \<Collection> cannot either:

\begin{Verbatim}
  // does not permit null elements
  class PriorityQueue<E> implements Collection<E> {
    boolean add(E);
    ...
  }
  // must not permit null elements, or PriorityQueue would not be a subtype of Collection
  interface Collection<E> {
    boolean add(E);    
    ...
  }
\end{Verbatim}


\paragraph{Justification from checker behavior}

Suppose that you changed the bound in the \<Collection> declaration to
\<extends @Nullable Object>.  Then, the checker would issue no warning for
this method:

\begin{Verbatim}
  static void addNull(Collection l) {
    l.add(null);
  }
\end{Verbatim}

\noindent
However, calling this method \emph{can} result in a null pointer exception,
for instance caused by the following code:

\begin{Verbatim}
  addNull(new PriorityQueue());
\end{Verbatim}

\noindent
Therefore, the bound must remain as \<extends @NonNull Object>.

By contrast, this code is OK because \<ArrayList> is documented to support
null elements:

\begin{Verbatim}
  static void addNull(ArrayList l) {
    l.add(null);
  }
\end{Verbatim}

\noindent
Therefore, the upper bound in \<ArrayList> is \<extends @Nullable Object>.
Any subclass of \<ArrayList> must also support null elements.




% Every implementation of List seems to permit null.
% Examples of Collection that do not permit null:
% BlockingQueue family:
%   BlockingQueue, BlockingDeque, ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue 
% PriorityQueue
% probably lots of other queues.

% A similar argument applies to \<Map>.
% For example, \<ConcurrentHashMap> and \<Hashtable> implement \<Map> but do
% not permit \<null> to be used as a key or value.  Therefore, \<Map> must
% not permit \<null> to be used as a key or value


% The Checker Framework is designed to warn you whenever your code might
% throw a null pointer exception.  If you want to be safe, you will never put
% \<null> in a \<List> of unknown provenance, because that \<List> might not
% accept null.



\paragraph{Suppressing warnings}

Suppose your program has a list variable, and you know that any list referenced
by that variable will definitely support null.  Then, you can suppress the
warning:

\begin{Verbatim}
  @SuppressWarnings("nullness:generic.argument")
  static void addNull(List l) {
    l.add(null);
  }
\end{Verbatim}

\noindent
You need to use \<@SuppressWarnings("nullness:generic.argument")>
whenever you use a collection that may contain \<null> elements in
contradiction to its documentation.  Fortunately, such uses are relatively
rare.


For more details on suppressing nullness warnings, see
Section~\ref{suppressing-warnings-nullness}.


\section{Is the Checker Framework an official part of Java?\label{faq-checker-framework-part-of-java}}

The Checker Framework is not an official part of Java, though it relies on
type annotations, which are part of Java 8.  See the
\ahref{http://types.cs.washington.edu/jsr308/jsr308-faq.html#checkers-in-java}{Type
  Annotations (JSR 308) FAQ} for more details.


% LocalWords:  IGJ toolset AbstractCollection ConcurrentHashMap NullnessUtils
% LocalWords:  castNonNull createWidget backporting JCIP's GuardedBy Awarns PMD
% LocalWords:  ElementType nullness bytecodes Jlint Hashtable SuppressWarnings
%  LocalWords:  RegexUtil compareTo myA requiresB nullable java
