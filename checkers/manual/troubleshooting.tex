\htmlhr
\chapter{Troubleshooting and getting help\label{troubleshooting}}

Please read the entire manual, including this chapter and the FAQ
(Chapter~\ref{faq}), because the manual might already answer your question.
If not, you can use the mailing list,
\code{checker-framework-discuss@googlegroups.com}, to ask other users for
help.  For archives and to subscribe, see \url{http://groups.google.com/group/checker-framework-discuss}.
To report bugs, use the issue tracker at
\url{http://code.google.com/p/checker-framework/issues/list}.
If you want to help out, you can choose a bug and fix it, or select a
project from the ideas list at
\url{http://code.google.com/p/checker-framework/wiki/Ideas}.


\section{Common problems and solutions\label{common-problems}}

\begin{itemize}
\item
To verify that you are using the compiler you think you are, you can add
\code{-version} to the command line.  For instance, instead of running
\code{javac -g MyFile.java}, you can run \code{javac \underline{-version} -g
  MyFile.java}.  Then, javac will print out its version number in addition
to doing its normal processing.

\end{itemize}



\subsection{Unable to run the checker, or checker crashes\label{common-problems-running}}

If you are unable to run the checker, or if the checker or the compiler
crashes, then the problem may be a problem with your environment.
This section describes some possible problems and solutions.

\begin{itemize}
\item
If you get the error

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
com.sun.tools.javac.code.Symbol$CompletionFailure: class file for com.sun.source.tree.Tree not found
\end{Verbatim}
% Unconfuse Emacs by matching the "$" in the above Verbatim
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
then you are using the source installation and file \code{tools.jar} is not
on your classpath.  See the installation instructions
(Section~\ref{installation}).

\item
If you get an error such as

\begin{Verbatim}
package checkers.nullness.quals does not exist
\end{Verbatim}

  \noindent
  despite no apparent use of \code{import checkers.nullness.quals.*;} in
  the source code, then perhaps
  \code{jsr308\_imports} is set as a Java system property, a shell
  environment variable, or a command-line option (see
  Section~\ref{jsr308_imports}).  You can solve this by unsetting the
  variable/option, or by ensuring that the \code{checkers.jar} file is on
  your classpath.

If the error is 

\begin{Verbatim}
package 'checkers.nullness.quals does not exist
\end{Verbatim}

\noindent
(note the extra apostrophe!), then you have probably misused quoting when
supplying the \code{jsr308\_imports} environment variable.

\item
If you get an error like the following when using the Ant task
(Section~\ref{ant-task}),

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
...\build.xml:59: Error running ${env.CHECKERS}\binary\javac.bat compiler
\end{Verbatim}
% Unconfuse Emacs by matching the "$" in the above Verbatim
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
then the problem may be that you have not set the CHECKERS environment
variable, as described in Section~\ref{windows-installation}.  Or, maybe
you made it a user variable instead of a system variable.

\item
If you get one of these errors:

\begin{alltt}
The hierarchy of the type \emph{ClassName} is inconsistent

The type com.sun.source.util.AbstractTypeProcessor cannot be resolved.
  It is indirectly referenced from required .class files", 
\end{alltt}

\noindent
then you are missing \code{jsr308-all.jar} from your classpath.

\item
If you get the error

\begin{Verbatim}
  java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy
\end{Verbatim}

\noindent
% I'm not 100% sure of the following explanation and solution.
then an annotation is not present at run time that was present at compile
time.  For example, maybe when you compiled the code, the \<@Nullable>
annotation was available, but it was not available at run time.
You can use JDK 8 at run time, or compile
with a Java 7 compiler that will ignore the annotations in comments.

\item
A ``class file not found'' error may be due to a JDK version mismatch.
For instance, you might be using JDK 7, but you get an error that refers to a class that was in a
previous version of the JDK but has subsequently been removed, such as:

\begin{Verbatim}
  class file for java.io.File$LazyInitialization not found
  class file for java.util.Hashtable$EmptyIterator not found
  java.lang.NoClassDefFoundError: java/util/Hashtable$EmptyEnumerator
\end{Verbatim}

Or, you might be using JDK 6, but you get an error that refers to a class
that has been introduced in a newer version of the JDK, such as:

\begin{Verbatim}
  class file for java.util.Vector$Itr not found
\end{Verbatim}
% To unconfuse Emacs's LaTeX mode: $

This problem occurs when your classpath contains code that was compiled
with one version of the JDK and refers to its implementation details, but
your classpath does not contain that version of the JDK itself.

You can solve the problem by re-generating \code{jdk/jdk.jar} and
\code{binary/jdk.jar}.  You can do this by running

\begin{Verbatim}
  cd checkers
  ant jdk.jar bindist
\end{Verbatim}


\item
A \<NoSuchFieldError> such as this:

\begin{Verbatim}
java.lang.NoSuchFieldError: NATIVE_HEADER_OUTPUT
\end{Verbatim}

\noindent
Field \<NATIVE\_HEADER\_OUTPUT> was added in JDK 8.
The error message suggests that
you're not executing with the right bootclasspath: some classes were
compiled with the JDK 8 version and expect the field, but you're
executing the compiler on a JDK without the field.

One possibility is that you are not running the Type Annotations compiler
--- use \<javac -version> to check this, then use the right one.  (Maybe
the Type Annotations javac is at the end rather than the beginning of your
path.)

If you are using Ant, then one possibility
is that the javac compiler is using the same JDK as Ant is using.  You can
correct this by being sure to use \<fork="yes"> (see
Section~\ref{ant-task}) and/or setting the \<build.compiler> property to
\<extJavac>.

If you are building from source, you might need to rebuild the Annotation
File Utilities before recompiling or using the Checker Framework.


\item
If you get an error that contains lines like these:

\begin{Verbatim}
Caused by: java.util.zip.ZipException: error in opening zip file
	at java.util.zip.ZipFile.open(Native Method)
	at java.util.zip.ZipFile.<init>(ZipFile.java:131)
\end{Verbatim}

\noindent
then one possibility is that you have installed the Checker Framework in a
directory that contains special characters that Java's ZipFile
implementation cannot handle.  For instance, if the directory name contains
``\<+>'', then Java 1.6 throws a ZipException, and Java 1.7 throws a
FileNotFoundException and prints out the directory name with ``\<+>''
replaced by blanks.

\end{itemize}


\subsection{Unexpected type-checking results\label{common-problems-typechecking}}

This section describes possible problems that can lead the type-checker to
give unexpected results.


\begin{itemize}
\item
  If the Checker Framework is unable to verify a property that you know is
  true, then it is helpful to formulate an argument about why the property
  is true.  Recall that the Checker Framework does modular verification,
  one procedure at a time; it observes the specifications, but not the
  implementations, of other methods.

  If any aspects of your argument are not expressed as annotations, then
  you may need to write more annotations.  If any aspects of your argument
  are not expressible as annotations, then you may need to extend the
  type-checker.

\item
If a checker seems to be ignoring the annotation on a method, then it is
possible that the checker is reading the method's signature from its
\code{.class} file, but the \code{.class} file was not created by the JSR
308 compiler.  You can check whether the annotations actually appear in the
\code{.class} file by using the \code{javap} tool.

If the annotations do not appear in the \code{.class} file, here are two
ways to solve the problem:
\begin{itemize}
\item
  Re-compile the method's class with the Type Annotations compiler.  This will
  ensure that the type annotations are written to the class file, even if
  no type-checking happens during that execution.
\item
  Pass the method's file explicitly on the command line when type-checking,
  so that the compiler reads its source code instead of its \code{.class}
  file.
\end{itemize}

\item
If the compiler reports that it cannot find a method from the
JDK or another external library, then maybe the stub/skeleton file for that
class is incomplete.  You can edit it to add the missing method.  The
libraries appear, for example, at \code{checkers/jdk/nullness/src/} for the
Nullness checker.

The error might take one of these forms:

\begin{Verbatim}
method sleep in class Thread cannot be applied to given types
cannot find symbol: constructor StringBuffer(StringBuffer)
\end{Verbatim}

\item
If you get an error related to a bounded type parameter and a literal such
as \<null>, the problem may be missing defaulting.  Here is an example:

\begin{Verbatim}
mypackage/MyClass.java:2044: warning: incompatible types in assignment.
      T retval = null;
                 ^
  found   : null
  required: T extends @MyQualifier Object
\end{Verbatim}

\noindent
A value that can be assigned to a variable of type \<T extends @MyQualifier
Object> only if that value is of the bottom type, since the bottom type is
the only one that is a subtype of every subtype of \<T extends @MyQualifier
Object>.  The value \<null> satisfies this for the Java type system, and it
must be made to satisfy it for the pluggable type system as well.  The
typical way to address this is to write the meta-annotation
\<@ImplicitFor(trees={Tree.Kind.NULL\_LITERAL})> on the definition of the
bottom type qualifier.

\end{itemize}


\subsection{Unable to build the checker, or to run programs\label{common-problems-running-java}}

An error like this

\begin{Verbatim}
Unsupported major.minor version 51.0
\end{Verbatim}

means that you have compiled some files into the Java 7 format (version
51.0), but you are trying to run them with Java 6.  Run \<java -version> to
determine the version of Java you are using and use a newer version,
and/or use the \<-target>
command-line option to \<javac> to specify the version of the class files
that are created, such as \<javac -target 6 ...>.



%% Commented out because these are not very helpful in terms of helping
%% a reader understand whether he/she is encountering the specific problem,
%% and because the issue tracker is a better way to find out about current
%% known problems.
%
% \subsection{Known problems in the framework\label{known-problems}}
% 
% \begin{itemize}
% 
% \item
%   The framework may not parse annotations from skeleton files if the
%   skeleton files are older than the classfiles.  Running \code{ant
%     touch-jdk} solves this problem, by applying the 
%   \code{touch} program to each distributed skeleton file.
% 
% % Mahmood will address.  -MDE 3/19/2009
% \item The framework is missing a check for type argument subtyping in
%   method invocations if the type arguments are inferred.
% 
% % Mahmood will address.  -MDE 3/19/2009
% \item The checks for enclosed types are not yet fully tested.
% 
% \end{itemize}
% 
% \subsection{Known problems in the Nullness checker}
% 
% \begin{itemize}
% \item
%   The Nullness checker is often able to determine that a call to
%   \code{Map.get()} will not return null.  This enables the checker to avoid
%   issuing false positive warnings, in circumstances like the following.
% 
% \begin{Verbatim}
%     @NonNull String value;
%     if (myMap.containsKey(key)) {
%       value = myMap.get(key);
%     }
%     for (String keyInMap : myMap.keySet()) {
%         value = myMap.get(keyInMap);
%     }
% \end{Verbatim}
% 
%   The Nullness checker can sometimes fail to issue a warning if the map is
%   modified or re-assigned between the check of \code{containsKey} and the
%   call to \code{get}.
% 
% % This description really needs an example of a case where the checker
% % fails.  Right now, it is impossible for a reader to tell what the problem
% % is or whether a particular piece of code triggers it.
% % Do we have a test case?
% 
% 
% % The solution is to merge flow with the Map.get heuristics.
% % And to do forward instead of backward analysis.
% 
% 
% \end{itemize}


\section{How to report problems (bug reporting)\label{reporting-bugs}}

If you have a problem with any checker, or with the Checker Framework,
please file a bug at 
\url{http://code.google.com/p/checker-framework/issues/list}.
(First, check whether there is an existing bug report for that issue.)

Alternately (especially if your communication is not a bug report), you can
send mail to checker-framework-dev@googlegroups.com.
We welcome suggestions, annotated libraries, bug fixes, new
features, new checker plugins, and other improvements.

Please ensure that your bug report is clear and that it is complete.
Otherwise, we may be unable to understand it or to reproduce it, either of
which would prevent us from fixing the bug.  Your bug report will be most
helpful if you:

\begin{itemize}
\item
  Add \code{-version -verbose -AprintErrorStack -printAllQualifiers} to the javac options.  This causes the compiler to output
  debugging information, including its version number.
\item
  Indicate exactly what you did.  Don't skip any steps, and don't merely
  describe your actions in words.  Show the exact commands by attaching a
  file or using cut-and-paste from your command shell;
\item
  Include all files that are necessary to reproduce the problem.  This
  includes every file that is used by any of the commands you reported, and
  possibly other files as well.
\item
  Indicate exactly what the result was by attaching a file or using
  cut-and-paste from your command shell (don't merely describe it in
  words).  Also indicate what you expected the result to be --- remember, a
  bug is a difference between desired and actual outcomes.
\end{itemize}

A particularly useful format for a test case is as a new file, or a diff to
an existing file, for the existing Checker Framework test suite.  For
instance, for the Nullness
Checker, see directory \<checker-framework/checkers/tests/nullness/>.
But, please report your bug even if you do not report it in this format.


\section{Building from source\label{build-source}}

The Checker Framework release (Section~\ref{installation}) contains
everything that most users need, both to use the distributed checkers and
to write your own checkers.  This section describes how to compile its
binaries from source.  You will be using the latest development version of
the Checker Framework, rather than an official release.

% Doing
% so permits you to examine and modify the implementation of the distributed
% checkers and of the checker framework.  It may also help you to debug
% problems more effectively.


\subsection{Obtain the source}

Obtain the latest source code from the version control repository:

\begin{Verbatim}
export JSR308=$HOME/jsr308
mkdir -p $JSR308
cd $JSR308
hg clone https://code.google.com/p/jsr308-langtools/ jsr308-langtools
hg clone https://code.google.com/p/checker-framework/ checker-framework
hg clone https://code.google.com/p/annotation-tools/ annotation-tools
\end{Verbatim}
% $ to unconfuse Emacs LaTeX mode

\noindent
(Alternately, you could use the version of the source code that is packaged
in the Checker Framework release.)

% TODO: the AFU and JSR 308 source code is not included in the
% checkers.zip file!


\subsection{Build the Type Annotations compiler}

\begin{enumerate}
\item
% Why is this necessary?  What goes wrong if it is not set?  Can I avoid
% the need to set it?  It's used for:
%  * the location of tools.jar, below.
%  * the default location of RTJAR, in checkers/jdk/Makefile.
Set the \<JAVA\_HOME> environment variable to the location of your JDK 
7 installation (not the JRE installation, and not JDK 6).
This needs to be an Oracle JDK.
(The \<JAVA\_HOME> environment
variable might already be set, because it is needed for Ant to work.)

In the bash shell, the following command \emph{sometimes} works (it might
not because \<java> might be the version in the JDK or in the JRE):
% Can someone give a simpler command?
\begin{Verbatim}
  export JAVA_HOME=${JAVA_HOME:-$(dirname $(dirname $(dirname $(readlink -f $(/usr/bin/which java)))))}
\end{Verbatim}

% # To build your own JDK:
% mkdir -p /scratch/$USER/jdk7
% cd /scratch/$USER/jdk7
% wget http://docs.oracle.com/otn-pub/java/jdk/7/jdk-7-linux-x64.tar.gz
% tar xzf jdk-7-linux-x64.tar.gz
% export JAVA_HOME=/scratch/$USER/jdk7/jdk1.7.0
% export PATH=${JAVA_HOME}/bin:${PATH}

\item
Compile the Type Annotations javac compiler and the javap tool:

\begin{Verbatim}
  cd $JSR308/jsr308-langtools/make
  ant clean build-javac build-javap
\end{Verbatim}

\item
 Add the \<jsr308-langtools/dist/bin> directory to the front of your PATH environment variable.
  Example command:

\begin{Verbatim}
  export PATH=$JSR308/jsr308-langtools/dist/bin:${PATH}
\end{Verbatim}

\end{enumerate}

% JSR 308 extends the Java language to permit annotations to appear on types,
% as in \code{List<@NonNull String>} (see Section~\ref{writing-annotations}).
% This change will be part of the Java 8 language.  We recommend that you
% write annotations in comments, as in \code{List</*@NonNull*/ String>} (see
% Section~\ref{annotations-in-comments}).  The JSR 308 compiler still reads
% such annotations, but this syntax permits you to use a compiler other than
% the JSR 308 compiler.  For example, you can compile your code with a Java 5
% compiler, and you can use a checker as an external tool in an IDE.



\subsection{Build the Annotation File Utilities\label{afu-building}}

This is simply done by:

\begin{Verbatim}
  cd $JSR308/annotation-tools
  ant
\end{Verbatim}

You do not need to add the Annotation File Utilities to the path, as
the Checker Framework build finds it using relative paths.


\subsection{Build the Checker Framework\label{building}}

% Building (compiling) the checkers and framework from source creates the
% \code{checkers.jar} file.  A pre-compiled \code{checkers.jar} is included
% in the distribution, so building it is optional.  It is mostly useful for
% people who are developing compiler plug-ins (type-checkers).  If you only
% want to \emph{use} the compiler and existing plug-ins, it is sufficient to
% use the pre-compiled version.

\begin{enumerate}
% \item
% Edit \code{checkers/build.properties} file so that the
% \code{compiler.lib} property specifies the location of the JSR 308
% \code{javac.jar} library.  (If you also installed the JSR 308 compiler from
% source, and you made the \code{checkers} and \code{jsr308-langtools} directories
% siblings, then you don't need to edit \code{checkers/build.properties}.)

\item
Run \code{ant} to create \<checkers.jar>:

\begin{Verbatim}
  cd $JSR308/checker-framework/checkers
  ant
\end{Verbatim}
% $ to unconfuse Emacs LaTeX mode

\item Add \code{tools.jar} and \code{checkers.jar} to your classpath.
  (If you do not do this, you will have to supply the \code{-cp} option
  whenever you run \code{javac} and use a checker plugin.)
  Example command:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  export CLASSPATH=${CLASSPATH}:$JAVA_HOME/lib/tools.jar:$JSR308/checker-framework/checkers/checkers.jar
\end{Verbatim}
% $ to unconfuse Emacs LaTeX mode
%BEGIN LATEX
\end{smaller}
%END LATEX
  %% In Cygwin, are reversed slashes required?

\item Test that everything works:

  \begin{itemize}

  \item Run \code{ant all-tests} in the \code{checkers} directory:
\begin{Verbatim}
  cd $JSR308/checker-framework/checkers
  ant all-tests
\end{Verbatim}
% $ to unconfuse Emacs LaTeX mode

  \item Run the Nullness checker examples (see
    Section~\refwithpage{nullness-example}).

  \end{itemize}

\end{enumerate}

\subsection{Build the Checker Framework manual (this document)}

\begin{enumerate}
\item
To build the manual you will need plume-bib (\myurl{http://code.google.com/p/plume-bib/}) and {\hevea} (\myurl{http://hevea.inria.fr/}) installed.

\item
Run \code{make} in the \code{checkers/manual} directory to build both the PDF and HTML versions of the manual.
\end{enumerate}

% \subsection{Adjust classpath}

% Building the Checker Framework requires use of a Java 8 compiler.  You may
% use either the OpenJDK compiler or the JSR 308 compiler.  The latter has a
% few extra features and tends to get bug fixes more quickly.

% The following instructions give detailed steps for installing the source
% release of the Checker Framework.


% \item Download and install the JSR 308 implementation; follow the instructions at
% % alternative: \urldef{\JsrInstallingUrl}\url{http://types.cs.washington.edu/checker-framework/current/README-jsr308.html#installing}
% {\codesize\url{http://types.cs.washington.edu/checker-framework/current/README-jsr308.html#installing}}.
% This creates a \code{jsr308-langtools} directory.
% 
% \item Download the Checker Framework distribution zipfile from
% \myurl{http://types.cs.washington.edu/checker-framework/current/checkers.zip},
% and unzip it to create a \code{checkers} directory.  We recommend that the
% \code{checkers} directory and the \code{jsr308-langtools} directory be siblings.
% Example commands:
% 
% \begin{Verbatim}
%   cd $JSR308
%   wget http://types.cs.washington.edu/checker-framework/current/checkers.zip
%   unzip checkers.zip
% \end{Verbatim}
% 
% You will also need to adjust the path to \<javac> in any Ant buildfiles,
% etc.

% \item Optionally edit property \code{compiler.lib} in file
%   \code{checkers/build.properties}.  You don't have to do this if the
%   \code{checkers} directory and the \code{jsr308-langtools} directory are
%   siblings.


% (A checkers implementation builds on
% standard mechanisms such as JSR 269 annotation processing, but also
% accesses the compiler's AST. In the long run, a checker built using the
% Checker Framework should not be dependent on any compiler specifics.)
% If you do not place the annotations in 
% then you should also disable Eclipse's on-the-fly syntax checking.




% \subsection{TO DO:  The short instructions (for Linux only)}
% 
% %%% This comment does not seem to be correct any longer.
% %% This text is identically reproduced at ../../jsr308-langtools/README-jsr308.html
% %% so if you change either one, change the other also!
% 
% The following commands install
% the JSR 308 \code{javac} compiler and the Checker
% Framework, or update an existing installation.
% It currently works only on \textbf{Linux}.
% For more details, or if anything goes wrong, see the comments in the 
% \code{Makefile-jsr308-install} file.
% 
% \begin{enumerate}
% 
% \item
%   Execute the following commands:
% 
% \begin{Verbatim}
%   cd
%   wget -nv -N http://types.cs.washington.edu/jsr308/Makefile-jsr308-install
%   make -f Makefile-jsr308-install
% \end{Verbatim}
% 
% \item
% Set some environment variables according to the instructions at the top of file
% \code{Makefile-jsr308-install}.
% 
% \end{enumerate}



\section{Learning more\label{learning-more}}

The technical paper ``Practical pluggable types for Java''~\cite{PapiACPE2008}
(\myurl{http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008.pdf})
gives more technical detail about many
aspects of the Checker Framework and its implementation.
%
The technical
paper also describes case
studies in which each of the checkers found
previously-unknown errors in real software.

The paper ``Building and using pluggable type-checkers''~\cite{DietlDEMS2011}
(\myurl{http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-icse2011.pdf})
discusses further experience with the Checker Framework, increasing the
number of lines of verified code to 3 million.

In addition to these papers that discuss use the Checker Framework
directly, other academic papers use the Checker Framework in their
implementation or evaluation.  Most educational use of the Checker
Framework is never published, and most commercial use of the Checker
Framework is never discussed publicly.


\section{Comparison to other tools\label{other-tools}}

A pluggable type-checker, such as those created by the Checker Framework,
aims to help you prevent or detect all errors of a given variety.  An
alternate approach is to use a bug detector such as
\ahref{http://findbugs.sourceforge.net/}{FindBugs},
\ahref{http://jlint.sourceforge.net/}{Jlint}, or
\ahref{http://pmd.sourceforge.net/}{PMD}.

A pluggable type-checker
differs from a bug detector in several ways:
\begin{itemize}
\item
  A type-checker aims to find \emph{all} errors.  Thus, it can verify the
  \emph{absence} of errors:  if the type checker says there are no null
  pointer errors in your code, then there are none.  (This guarantee only
  holds for the code it checks, of course; see
  Section~\ref{checker-guarantees}.)

  A bug detector aims to find \emph{some} of the most obvious errors.  Even
  if it reports no errors, then there may still be errors in your code.

  Both types of tools may issue false positive warnings; see
  Section~\ref{suppressing-warnings}.

\item
  A type-checker requires you to annotate your code with type qualifiers,
  or to run an inference tool that does so for you.  A bug detector may not
  require annotations.  This means that it may be easier to get started
  running a bug detector.

\item
  A type-checker may use a more sophisticated and complete analysis.
  A bug detector typically does a more lightweight analysis, coupled with
  heuristics to suppress false positives.

  As one example, a type-checker can take advantage of annotations on
  generic type parameters, such as \code{List<@NonNull String>}, permitting
  it to be much more precise for code that uses generics.

\end{itemize}

A case study~\cite[\S6]{PapiACPE2008} compared the Checker Framework's nullness
checker with those of FindBugs, Jlint, and PMD\@.  The case study was on a
well-tested program in daily use.  The Checker Framework tool found 8
nullness errors (that is, null pointer dereferences).  None of the other
tools found any errors.

Also see the
\ahref{http://types.cs.washington.edu/jsr308/}{JSR 308}~\cite{JSR308-2008-09-12}
documentation for a detailed discussion of related work.



\section{Credits and changelog\label{credits}}

The key developers of the Checker Framework are Mahmood Ali, Telmo Correa,
Werner M. Dietl, Michael D. Ernst, and Matthew M. Papi.
Many other developers have also contributed, for example by writing
the checkers that are distributed with the Checker Framework.
Many, many users to list have provided valuable feedback, for which we are
grateful.

%% Not so accurate, since Mahmood is really an author of the nullness and
%% interned checkers too.
% The Checker Framework was implemented by 
% The nullness checker was implemented by Matthew M. Papi.
% The interning checker was implemented by Matthew M. Papi.
% The Javari checker was implemented by Telmo Correa.
% The IGJ checker was implemented by Mahmood Ali.
% The basic checker was implemented by Matthew M. Papi.
% The Fake enum checker was written by Werner M. Dietl.
% ... many others ...

Differences from previous versions of the checkers and framework can be found
in the \code{changelog-checkers.txt} file.  This file is included in the
Checker Framework distribution and is also available on the web at
\myurl{http://types.cs.washington.edu/checker-framework/current/changelog-checkers.txt}.






% LocalWords:  jsr unsetting plugins langtools zipfile cp plugin Nullness txt
% LocalWords:  nullness classpath NonNull MyObject javac uref changelog MyEnum
% LocalWords:  subtyping containsKey proc classfiles SourceChecker javap jdk
% LocalWords:  MyFile buildfiles ClassName JRE java jsr308 bootclasspath
%  LocalWords:  extJavac ZipFile AprintErrorStack printAllQualifiers Jlint
%  LocalWords:  Telmo Correa Papi
